[//]: # "java"

# Wydania

[//]: # "releases"

| Version              | Release date   | End of Free Public Updates                                   | Extended Support Until                                       |
| :------------------- | :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| JDK Beta             | 1995           | ?                                                            | ?                                                            |
| JDK 1.0              | January 1996   | ?                                                            | ?                                                            |
| JDK 1.1              | February 1997  | ?                                                            | ?                                                            |
| J2SE 1.2             | December 1998  | ?                                                            | ?                                                            |
| J2SE 1.3             | May 2000       | ?                                                            | ?                                                            |
| J2SE 1.4             | February 2002  | October 2008                                                 | February 2013                                                |
| J2SE 5.0             | September 2004 | November 2009                                                | April 2015                                                   |
| Java SE 6            | December 2006  | April 2013                                                   | December 2018 December 2023, paid support for Zulu[[8\]](https://en.wikipedia.org/wiki/Java_version_history#cite_note-Zulu-8) |
| Java SE 7            | July 2011      | April 2015                                                   | July 2022                                                    |
| **Java SE 8 (LTS)**  | March 2014     | January 2019 for Oracle (commercial) <br />December 2030 for Oracle (non-commercial) <br />December 2030 for Zulu <br />At least May 2026 for AdoptOpenJDK <br />At least May 2026 for Amazon Corretto | December 2030                                                |
| Java SE 9            | September 2017 | March 2018 for OpenJDK                                       | N/A                                                          |
| Java SE 10           | March 2018     | September 2018 for OpenJDK                                   | N/A                                                          |
| **Java SE 11 (LTS)** | September 2018 | September 2027 for Zulu <br />At least October 2024 for AdoptOpenJDK <br />At least September 2027 for Amazon Corretto | September 2026, or September 2027 for e.g. Zulu              |
| Java SE 12           | March 2019     | September 2019 for OpenJDK                                   | N/A                                                          |
| Java SE 13           | September 2019 | March 2020 for OpenJDK                                       | N/A                                                          |
| Java SE 14           | March 2020     | September 2020 for OpenJDK                                   | N/A                                                          |
| Java SE 15           | September 2020 | March 2021 for OpenJDK, <br />March 2023 for Zulu            | N/A                                                          |
| Java SE 16           | March 2021     | September 2021 for OpenJDK                                   | N/A                                                          |
| **Java SE 17 (LTS)** | September 2021 | September 2030 for Zulu                                      | TBA                                                          |

Wynika stąd, że wersja 8 będzie miała wsparcie do 2026. Następna wersja LTS to 11 która ma miec wsparcie do 2024. Troche dziwne, ze 8 ma dłuższe wsparcie niż 11. Następna LTS to 17 która ma mieć wsparcie do 2030.
## Kompatybilność
Można wyróżnić kompatybilność:

1. kodów źródłowych,
2. kodów binarnych
3. zachowania

**Kodów źródłowych** - kompatybilność polega na tym, że jeśli dany kod kompiluje się na określonych wersjach JVM to oznacza, że są kompatybilne z poziomu kodów źródłowych

**Kodów binarnych** - jest to kompatybilność na poziomie kodu JVM

Zachowania - ten typ kompatybilności mówi o spójnym zachowniu. Czyli jak kod zachowuje się tak samo na różnych wersjach to oznacza, że jest kompatybilny.

# Budowanie
W ekosystemie Javy jest kilka narzędzi do pakowania aplikacji. Między innymi są to:

- Ant,
- Maven,
- Ivy (kontunuacja Anta),
- Make,
- Builder,
- Gradle.
## Rodzaje pakietów

Java udostępnia udostępnia różne sposoby pakowania kodu źródłowego.

| Typ    | Opis                                                         |
| ------ | ------------------------------------------------------------ |
| JAR    | Jest to standardowy format pakowania aplikacji w Javie. W zasadzie są to skompilowane pliki, zasoby, metadane itp. do pliku zip tylko z rozszerzeniem JAR. Tak spakowana aplikacja może być biblioteką lub plikiem wykonywalnym. |
| MRJAR  | Jest to rozszerzenie formatu JAR. Rozszerzenie polega na tym, że możliwe jest przechowywanie różnych kompilacji źródeł dla różnych wersji Javy. To jest ważna cecha ponieważ standardowy JAR bywał problematyczny ze względu na to na której Javie miał być uruchamiany. Powodowało to wiele trudności. Jeden pakiet w Javie 9 inny 8 itp. |
| JMOD   | Ten format wszedł od Javy 9. Przechowuje on wszystkie inne zasoby, które nie mogą zostać spakowane do pliku JAR. Plik JMOD jest także oparty na archiwum ZIP. **Plik JMOD w odróżnieniu do JAR nie jest wykonywalny, musi zostać dołączony w trakcie pakowania.** Do budowania tego typu paczki używamy polecenie `jmod`. |
| JIMAGE | Podobnie jak JMOD ten format który pojawił się od wersji Java 9. Przechowuje on zoptymalizowany zasoby pod kątem uruchomienia oraz szybkości działa pod określone JDK. Do tworzenia tego typu pliku używamy polecenie JLINK. |

MRJAR - poniżej umieszczam przykładową strukturę takiego archiwum.

```
- jar-root
   - A.class
   - B.class
   - C.class
- META-INF
- MANIFEST.MF
- version
- 8
   - A.class
   - B.class
- 9
   - C.class
   - D.class
```
## Ant

[//]: "ant"

Jest to jeden z pierwszym narzędzi (nie licząc narzędzia Make) do budowania aplikacji pisanych w Javie. Ant jest bardzo podobny do narzędzia Make. Cały proces pakowania jest opisany w pliku Xml.

Poniżej taki przykładowy plik konfiguracji.

```xml
<project>
    <target name="clean">
        <delete dir="classes" />
    </target>
 
    <target name="compile" depends="clean">
        <mkdir dir="classes" />
        <javac srcdir="src" destdir="classes" />
    </target>
 
    <target name="jar" depends="compile">
        <mkdir dir="jar" />
        <jar destfile="jar/HelloWorld.jar" basedir="classes">
            <manifest>
                <attribute name="Main-Class" 
                  value="antExample.HelloWorld" />
            </manifest>
        </jar>
    </target>
 
    <target name="run" depends="jar">
        <java jar="jar/HelloWorld.jar" fork="true" />
    </target>
</project>
```
### Budowanie modułów

[//]: "build-modules"

```xml
<project name="MyProject" basedir="." default="text">

    <property name="version" value="1.1.1"/>
    <property name="javahome" value="C:\Program Files\Java\jdk-9.0.4\"/>

    <target name="clean">
        <delete dir="out-build"/>
        <mkdir  dir="out-build"/>
        <mkdir  dir="out-build/java"/>
        <mkdir  dir="out-build/java/com.nanosai.memops"/>
    </target>

    <target name="copy-source">
        <copydir src="src/main/java" dest="out-build/java/com.nanosai.memops" />
    </target>


    <target name="compile">
        <exec executable="${javahome}\bin\javac" dir="${basedir}">
            <arg value="-d"/>
            <arg value="out-build/classes"/>
            <arg value="--module-source-path"/>
            <arg value="out-build/java"/>
            <arg value="--module"/>
            <arg value="com.nanosai.memops"/>
        </exec>
    </target>

</project>
```

### Pakowanie modułów
[//]: "package-modules"

```xml
<project name="MyProject" basedir="." default="text">

    <property name="version" value="1.1.1"/>
    <property name="javahome" value="C:\Program Files\Java\jdk-9.0.4\"/>

    <target name="clean">
        <delete dir="out-build"/>
        <mkdir  dir="out-build"/>
        <mkdir  dir="out-build/java"/>
        <mkdir  dir="out-build/java/com.nanosai.memops"/>
    </target>

    <target name="copy-source">
        <copydir src="src/main/java" dest="out-build/java/com.nanosai.memops" />
    </target>


    <target name="compile">
        <exec executable="${javahome}\bin\javac" dir="${basedir}">
            <arg value="-d"/>
            <arg value="out-build/classes"/>
            <arg value="--module-source-path"/>
            <arg value="out-build/java"/>
            <arg value="--module"/>
            <arg value="com.nanosai.memops"/>
        </exec>
    </target>

    <target name="package-jar">
        <exec executable="${javahome}\bin\jar" dir="${basedir}">
            <arg value="-c"/>
            <arg value="--file=out-build/com-nanosai-memops.jar"/>
            <arg value="-C"/>
            <arg value="out-build/classes/com.nanosai.memops"/>
            <arg value="."/>
        </exec>
    </target>

</project>
```

## Gradle

[//]: "gradle"

Gradle jest narzędziem służącym do budowania projektów. Pozwala ono na zautomatyzowanie tego procesu. Używa się do tego tak zwanego języka domenowego – **DSL** (ang. *Domain Specific Language*), który ułatwia wykonywanie standardowych zadań związanych z budowaniem projektu.

Gradle do działania potrzebuje konfiguracji. Domyślnie konfigurację umieszcza się w pliku `build.gradle`. Wewnątrz tego pliku możemy umieszczać komendy, które następnie zostaną wykonane przez `gradle`. Poniżej pokażę kilka podstawowych konstrukcji dostępnych w DSL dostarczonym przez Gradle.

Przykładowa konfiguracja:

```
task runAllTests {
    println 'now I am checking if all tests are passing, in theory'
}

task buildJar(dependsOn: runAllTests) {
    println 'now I am building JAR file, in theory'
}
```
## Maven

[//]: "maven"

Jest to jedno z narzędzi do budowania aplikacji w Javie. Maven buduje aplikacje na postawie pliku konfiguracyjnego `pom.xml`. W zasadzie podstawowa konfiguracja jest wystarczająca do utworzenie aplikacji.

Maven w odróżnieniu od `Ant, make, webpack` ma określoną strukturę, dzięki czemu nie trzeba na początku poświęcać czasu na to w jaki sposób zbudować aplikację lub dla każdej aplikacji tworzyć różne skrypty do budowania aplikacji.
### Semantyka wersji
[//]: "version-semantics"
W Mavenie przyjął się uproszczony schemat wersjonowania.

- `1.2.3-beta.4-SNAPSHOT`: A snapshot version of a pre-release version.
- `1.2.3-SNAPSHOT`: A snapshot version of a release version.
- `1.2.3-beta.4`: A stable version of a pre-release version.
- `1.2.3`: A release version (which is a stable, non-snapshot version, obviously).
### Tworzenie projektu
[//]: "init-project"
Za stworzenie podstawowej struktury projektu jest odpowiedzialny Maven. Podstawowy projekt jest tworzony poleceniem.

```shell
mvn archetype:generate -DgroupId=com.httpio.app -DartifactId=httpio -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
```

- `groupId` jest to ogólna grupa (jest to również ścieżka do paczki w kodzie),
- `artifactId`unikalna nazwa w ramach grupy.
- `archetypeVersion=1.4` wersja archetypu, np. wersja `1.0` ma ograniczony plik `pom.xml` do podstawowych opcji.

Po utworzeniu mamy następującą strukturę projektu.

```
httpio
|-- pom.xml
`-- src
    |-- main
    |   `-- java
    |       `-- com
    |           `-- mycompany
    |               `-- app
    |                   `-- App.java
    `-- test
        `-- java
            `-- com
                `-- mycompany
                    `-- app
                        `-- AppTest.java
```

Plik `pom.xml` stanowi rdzeń konfiguracji projektu w Maven. Jest to pojedynczy plik konfiguracyjny, który zawiera większość informacji wymaganych do zbudowania projektu w odpowiedni sposób. POM jest ogromny i może być zniechęcający w swojej złożoności, ale nie jest konieczne zrozumienie wszystkich zawiłości, które jeszcze nie zostały skutecznie wykorzystane.

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.mycompany.app</groupId>
  <artifactId>my-app</artifactId>
  <version>1.0-SNAPSHOT</version>

  <properties>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>
```

Tak stworzony projekt jest gotowy do zbudowania. Aby zbudować projekt wywołujemy polecenie.

```shell
mvn package
```

W trakcie pakowania wykonywane są wszystkie fazy projektu przez walidację, testy jednostkowe itp.

Plik wykonywalny może zostać uruchomiony poleceniem.

```shell
java -cp target/httpio-1.0-SNAPSHOT.jar com.mycompany.app.App

### -cp <class search path of directories and zip/jar files>
```

### Zasoby
[//]: "resources"
| Nazwa              | Odwołanie                                                    |
| ------------------ | ------------------------------------------------------------ |
| Maven in 5 minutes | https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html |
### Standardowa struktura katalogów
[//]: "directories-structure"
- `src/main/java` - kod źródłowy,
- `src/main/resources` - zasoby takie jak obrazki itp. ,
- `src/main/filters` - Resource filters, in the form of properties files, which may be used to define variables only known at runtime
- `src/main/config` - Configuration files
- `src/main/webapp` - The Web application directory for a WAR project
- `src/test/java` - Unit tests
- `src/test/resources` - Resources to be used for unit tests, but will not be deployed
- `src/test/filters` - Resources filters to be used for unit tests, but will not be deployed
- `src/site` - Files used to generate the Maven project Website
### Fazy projektu
[//]: "project-phases"
Działanie Mavena opiera się na fazach projektu (jest to przykładowa lista faz projektu):

- `generate-sources`: Generates any extra source code needed for the application, which is generally accomplished using the appropriate `plug-ins`
- `compile`: Compiles the project source code
- `test-compile`: Compiles the project unit tests
- `test`: Runs the unit tests (typically using JUnit) in the src/test directory
- `package`: Packages the compiled code in its distributable format (JAR, WAR, etc.)
- `integration-test`: Processes and deploys the package if necessary into an environment where integration tests can be run
- `install`: Installs the package into the local repository for use as a dependency in other projects on your local machine
- `deploy`: Done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects

Każda z faz może zostać wywołana:

```shell
### mvn {name}
mvn compile
```
### Generowanie strony
[//]: "project-site"
Maven ma możliwość generowania podstawowej strony dla projektu na postawie zdefiniowanych informacji. Stronę można wygenerować poleceniem.

```shell
mvn site
```
### Pakowanie aplikacji
[//]: "package"
Jest to etap gdy chcemy spakować aplikację w jeden wykonywalny plik.

Maven udostępnia kilka rozszerzeń (pluginów) pozwalający na spakowanie aplikacji.

- ręczna konfiguracja,
- Maven Assembly Plugin,
- Apache Maven Shade Plugin,
- One Jar Maven Plugin,
- Spring Boot Maven Plugin,
- Web Application with Executable Tomcat.

Poszczególne metody zostały opisane:

https://www.baeldung.com/executable-jar-with-maven
#### Pakowanie za pomocą Maven Assembly Plugin
http://maven.apache.org/plugins/maven-assembly-plugin/usage.html

Do pliki `pom.xml` dodajemy wtyczkę:

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  ...

  <build>
    ...
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        ...
      </plugins>
    </pluginManagement>
    <plugins>
      ...
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-assembly-plugin</artifactId>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>single</goal>
            </goals>
            <configuration>
              <descriptorRefs>
                <descriptorRef>jar-with-dependencies</descriptorRef>
              </descriptorRefs>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
```

Poleceniem `mvn package` pakujemy aplikację, poleceniem `target/app-jar-with-dependencies.jar` ją uruchamiamy.
### Moduły
[//]: "modules"
Aby utworzyć aplikacje z wieloma modułami w pliku `pom.xml` należy zdefiniować `packaging` na `pom` aby Maven wiedział, że nadrzędny moduł jest rodzicem.

Następnie tworzymy moduły:

```shell
mvn archetype:generate -DarchetypeArtifactId=maven-archetype-quickstart -DgroupId=learn.java  -DartifactId=gui;

## Opcja --batch-mode powoduje, że MVN nie zadanie pytań.
mvn archetype:generate -DarchetypeArtifactId=maven-archetype-quickstart -DgroupId=com.dhl.mango  -DartifactId=mango-be-common 
--batch-mode;
```

W wyniku tej operacji powstaną katalogi z modułami. Moduły od razu zostaną połączone z głównym modułem.

```
├───src
│   ├───main
│   │   └───java
│   │       └───learn
│   │           └───java
│   └───test
│       └───java
│           └───learn
│               └───java
| ...
```

Każdy moduł ma swój osobny plik `pom.xml`. W pliku nadrzędnym `pom.xml` pojawia się informacja o modułach.

```xml
<! --- ... --->
<modules>
    <module>logic</module>
    <module>gui</module>
</modules>
```
### Ustawienia
[//]: "settings"
http://maven.apache.org/ref/3.6.2/maven-settings/settings.html
### Raportowanie
[//]: "reporting"
 https://maven.apache.org/plugins/maven-site-plugin/examples/configuring-reports.html 
### Logowanie
[//]: "logs"
W podstawowej konfiguracji polecenie `mvn` zwraca tylko logi na poziomie `info, worning, error`. W przypadku gdy wystąpi błąd nie wyświetla pełnego traca. 

Istnieje kilka opcji związanych z logowaniem i poziomem logów:

- `-e` wyświetlany będzie cały komunikat błędu,
- `-X, -debug` wyświetlane będą logi z poziomu `debug`,
- `--quiet` nie będą wyświetlane żadne logi,
- `--log-file ./mvn.log` logi zostaną zrzucone do pliku.

Maven korzysta z biblioteki SLF4J do logów. Konfiguracja jest w pliku `${maven.home}/conf/logging/simplelogger.properties`.

```properties
### simplelogger.properties`
org.slf4j.simpleLogger.defaultLogLevel=info
org.slf4j.simpleLogger.showDateTime=false
org.slf4j.simpleLogger.showThreadName=false
org.slf4j.simpleLogger.showLogName=false
org.slf4j.simpleLogger.logFile=System.out
org.slf4j.simpleLogger.cacheOutputStream=true
org.slf4j.simpleLogger.levelInBrackets=true
org.slf4j.simpleLogger.log.Sisu=info
org.slf4j.simpleLogger.warnLevelString=WARNING

### MNG-6181: mvn -X also prints all debug logging from HttpClient
### Be aware that the shaded packages are used
### org.apache.http -> org.apache.maven.wagon.providers.http.httpclient
org.slf4j.simpleLogger.log.org.apache.maven.wagon.providers.http.httpclient=off
org.slf4j.simpleLogger.log.org.apache.maven.wagon.providers.http.httpclient.wire=off
```
### Optymalizacja kompilacji
[//]: "compile-optimization"
Poprawa wykorzystania procesorów i wątków.

```shell
mvn -T 4 install -- will use 4 threads
mvn -T 1C install -- will use 1 thread per available CPU core
```

Wyłączenie testów, jeśli ma być to szybka kompilacja.

```shell
mvn ... DskipTests=true
```

Kompilacja konkretnych modułów razem z zależnościami.

```shell
mvn install -pl $moduleName -am
```

- `-pl` pozwala na zdefiniowanie modułu,
- `-am` moduł jest kompilowany razem z zależnościami.

W przypadku szybkiej kompilacji warto wejść w tryb offline. W tym trybie Maven szukał zależności w repozytorium lokalnym. Ta falga powoduje, że np. niektóre wtyczki które korzystają z internetu nie będą oczekiwały na połączenie.

```shell
mvn ... --offline
```

Możliwe jest również ustawienie `dependencyLocationsEnabled` dla wtyczki `maven-project-info-reports-plugin`.

```xml
<reporting>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-project-info-reports-plugin</artifactId>
            <version>2.7</version>

            <configuration>
                <dependencyLocationsEnabled>false</dependencyLocationsEnabled>
            </configuration>
        </plugin>
    </plugins>
</reporting>
```

Zdefiniowanie opcji JVM dla  Mavena.

```
-XX:+TieredCompilation -XX:TieredStopAtLevel=1
```

Te opcje powinny przyspieszyć samo uruchomienie Mavena.

Podsumowując:

```
MAVEN_OPTS= -XX:+TieredCompilation -XX:TieredStopAtLevel=1
mvn -T 1C install -pl $moduleName -am —offline
```
### Wtyczki

[//]: "plugins"

#### Exec

[//]: "exec"

Wtyczka za pomocą, której można uruchomić program z możliwością konfiguracji. Wtyczka dostarcza dwa polecenia:

- exec:exec - uruchomienie w osobnym procesie,
- exec:java - uruchomienie w ramach tego samego VM co mvn.

W przypadku polecenie `exec:exec` trzeba mieć przygotowany wykonywalny plik np. archiwum `jar`.

Wtyczka pozwala na konfiguracje tego jak zostanie uruchomiony proces za pomocą pliku `pom` lub przez parametry wiersza poleceń. 

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>exec-maven-plugin</artifactId>
            <version>3.0.0</version>
            <executions>
                <execution>
                    <goals>
                        <goal>exec</goal>
                    </goals>
                </execution>
            </executions>
            <configuration>
                <mainClass>repo.maven.exec.App</mainClass>
                <!-- Przy poleceniu exec:exec -->
                <!-- <executable>maven</executable>-->
                <!-- <workingDirectory>/tmp</workingDirectory>-->
                <arguments>
                    <argument>-X</argument>
                    <argument>myproject:dist</argument>
                </arguments>
                <environmentVariables>
                    <LANG>en_US</LANG>
                </environmentVariables>
            </configuration>
        </plugin>
    </plugins>
</build>
```

Przez wiersz poleceń:

```shell
mvn compile exec:java -Dexec.mainClass="com.baeldung.main.Exec" -Dexec.arguments="Hello World,Bye"
```
#### Assembly

[//]: "assembly"

Wtyczka pakuje aplikacje w jedno wykonywalne archiwum. Dokumentacja wtyczki http://maven.apache.org/plugins/maven-assembly-plugin. W ramach wtyczki mamy dwie konfigurację, główną w pliku `pom.xml` oraz tgz. deskryptor który opisuje sposób pakowania wynikowego pliku.

```xml
<!-- pom -->
<project>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <!-- Ustawiamy, że polecenie single zostanie wykonane w ramach fazy pakowania -->
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
                <!-- Konfiguracja -->
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>com.lvl.Bootstrap</mainClass>
                        </manifest>
                        <manifestEntries>
                            <Class-Path>/</Class-Path>
                        </manifestEntries>
                    </archive>
                    <descriptors>
                        <descriptor>src/assembly/jar.xml</descriptor>
                    </descriptors>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

W ramach powyżej konfiguracji wskazujemy plik deskryptora `src/assembly/jar.xml`.

```xml
<!-- src/assembly/jar.xml -->
<assembly xmlns="http://maven.apache.org/ASSEMBLY/2.1.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/ASSEMBLY/2.1.0 http://maven.apache.org/xsd/assembly-2.1.0.xsd">
    <id>exec</id>
    <formats>
        <format>jar</format>
    </formats>
    <includeBaseDirectory>false</includeBaseDirectory>
    <!-- Sekcja z zależnościami -->
    <dependencySets>
        <dependencySet>
            <!-- Pobierane są wszystkie zaleności, które są następnie rozpakowywane -->
            <outputDirectory>/</outputDirectory>
            <!-- Rozpakowywany jest również główny pakiet -->
            <useProjectArtifact>true</useProjectArtifact>
            <unpack>true</unpack>
            <scope>runtime</scope>
        </dependencySet>
    </dependencySets>
</assembly>
```

Opis pliku deskryptora https://maven.apache.org/plugins/maven-assembly-plugin/assembly.html

##### Wykonywalny JAR

[//]: "executable-jar"

```xml
<build>
    <finalName>my-project-name</finalName>
    <plugins>

        <!-- other Maven plugins ... -->

        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-assembly-plugin</artifactId>
            <version>3.1.1</version>

            <configuration>
                <descriptorRefs>
                    <descriptorRef>jar-with-dependencies</descriptorRef>
                </descriptorRefs>
            </configuration>

            <executions>
                <execution>
                    <id>make-assembly</id>
                    <phase>package</phase>
                    <goals>
                        <goal>single</goal>
                    </goals>
                </execution>
            </executions>

        </plugin>
    </plugins>
</build>
```

#### Versions

Wtyka pozwala na wykonywanie różnych operacji związanych z wersjami. Pozwala między innymi na wyszukiwanie wersji, ustawienie wersji itp.

https://www.mojohaus.org/versions-maven-plugin/index.html

#### Release

[//]: "release"

This plugin is used to release a project with Maven, saving a lot of repetitive, manual work. Releasing a project is made in two steps: prepare and perform.

https://maven.apache.org/maven-release/maven-release-plugin

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-release-plugin</artifactId>
            <configuration>
                <goals>install</goals>
                <autoVersionSubmodules>true</autoVersionSubmodules>
            </configuration>
        </plugin>
    </plugins>
</build>
<scm>
    <developerConnection>scm:git:git@github.com:ttmdear/pet-clinic.git</developerConnection>
    <tag>HEAD</tag>
</scm>
```
#### Surefire

[//]: "surefire"

The Surefire Plugin is used during the `test` phase of the build lifecycle to execute the unit tests of an application.

https://maven.apache.org/surefire/maven-surefire-plugin

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>${maven.surefire.version}</version>
</plugin>
```
#### WAR

[//]: "war"

The WAR Plugin is responsible for collecting all artifact dependencies, classes and resources of the web application and packaging them into a web application archive.

https://maven.apache.org/plugins/maven-war-plugin

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-war-plugin</artifactId>
    <version>${maven-war-plugin.version}</version>
    <configuration>
        <archive>
            <addMavenDescriptor>false</addMavenDescriptor>
        </archive>
        <webXml>${webXmlPath}</webXml>
        <packagingExcludes>${webProdXmlFile},${webTestXmlFile}</packagingExcludes>
    </configuration>
</plugin>

<!-- webXmlPath -->
<webXmlPath>src/main/webapp/${webXmlFile}</webXmlPath>
```
#### Dependency

[//]: "dependency"

...

#### Compiler

[//]: "compiler"

Jest to podstawowa wtyczka do kompilowania.

https://maven.apache.org/plugins/maven-compiler-plugin

```xml
<plugin>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>${compiler-plugin.version}</version>
    <configuration>
        <source>${jdk.version}</source>
        <target>${jdk.version}</target>
    </configuration>
</plugin>

```

Polecenia

```shell
## Kompilowanie
mvn compile

## Kompilowanie testów
mvn test-compile
```

Konfiguracja:

```xml
<project>
  ...
  <build>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.1</version>
          <configuration>
              <verbose>true</verbose>
              <fork>true</fork>
              <executable><!-- path-to-javac --></executable>

              <!--
				Wtedy JAVA_1_4_HOME umieszczamy w settings.xml
			  -->
              <executable>${JAVA_1_4_HOME}/bin/javac</executable>
              <compilerVersion>1.3</compilerVersion>
              <source>11</source>
              <target>11</target>
              <fork>true</fork>
              <meminitial>128m</meminitial>
              <maxmem>512m</maxmem>
              <compilerArgs>
                  <arg>-verbose</arg>
                  <arg>-Xlint:all,-options,-path</arg>
              </compilerArgs>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
  ...
</project>
```
#### Animal Sniffer

[//]: "animal-sniffer"

The Animal Sniffer Plugin is used to build signatures of APIs and to check your classes against previously generated signatures. This plugin is called animal sniffer because the principal signatures that are used are those of the Java Runtime, and since Sun traditionally names the different versions of its Java Runtimes after different animals, the plugin that detects what Java Runtime your code requires was called "Animal Sniffer".

```xml
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>animal-sniffer-maven-plugin</artifactId>
    <version>${animal.sniffer.version}</version>
    <configuration>
        <signature>
            <groupId>org.codehaus.mojo.signature</groupId>
            <artifactId>${animal.sniffer.java.version}</artifactId>
            <version>1.0</version>
        </signature>
    </configuration>
    <executions>
        <execution>
            <phase>test</phase>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```
#### GMavenPlus

[//]: "g-magen-plus"

https://github.com/groovy/GMavenPlus 

Jest to wtyczka pozwalająca na kompilacje kodu w Groovim.

```xml
<dependency>
    <groupId>org.codehaus.groovy</groupId>
    <artifactId>groovy-all</artifactId>
    <version>2.4.7</version>
    <scope>test</scope>
</dependency>
```

Oraz musimy dodać wtyczkę która się uruchomi w trakcie kompilacji.

```xml
<plugin>
    <groupId>org.codehaus.gmavenplus</groupId>
    <artifactId>gmavenplus-plugin</artifactId>
    <version>1.5</version>
    <executions>
        <execution>
            <goals>
                <goal>compile</goal>
                <goal>testCompile</goal>
            </goals>
        </execution>
     </executions>
</plugin>
```

#### OWASP

[//]: "owasp"

Checking vulnerabilities in dependencies.

```xml
<plugin>
    <!-- Sprawdzanie podatności w zależnościach. Aby uruchomić należy użyć poleceń dependency-check:check (sprawdzanie 
     samego projektu) albo dependency-check:aggregate (sprawdzanie projektu i wszystkich dzieci). Raport jest domyślnie 
     generowany w pliku target/dependency-check-report.html. Więcej informacji na stronie: https://jeremylong.github.io/DependencyCheck/dependency-check-maven/aggregate-mojo.html -->
    <groupId>org.owasp</groupId>
    <artifactId>dependency-check-maven</artifactId>
    <version>${dependency-check.version}</version>
    <configuration>
        <failBuildOnAnyVulnerability>true</failBuildOnAnyVulnerability>
    </configuration>
</plugin>
```
#### Checkstyle

[//]: "checkstyle"

The plugin generates a report with the analysis of the code writing style.

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-checkstyle-plugin</artifactId>
    <version>${maven-checkstyle-plugin.version}</version>
    <configuration>
        <violationSeverity>error</violationSeverity>
        <failOnViolation>true</failOnViolation>
        <configLocation>checkstyle-config.xml</configLocation>
        <consoleOutput>true</consoleOutput>
        <encoding>UTF-8</encoding>
    </configuration>
</plugin>
```
#### Tomcat

[//]: "tomcat"

It is a plug-in that integrates with the Tomcat server. Sample configuration:

```xml
<plugin>
    <groupId>org.apache.tomcat.maven</groupId>
    <artifactId>tomcat7-maven-plugin</artifactId>
    <version>2.2</version>
    <configuration>
        <port>9000</port>   //Configure port number
        <path>/spring5-webmvc-demo</path>   //Configure application root URL
    </configuration>
</plugin>
```

Possible options:

```
address – This IP address will be used on all ports
contextFile – The path of the Tomcat context XML file.
hostName – configure host name
httpsPort – The https port to run the Tomcat server on.
keystoreFile – Override the default keystoreFile for the HTTPS connector (if enabled)
keystorePass – Override the default keystorePass for the HTTPS connector (if enabled)
mainClass – Main class to use for starting the standalone jar.
systemProperties – List of System properties to pass to the Tomcat Server.
port – Custom port number
path – The webapp context path to use for the web application
warFile – The path of the WAR file to deploy.
```
#### AntRun

[//]: "ant-run"

Wtyczka umożliwia uruchomienie zadań Ant.
### Pozostałe

#### Ustawienie wersji

Za pomocą wtyczki do wersji możliwa jest aktualizacja wersji jednym poleceniem.

https://www.mojohaus.org/versions-maven-plugin/index.html

[//]:"version-set"

```shell
mvn versions:set -DnewVersion=1.0.1-SNAPSHOT
```

#### Konfiguracja BOM

[//]: "bom"

Jest to skrót od Bill Of Materials dosłownie oznacza to zestawienie materiałów. W kontekście Mavena jest to lista zależności. 

Często jest tak, że pewna zależności może występować w kilku pakietach np.

```
A -> B -> C -> D 1.4  and  A -> E -> D 1.0
```

Zależności C oraz E wymaga zależności E w różnych wersjach. W przypadku Mavena zostanie wybrana zależność D 1.0 ponieważ jest to krótsza ścieżka zależności. Taki jest algorytm negocjacji wersji w Mavenie.

To zachowanie można zmodyfikować przez zdefiniowanie zależności w ramach sekcji`dependencyManagement`. W ten sposób możemy kontrolować jakie wersje zależności powinny zostać użytę.

```xml
<project ...>
    <modelVersion>4.0.0</modelVersion>
    <groupId>baeldung</groupId>
    <artifactId>Baeldung-BOM</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>BaelDung-BOM</name>
    <description>parent pom</description>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>test</groupId>
                <artifactId>a</artifactId>
                <version>1.2</version>
            </dependency>
			<!-- ... -->
        </dependencies>
    </dependencyManagement>
</project>
```

Te ustawienia do innego projektu możemy zaimportować przez dziedzinie po tym projekcie. 

```xml
<project ...>
    <modelVersion>4.0.0</modelVersion>
    <groupId>baeldung</groupId>
    <artifactId>Test</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>Test</name>
    <parent>
        <groupId>baeldung</groupId>
        <artifactId>Baeldung-BOM</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
</project>
```

To podejście ogranicza nas tylko do jednej definicji. Możemy dziedziczyć tylko po jednym pomie.

Możemy również zaimportować BOM do projektu, który np. rozszerza projekt Sprionga.

```xml
<project ...>
    <modelVersion>4.0.0</modelVersion>
    <groupId>baeldung</groupId>
    <artifactId>Test</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>Test</name>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>baeldung</groupId>
                <artifactId>Baeldung-BOM</artifactId>
                <version>0.0.1-SNAPSHOT</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

Zwróć uwagę, że np. nasz projekt może rozszerzać inny projekt ale możemy również zaimportować listę zależności np. dla Springa.

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-framework-bom</artifactId>
            <version>4.3.8.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```
#### Ustawienie wersji Javy

[//]: "java-version"

Parametr `source` ustawia z jaką wersją Javy ma zostać skompilowany kod. Parametr target definiuje munimalną wersję Javy. Jeśli np. ustawimy target na 1.7 to kod się uruchomi na wersji 1.6.

Ogólnie są to parametry przekazywane w do polecenia `javac`.

```shell
javac -source 1.6 -target 1.6 -bootclasspath C:\jdk1.6.0\lib\rt.jar -extdirs "" OldCode.java
```

W Mavenie jest wtycznka `maven-compiler-plugin` odpowiedzialna za kompilacje. Do wersji Java 8 te parametry mogły być ustawiane we globalnych właściwościach.

```xml
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
</properties>
```

Od wersji Java 9 ten parametry są ustawiane na poziomie wtyczki.

```xml
<.../>
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.8.0</version>
            <configuration>
                <release>11</release>
                <target>11</target>
                <source>11</source>
            </configuration>
        </plugin>
    </plugins>
</build>
<.../>
```
#### Profil z wtyczką

[//]: "profile"

Jest to fajne połączenie, gdzie w ramach profilu zostaje uruchomiona wtyczka. Poniżej przykład w którym dla profilu `prod` uruchamiana jest wtyczka `maven-antrun-plugin` która przenosi pliku poza wara.

```xml
</...>
<profile>
    <id>prod</id>
    <properties>
        <freemarker.templates-dir>/usr/mo-noticegen/templates</freemarker.templates-dir>
        <log.level>INFO</log.level>
    </properties>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-antrun-plugin</artifactId>
                <version>1.7</version>
                <executions>
                    <execution>
                        <phase>prepare-package</phase>
                        <goals>
                            <goal>run</goal>
                        </goals>
                        <configuration>
                            <tasks>
                                <move file="${project.build.outputDirectory}/application.yaml"
                                      toFile="${project.build.directory}/application.yaml"/>
                                <move file="${project.build.outputDirectory}/templates"
                                      toFile="${project.build.directory}/templates"/>
                            </tasks>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</profile>
</...>
```
#### Pakowanie modułu z profilem

[//]: "package-module"

Polecenie pakuje jeden moduł oraz moduły zależne.

```shell
mvn install --threads 4.0C --projects pentaid-backend -P clip-pentaid-wb-modules,dev-pbobryk-jboss,jboss -DskipTests -Dmaven.test.skip=true -am --offline
```
#### Opcje `--also-make`, `--also-make-dependents`

[//]: "compile-dependents"

Opcja `--also-make` powoduje, że Maven kompiluje dodatkowo zależności. Jest przydatna w połączeniu z opcją `--projects` która pozwala na zdefiniowane modułów które mają być skomplikowane.

Opcja ``--also-make-dependents` powoduje, że zostaną przekompilowane wszystkie moduły zależne od modułu kompilowanego. 
#### Instalacja biblioteki do repozytorium

[//]: "install-package"

Maven umożliwia zainstalowanie biblioteki zewnętrznej do repozytorium. Miałem taką sytuację, że brakowało mi sterownika do bazy oracle.ojdbc6. Pomimo, że był dostępny w repozytorium Mavena to Maven nie mógł go pobrać lokalnie. Wiec musiałem go pobrać i ręcznie dorzucić .

```shell
mvn install:install-file -Dfile="c:\Projekty\lib\ojdbc6.jar" -DgroupId="com.oracle" -DartifactId="ojdbc6" -Dversion="11.2.0.3" -Dpackaging="jar" -DgeneratePom=true
```
#### Definiowanie własnych repozytoriów

[//]: "set-repositories"

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<!-- ... -->

	<repositories>
		<repository>
			<id>local-repository</id>
			<name>Local repository</name>
			<url>file</url>
		</repository>
	</repositories>
</project>
```
#### Uruchomienie w ramach innego katalogu

[//]: "run-with-other-pwd"

```shell
mvn -f tutorials/pom.xml clean compile
```

# Narzędzia

| Nazwa | Opis                                                         |
| ----- | ------------------------------------------------------------ |
| jdb   | Debugger <br />https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jdb.html#CHDFHFDB |
| javac | Kompilator                                                   |
| java  | Maszyna wirtualna                                            |
| jar   | Narzędzie do pracy z plikami .jar.                           |
| jdeps | Narzędzie do analizy zależności między modułami. Przydaje się gdy chcemy np. stworzyć obraz uruchamialny. |
| javap | Rozkompiluje pliki class<br />https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javap.html |
| javah | Generuje nagłów dla C<br />https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javah.html#BJECIACA nagłówek można wykorzystać przy pisaniu rozszerzeń napusanych w JNI. |

## JMeter
![image-20210902133333932](../.files/image-20210902133333932.png)

Narzędzie do generowania testów stresowych.

### Parametry z pliku CSV i bazy danych
https://www.blazemeter.com/blog/jmeter-parameterization-the-complete-guide

## VisualVM
 ![Znalezione obrazy dla zapytania visualvm](../.files/visualvm_logo_big.png) 

Jest to narzędzie pozwaljące na obserwowanie zużycia zasów przez JVM dla określonego procesu. Poniżej obserwujemy program wykonany poleceniem:

```shell
java -cp target/classes -Xms30m -Xmx100m com.memmorytest.App
```
Zwróć uwagę, że bardzo dobrze widać jak działa GC.

<img src="../.files/image-20200116163659357.png" alt="image-20200116163659357" style="zoom:50%;" />

Narzędzie pozwala również na **profilowanie pamięci i użycia procesora**.

## JD Java Decompiler
Jest to narzędzie do dekompilowania bytecodu Javy.

## MemoryAnalyzer
![img](../.files/mat_thumb.png)

Narzędzie GUI do analizowania zrzutów pamięci.

### Shallow Heap i Retained Heap
Shallow Heap - jest to pamięć która jest pobierana b

## hprof
Podstawowe narzędzie do profilowania kodu Javy. Jest ono dostarczane razem z JDK jako cześć środowiska Javy. **Warto wspomnieć o tym, że narzędzie zostało usunięty od Javy 9**

Opcje polecenia

```shell
java -agentlib:hprof=help

     HPROF: Heap and CPU Profiling Agent (JVMTI Demonstration Code)

hprof usage: java -agentlib:hprof=[help]|[<option>=<value>, ...]

Option Name and Value  Description                    Default
---------------------  -----------                    -------
heap=dump|sites|all    heap profiling                 all
cpu=samples|times|old  CPU usage                      off
monitor=y|n            monitor contention             n
format=a|b             text(txt) or binary output     a
file=<file>            write data to file             java.hprof[{.txt}]
net=<host>:<port>      send data over a socket        off
depth=<size>           stack trace depth              4
interval=<ms>          sample interval in ms          10
cutoff=<value>         output cutoff point            0.0001
lineno=y|n             line number in traces?         y
thread=y|n             thread in traces?              n
```

Mamy możliwość obserwowania danych o użyciu procesora lub zrzut pamięci HeadDump.

```
java -agentlib:hprof=heap=sites <classname>
java -agentlib:hprof=cpu=samples <classname>
java -agentlib:hprof=cpu=times <classname>
```

Próbkowanie czasu wygląda następująco.

```shell
java -agentlib:hprof=cpu=samples <CLASS_NAME>

# Do polecenia możemy przekazać więcej opcji
# java -agentlib:hprof=cpu=samples,depth=100,interval=20,lineno=y,thread=y,file=out.hprof myclass
```

Generowany jest plik `java.hprof.txt` z treścią z którego można odczytać użyty czas procesora.

```
CPU SAMPLES BEGIN (total = 21079) Mon May 20 12:31:57 2013
rank   self  accum   count trace method
   1 27.80% 27.80%    5859 300304 java.lang.StrictMath.acos
   2 24.52% 52.32%    5169 300275 java.net.SocketInputStream.socketRead0
   3  6.49% 58.81%    1369 300349 java.lang.String.length
   4  5.19% 64.01%    1095 300407 java.util.regex.Pattern$Branch.match
   5  3.57% 67.58%     753 300315 java.util.Vector.indexOf
   6  3.51% 71.08%     739 300311 java.util.Vector.contains
   7  3.04% 74.13%     641 300308 DBscanDistanceMatrix.getNeighboursWithinRange
   8  2.25% 76.38%     475 300443 java.util.regex.Matcher.getTextLength
   9  1.75% 78.13%     368 300446 java.util.regex.Pattern$Curly.match
  10  1.43% 79.56%     302 300416 java.util.regex.Pattern$Start.matcho
```

## jconsole
Narzędzie GUI do obserwowania działania JVMa pod kątem różnych mętryk procesora, pamięci.

## javap
Jest to narzędzie wiersza poleceń do odkodowania bytecodu Javy do formy asemblera Javy. Narzędzie posiada wiele opcji. 

```shell
javap -c GetterAndWrite.class
```

W wyniku dostaniemy

```
Compiled from "GetterAndWrite.java"
public class repo.performance.tests.bytecode.GetterAndWrite {
  public static void main(java.lang.String[]) throws java.io.IOException;
    Code:
       0: new           #1                  // class repo/performance/tests/bytecode/GetterAndWrite
       3: dup
       4: invokespecial #2                  // Method "<init>":()V
       7: astore_1
       8: aload_1
       9: invokevirtual #3                  // Method getter:()I
      12: pop
      13: aload_1
      14: invokevirtual #4                  // Method getterWithSize:()I
      17: pop
      18: aload_1
      19: invokevirtual #5                  // Method print:()V
      22: return
...
```

W odpowiedzi dostaniemy odkodowany bytecode każdej metody w klasie. Pozwala to analizę poszczególnych metod. Numer linii 0,3,4... to adres bajtu pamięci w którym ulokowane jest polecenie.

### Wyświetlenie wszystkich metod
```shell
$ javap -p GetterAndWrite.class
Compiled from "GetterAndWrite.java"
public class repo.performance.tests.bytecode.GetterAndWrite {
  private int value;
  public static void main(java.lang.String[]) throws java.io.IOException;
  public repo.performance.tests.bytecode.GetterAndWrite();
  private void print();
  public int getter();
  public int getterWithSize();
}
```

### Informacje i skrót klasy
```shell
$ javap -sysinfo GetterAndWrite.class
Classfile /C:/home/repository/java/performance-tests/src/main/java/repo/performance/tests/bytecode/GetterAndWrite.class
  Last modified Sep 14, 2021; size 1254 bytes
  MD5 checksum 1eeda3dcbf37d056164de392a50782a0
  Compiled from "GetterAndWrite.java"
public class repo.performance.tests.bytecode.GetterAndWrite {
  public static void main(java.lang.String[]) throws java.io.IOException;
  public repo.performance.tests.bytecode.GetterAndWrite();
  public int getter();
  public int getterWithSize();
}
```

## jcmd
Jest to narzędzie wiersza poleceń za pomocą które możemy różne informacje z JVM począwszy od tych związanych z wydajnością skończywszy na parametrach wywołania.

Najprostszym wywołaniem jest wywołanie samego polecenia bez parametrów. Wtedy dostajemy listę aktualnie działających procesów JVM razem z ich identyfikatorami (pid).

```shell
jcmd

# 21040 repo.java.memory.dump.App
# 13636 org.jetbrains.idea.maven.server.RemoteMavenServer36
# 18732 jdk.jcmd/sun.tools.jcmd.JCmd
# 5964 org.jetbrains.jps.cmdline.Launcher C:/Program Files/JetB [...]
```

Następnie możemy wykonać polecenie

```shell
jcmd <PID> help
```

Dostaniemy listę poleceń jakie możemy wykonać. Lista jest bardzo długa i zawiera kilka sekcji `VM.*, GC.*, ...`.

```shell
Compiler.CodeHeap_Analytics
Compiler.codecache
Compiler.codelist
Compiler.directives_add
Compiler.directives_clear
Compiler.directives_print
Compiler.directives_remove
Compiler.queue
GC.class_histogram
GC.class_stats
GC.finalizer_info
GC.heap_dump
GC.heap_info
GC.run
GC.run_finalization
JFR.check
JFR.configure
JFR.dump
JFR.start
JFR.stop
JVMTI.agent_load
JVMTI.data_dump
ManagementAgent.start
ManagementAgent.start_local
ManagementAgent.status
ManagementAgent.stop
Thread.print
VM.class_hierarchy
VM.classloader_stats
VM.classloaders
VM.command_line
VM.dynlibs
VM.flags
VM.info
VM.log
VM.metaspace
VM.native_memory
VM.print_touched_methods
VM.set_flag
VM.stringtable
VM.symboltable
VM.system_properties
VM.systemdictionary
VM.uptime
VM.version
```

### Przypadki użycia
#### Pobranie wersji Javy
```shell
$ jcmd 21040 VM.version;
21040:
OpenJDK 64-Bit Server VM version 11.0.11+9
JDK 11.0.11
```

#### Pobranie czasu działania aplikacji
```shell
$ jcmd 21040 VM.uptime;
21040:
1259.621 s
```

#### Wyświetlenie informacji o wątkach
Pozwala na wyświetlenie informacji o działaniu wątków. 

```shell
jcmd 21040 Thread.print;

"main" #1 prio=5 os_prio=0 cpu=703.13ms elapsed=2092.93s tid=0x0000027a56279000 nid=0x2460 waiting on condition  [0x000000e3c04ff000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
        at java.lang.Thread.sleep(java.base@11.0.11/Native Method)
        at repo.java.memory.dump.App.main(App.java:16)
```

Ogólnie sporo informacji, ale np. dla mojego jednego wątku była informacja o tym, że aktualnie jest w stanie oczekiwania `TIMED_WAITING`. Dzięki temu możemy sprawdzić co się dzieje z wątkami.

#### Zrzucenie pliku sterty
```shell
$ jcmd 21040 GC.heap_dump dump.txt
21040:
Heap dump file created
```

#### Informacje na temat pamięci
```shell
$ jcmd 21040 GC.heap_info;
21040:
 garbage-first heap   total 9216K, used 4584K [0x00000000ff400000, 0x0000000100000000)
  region size 1024K, 1 young (1024K), 0 survivors (0K)
 Metaspace       used 13296K, capacity 13581K, committed 14208K, reserved 1062912K
  class space    used 1331K, capacity 1428K, committed 1664K, reserved 1048576K
```

#### Uruchomienie CG
```shell
$ jcmd 21040 GC.run;
21040:
Command executed successfully
```

#### Pobranie histogramu klas
Bardzo przydatna informacja aby szybko sprawdzić ile miejsca zajmują poszczególne elementy.

```shell
$ jcmd 21040 GC.class_histogram

 num     #instances         #bytes  class name (module)
-------------------------------------------------------
   1:         31655        1733024  [B (java.base@11.0.11)
   2:         31147         747528  java.lang.String (java.base@11.0.11)
   3:         20780         332480  repo.java.memory.dump.Node
   4:          2153         259576  java.lang.Class (java.base@11.0.11)
[...]
```

Od razu widzę ile jest instancji mojego obiektu ` repo.java.memory.dump.Node` i ile miejsca zajmują. Podobne informacje są umieszczone w HeapDumpie pamięci.

#### Pobranie statystyk klas
```shell
$ jcmd 21040 GC.class_stats
```

Zwraca sporo informacji na temat klas, ile miejsca zajmują, ile maja metod, ile adnotacji. Pomocne informacje np. przy sprawdzaniu jakości kodu.

#### Informacje o sposobie uruchomienia
```shell
$ jcmd 21040 VM.command_line;
21040:
VM Arguments:
jvm_args: -Xms8m -Xmx12m -XX:+HeapDumpOnOutOfMemoryError [...]
java_command: repo.java.memory.dump.App
java_class_path (initial): C:\home\repository\java\java-memory-dump\target\classes
Launcher Type: SUN_STANDARD
```

Możemy też wykonać polecenie `VM.flags` do wyświetlenia samych flag VM.

```shell
$ jcmd 21040 VM.flags;
21040:
-XX:CICompilerCount=4 -XX:ConcGCThreads=2 -XX:G1ConcRefinementThreads=8 -XX:G1HeapRegionSize=1048576 -XX:GCDrainStackTargetSize=64 -XX:+HeapDumpOnOutOfMemoryError -XX:InitialHeapSize=8388608 -XX:MarkStackSize=4194304
```

#### Informacje o wirtualnej maszynie
Zawiera zbiorcze zestawienie różnych informacji o działającej maszynie wirtualnej.

```shell
jcmd 21040 VM.info;
```

#### Hierarchia klas
Ciekawe polecenie pozwala na wyświetlenie wszystkich klas razem z informacją o ich hierarchi.

```shell
$ jcmd 21040 VM.class_hierarchy

|--sun.management.spi.PlatformMBeanProvider/null
|  |--java.lang.management.DefaultPlatformMBeanProvider/null
|  |--com.sun.management.internal.PlatformMBeanProviderImpl/null
|  |--jdk.management.jfr.internal.FlightRecorderMXBeanProvider/null
|--sun.management.Util/null
```

#### Lista klas wczytywaczy
Tutaj mamy dwa poleceni. 

```shell
$ jcmd 21040 VM.classloaders;
21040:
+-- <bootstrap>
      |
      +-- jdk.internal.reflect.DelegatingClassLoader (+ 64 more)
      |
      +-- "platform", jdk.internal.loader.ClassLoaders$PlatformClassLoader
            |
            +-- "app", jdk.internal.loader.ClassLoaders$AppClassLoader
                  |
                  +-- sun.reflect.misc.MethodUtil
                        |
                        +-- jdk.internal.reflect.DelegatingClassLoader
                        

```

Oraz pobranie informacji.

```shell
jcmd 21040 VM.classloader_stats;
```

#### Wyświetlenie wczytanych właściwości
```shell
jcmd 21040 VM.system_properties;
```

#### Obsługa logów
Nie sprawdziłem tego, ale polecenie najprawdopodobniej pozwala na zrzucenie logów do pliku

```shell
jcmd 21040 VM.log
```

## java
```shell
## Uruchomienie com.memmorytest.App
java -cp classes com.memmorytest.App

## Uruchomienie z przełącznikami pamięci
java -cp target/classes -Xms30m -Xmx100m com.memmorytest.App

java -Xmx120m -Xms30m -Xmn10m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar Java2Demo.jar
```
## javac
It is compiler for Java.

```shell
## Prosty przypadek kompilacji
javac -d target/classes src/main/java/com/memmorytest/App.java
```
## javap
The **javap** tool is used to get the information of any class or interface. The javap command (also known as the **Java Disassembler**) disassembles one or more class files. Its output depends on the **options** used (“**-c**” or “**-verbose**” for byte code and byte code along with innards info, respectively). If no options are used, javap prints out the package, protected, and public fields and methods of the classes passed to it.

```shell
javap [option] [classname]
```
## jstat
Jest to narzędzie za pomocą którego można obserwować statystyki związane z uruchomonym programem.

Narzędzie umożliwia kilka opcji które chcemy obserwować.

```shell
-class
-compiler
-gc
-gccapacity
-gccause
-gcmetacapacity
-gcnew
-gcnewcapacity
-gcold
-gcoldcapacity
-gcutil
-printcompilation
```

Poniżej przykłądowe polecenie:

```
 jstat -gc 13744 1000
```

W wyniku otrzymam wiele kolumn. 

- **S0C and S1C**: This column shows the current size of the Survivor0 and Survivor1 areas in KB.
- **S0U and S1U**: This column shows the current usage of the Survivor0 and Survivor1 areas in KB. Notice that one of the survivor areas are empty all the time.
- **EC and EU**: These columns show the current size and usage of Eden space in KB. Note that EU size is increasing and as soon as it crosses the EC, Minor GC is called and EU size is decreased.
- **OC and OU**: These columns show the current size and current usage of Old generation in KB.
- **PC and PU**: These columns show the current size and current usage of Perm Gen in KB.
- **YGC and YGCT**: YGC column displays the number of GC event occurred in young generation. YGCT column displays the accumulated time for GC operations for Young generation. Notice that both of them are increased in the same row where EU value is dropped because of minor GC.
- **FGC and FGCT**: FGC column displays the number of Full GC event occurred. FGCT column displays the accumulated time for Full GC operations. Notice that Full GC time is too high when compared to young generation GC timings.
- **GCT**: This column displays the total accumulated time for GC operations. Notice that it’s sum of YGCT and FGCT column values.

Do obserwowania możemy wykorzystać również narzędzie visualvm.
## jlink
jlink to narzędzie, które generuje niestandardowy obraz środowiska wykonawczego Java (JIMAGE), który zawiera tylko moduły platformy wymagane dla danej aplikacji.

Przed stworzeniem paczki musimy dowiedzieć od czego zależne są moduły. Do określania zależność służy polecenie `jdeps`.

```
jdeps --module-path "mods/;lib" -s --module httpio.app
```

Polecenie wyświetli list zależnych modułów.

```
httpio.app -> httpio.gui
httpio.app -> httpio.logic
httpio.app -> java.base
```

Tworzenie paczki.

```shell
jlink --module-path "mods/;lib" --add-modules httpio.app --output httpio.build
```

Powstanie katalog `httpio.build` w katalogu przystosowana `java` do uruchomienia z modułem.

Aby uruchomić aplikacje wywołujemy polecenie.

```shell
./java --module httpio.app/httpio.app.App
```

Można również utworzyć gotową paczkę wykonywalną.

```shell
jlink --launcher httpio=httpio.app/httpio.app.App --module-path "mods/;lib" --add-modules httpio.app --output httpio.1.0.0
```

W katalogi `httpio.1.0.0/bin` jest gotowy plik wykonywalny `httpio`.

Do ścieżki z modułami warto również dodać `JAVA_HOME`.

```shell
jlink --module-path $JAVA_HOME/jmods:mlib --add-modules com.greetings --output greetingsapp
```

W Windows separatorem katalogów jest `;` natomiast systemach pochodzenia unixowego `:`.

*The value to `--module-path` is a PATH of directories containing the packaged modules. Replace the path separator ':' with ';' on Microsoft Windows.*
## visualvm
 ![Znalezione obrazy dla zapytania visualvm](../.files/visualvm_logo_big.png) 

Jest to narzędzie pozwalające na obserwowanie zużycia zasobów przez JVM dla określonego procesu. Poniżej obserwujemy program wykonany poleceniem:

```shell
java -cp target/classes -Xms30m -Xmx100m com.memmorytest.App
```

Zwróć uwagę, że bardzo dobrze widać jak działa GC.

<img src="../.files/image-20200116163659357.png" alt="image-20200116163659357" style="zoom:50%;" />

# Biblioteki i narzędzia

[//]:"libraries-and-tools"

| Nazwa | Opis                                                         |
| ----- | ------------------------------------------------------------ |
| p6spy | Jest to sterownik do bazy danych pozwalający na logowanie wszystkich zapytań wykonywanych na bazie danych z poziomu aplikacji. |
| jsoup | Biblioteka przetwarzania HTML w sposób zbliżony do jQuery.<br />https://jsoup.org |
|       |                                                              |

## Guice
[//]:"guice"
![Introduction to Google Guice. Introduction | by Mohit Sharma | Medium](../.files/1bZhuDw5BTdUu3xjyiwiuJQ-16421642331362.png)

Jest to biblioteka dostarczająca mechanizm do wstrzykiwania zależności. Biblioteka jest rozwijana przez Googla.
### Konfiguracja
```xml
<dependency>
    <groupId>com.google.inject</groupId>
    <artifactId>guice</artifactId>
    <version>4.1.0</version>
</dependency>
```

Następnym krokiem jest zdefiniowanie mapowania typów na konkretne implementacja. Definiujmy to przez rozszerzenie klasy `AbstractModule` i nadpisanie metody `configure` gdzie definiujemy mapowanie typów na implementacje.

```java
public class BasicModule extends AbstractModule {
 
    @Override
    protected void configure() {
        // Mapowanie po typie.
        bind(Communicator.class).to(DefaultCommunicatorImpl.class);
        
        // Mapowanie po nazwie
        bind(Communicator.class)
          .annotatedWith(Names.named("DefaultCommunicator"))
          .to(DefaultCommunicatorImpl.class);
        
        // Mapowanie 
        bind(Boolean.class).toInstance(true);
        bind(Communication.class).toConstructor(
          Communication.class.getConstructor(Boolean.TYPE));
        
        bind(Communication.class)
          .toInstance(new Communication(true));
    }
}
```

Pobranie zależności

```java
Injector injector = Guice.createInjector(new Components());

C c = injector.getInstance(C.class);
```
### Wstrzykiwanie zależności
```java
// Prze pole
@Inject @Named("SMSComms")
CommunicationMode smsComms;

// Przez metodę
@Inject
public void setEmailCommunicator(@Named("EmailComms") CommunicationMode emailComms) {
    this.emailComms = emailComms;
}

// Przez kontruktor
@Inject
public Communication(@Named("IMComms") CommunicationMode imComms) {
    this.imComms= imComms;
}
```
### Zakresy
Domyślne za każdym razem trzony jest nowy obiekt. Odpowiednikiem w Springu jest zakres prototypu. Natomiast to zachowanie można zmienić.

```java
// Singleton
bind(Communicator.class).annotatedWith(Names.named("AnotherCommunicator"))
  .to(Communicator.class).in(Scopes.SINGLETON);

// Eager
bind(Communicator.class).annotatedWith(Names.named("AnotherCommunicator"))
  .to(Communicator.class)
  .asEagerSingleton();
```
### Aspekty
```java
public class MessageLogger implements MethodInterceptor {
    @Inject
    Logger logger;

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        Object[] objectArray = invocation.getArguments();
        for (Object object : objectArray) {
            logger.info("Sending message: " + object.toString());
        }
        return invocation.proceed();
    }
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MessageSentLoggable {
}

public class AOPModule extends AbstractModule {
    @Override
    protected void configure() {
        bindInterceptor(
            Matchers.any(),
            Matchers.annotatedWith(MessageSentLoggable.class),
            new MessageLogger()
        );
    }
}

@Override
@MessageSentLoggable
public boolean sendMessage(String message) {
    logger.info("SMS message sent");
    return true;
}

public static void main(String[] args) {
    Injector injector = Guice.createInjector(new BasicModule(), new AOPModule());
    Communication comms = injector.getInstance(Communication.class);
}
```
### Integracja z JavaFX
Istnieje możliwość podpięcia kontenera pod `FXMLLoader`. Dzięki temu, `FXMLLoader` tworzenie obiekty określonego typu (zdefiniowanego w fxml) będzie delefował do kontenera DI. Natomiast ten w odpowiedni sposób zainicjuje obiekt kontrolera razem z zależnościami.

```java
final Injector injector = Guice.createInjector(...);

FXMLLoader loader = new FXMLLoader(getClass().getResource(...));

loader.setControllerFactory(new Callback<Class<?>, Object>() {
    @Override
    public Object call(Class<?> type) {
        return injector.getInstance(type);
    }
});
```
## Apache Commons CLI
[//]:"apache-commons-cli"
Jest to biblioteka do obsługi parametrów wywołania polecenia.

https://commons.apache.org/proper/commons-cli
### Konfiguracja
```xml
<dependency>
    <groupId>commons-cli</groupId>
    <artifactId>commons-cli</artifactId>
    <version>1.4</version>
</dependency>
```

### Użycie

```java
// create Options object
Options options = new Options();

// add t option
options.addOption("t", false, "display current time");
options.addOption(new Option("d", "debug", false, "Turn on debug."));
options.addOption(new Option("e", "extract", false, "Turn on extract."));
options.addOption(new Option("o", "option", true, "Turn on option with argument."));
options.addOption("c", true, "country code");

CommandLineParser parser = new DefaultParser();
CommandLine cmd = parser.parse( options, args);

// get c option value
String countryCode = cmd.getOptionValue("c");

if(countryCode == null) {
    // print default date
}
else {
    // print date for country specified by countryCode
}
```
## JaCoCo
[//]:"jacoco"
Jest to narzędzie do analizy pokrycia kodu.

```xml
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.7.7.201606060606</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>prepare-package</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>

<!-- Inna konfiguracja z wykluczeniem okreslonych klas -->
<plugins>
    <plugin>
        <groupId>org.jacoco</groupId>
        <artifactId>jacoco-maven-plugin</artifactId>
        <configuration>
            <append>true</append>
            <excludes>
                <exclude>com/pentacomp/ezamowienia/mo/importer/ImporterApplication.class</exclude>
                <exclude>com/pentacomp/ezamowienia/mo/importer/domain/**</exclude>

                <!-- Data/Setters/Getters -->
                <exclude>**/TEDApi$NoticeSearchParams*.class</exclude>
                <exclude>**/BZPConfiguration*.class</exclude>
                <exclude>**/TEDConfiguration*.class</exclude>
            </excludes>
        </configuration>
        <executions>
            <execution>
                <goals>
                    <goal>prepare-agent</goal>
                </goals>
            </execution>
            <execution>
                <id>report</id>
                <phase>prepare-package</phase>
                <goals>
                    <goal>report</goal>
                </goals>
            </execution>
        </executions>
    </plugin>
</plugins>
```

Po wykonaniu `mvn clean package` wykonywane są testy oraz w trakcie tych testów uruchamiany jest mechanizm sprawdzający.

Raport z pokrycia jest umieszczony w pliku `target/site/jacoco/index.html`.
### Sposób działania
JaCoCo działa jako agent Java, jest odpowiedzialny za instrumentowanie kodu bajtowego podczas wykonywania testów. JaCoCo zagłębia się w każdą instrukcję i pokazuje, które linie są ćwiczone podczas każdego testu.

Aby zebrać dane pokrycia, JaCoCo używa ASM do instrumentacji kodu w locie, odbierając zdarzenia z interfejsu narzędzia JVM w procesie.

![jacoco concept](../.files/jacoco-concept.png)
### Minimalne pokrycie
JaCoCo pozwala na zdefiniowanie minimalnego pokrycia.

```xml
<execution>
    <id>jacoco-check</id>
    <goals>
        <goal>check</goal>
    </goals>
    <configuration>
        <rules>
            <rule>
                <element>PACKAGE</element>
                <limits>
                    <limit>
                        <counter>LINE</counter>
                        <value>COVEREDRATIO</value>
                        <minimum>0.50</minimum>
                    </limit>
                </limits>
            </rule>
        </rules>
    </configuration>
</execution>
```

Jeśli poziom pokrycia nie zostanie spełniony to budowanie się nie skończy.

```java
[ERROR] Failed to execute goal org.jacoco:jacoco-maven-plugin:0.7.7.201606060606:check
  (jacoco-check) on project mutation-testing: Coverage checks have not been met.
```
## Hamcrest
[//]:"hamcrest"
Jest to biblioteka dostarczająca zbiór różnego rodzaju mechanizmów do sprawdzania asercji.
## SLF4J
[//]:"sl4j"
**Simple Logging Facade for Java** - służy jako prosta fasada lub abstrakcja dla różnych środowisk rejestrowania (np. Java.util.logging, logback, log4j), umożliwiając użytkownikowi końcowemu podłączenie pożądanego środowiska rejestrowania w czasie wdrażania.

Aby użyć biblioteki ustawiamy zależność:

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.30</version>
</dependency>
```

I w zależności od implementacji mechanizmu:

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
    <version>1.7.13</version>
</dependency>

<!-- Standardowa implementacja -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-jdk14</artifactId>
    <version>1.7.13</version>
</dependency>
```
## Lombok
[//]:"lombok"
 ![Podobny obraz](../.files/lombok-1579165185866.png)

https://projectlombok.org

Biblioteka dostarcza różnego rodzaju mechanizmu za pomocą których możemy automatycznie zaimplementować różnego rodzaju funkcje. Projekt Lombok ma na celu zredukowanie boiler-plate code za pomocą adnotacji, które wykonują transformacje klas w czasie kompilacji.

Lombok np. za pomocą adnotacji pozwala na zdefiniowanie metod typu `get/set` dla wszystkich pół w klasie.

```java
@Getter
@Setter
@ToString
public class User {
    private String id;
    private String name;
    private String firstName;
    private String lastName;

    public void setId(String id) {
        this.id = id + "n";
    }
}
```

### Zasada działania
Projekt Lombok działa jako procesor adnotacji. Mechanizm przetwarzający adnotacje deleguje do Lomboka te adnotacje które obsługuje. Do Lomboka przekazywana jest reprezentacja AST (Abstract Syntax Tree). Lombok może modyfikować/tworzyć i usuwać wszystkie elementy tego drzewa. Na postawie tego drzewa jest w następnych krokach generowany Byte Code.

![img](../.files/Compile Process-1577310430594.gif)
#### Dostępne rozszerzenia

**Te dość popularne**

| Adnotacja                                                    | Działanie                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| @Getter/Setter                                               | Adnotacje powodują, że Lombok generuje metody typu `get/set` dla pól. Jest to bardzo praktyczne i pozwala zmniejszyć ilość powtarzającego się kodu. |
| @NoArgsConstructor, @RequiredArgsConstructor, @EqualsAndHashCode, @AllArgsConstructor | Generuje różne warianty konstruktora.                        |
| @Data                                                        |                                                              |
| @ToString                                                    | Generuje metodę `toString`.                                  |
| @Builder                                                     | Powoduje, że jest generowany mechanizm budujący klasę.       |
| @Log                                                         | Powoduje, że inicjowane jest pole `log` z przypisanym loggerem. |
| @Value                                                       | Powoduje, że zostanie wygenerowana klasa reprezentująca wartość. Obiekty typu `Value` są niezmienne tzn. po zainicjowaniu nie powinny dostarczać metod za pomocą których można zmienić ich stan. |

**Pozostałe**

| Adnotacja          | Działanie                                                    |
| ------------------ | ------------------------------------------------------------ |
| val/var            | Pozwala na zdefiniowanie typu który będzie automatycznie wykrywany w trakcie kompilacji. `val` zmienna typu `final`, `var` zmienna którą możemy zmienić. Zastosowany typ jest automatycznie wykrywany na podstawie kontekstu. |
| @NonNull           | Adnotacja powoduje, ze zostanie dodane sprawdzenie czy zmienne nie jest `NULL` , jeśli tak to wyrzucany jest wyjątek. |
| @Cleanup           | Adnotacja dodaje czyszczenie zasobów. Przydatne np. przy operacjach na strumieniach. |
| @Getter(lazy=true) | Działa podobnie jak `@Getter` tylko dodatkowo implementuje `cache`. |
| @EqualsAndHashCode | Adnotacja spowoduje, że zostaną wygenerowane dwie metody `equal, hashCode`. |
| @SneakyThrows      | Adnotacja powoduje, że zostanie dodana obsługa wyjątków.     |
| @Synchronized      | Adnotacja powoduje, że jest implementowany bezpieczniejszy wariant blokady wątku. |
| @With              | Pozwala na wygenerowanie metody `with...` która utworzy nowy obiekt zmieniając tylko określony atrybut. Metoda `with...` jest przydatna gdy chcemy np. utworzyć nowy obiekt `Value` na postawie poprzedniego zmieniając określona wartość. |

#### Adnotacja @Synchronized

Adnotacja powoduje, że jest implementowany bezpieczniejszy wariant blokady wątku.

```java
import lombok.Synchronized;

public class SynchronizedExample {
  private final Object readLock = new Object();

  @Synchronized
  public static void hello() {
    System.out.println("world");
  }

  @Synchronized
  public int answerToLife() {
    return 42;
  }

  @Synchronized("readLock")
  public void foo() {
    System.out.println("bar");
  }
}
```

Spowoduje, że:

```java
public class SynchronizedExample {
  private static final Object $LOCK = new Object[0];
  private final Object $lock = new Object[0];
  private final Object readLock = new Object();

  public static void hello() {
    synchronized($LOCK) {
      System.out.println("world");
    }
  }

  public int answerToLife() {
    synchronized($lock) {
      return 42;
    }
  }

  public void foo() {
    synchronized(readLock) {
      System.out.println("bar");
    }
  }
}
```

Problem odnośnie blokowania opisałem w rozdziałach ogólnych.

Adnotacja bez parametrów spowoduje, że blokada zostanie ustawiona na zmiennej `$lock`. Można również zdefiniować na jakiej zmiennej ma być ustawiona blokada.

```java
public String getFullName() {
    // Tworzona jest zmienne final String fullName, typ zmiennej jest wywnioskowany
    val fullName = firstName + " " + lastName;

    return fullName;
}

@Synchronized("lockA")
public void sendToEmail() throws InterruptedException {
    log.info(String.format("Rozpoczynam wysyłanie emaila [%s]. Wątek [%s].", id, Thread.currentThread().getId()));

    Thread.sleep(5000);
}
```

## Jackson
[//]: # "jackson"

<img src="../.files/image-20201117142058492.png" alt="image-20201117142058492" style="zoom:50%;" />

Jest to biblioteka do pracy w formatem JSON. Składa się ona z trzech komponentów:

-  Jackson Core,
-  Jackson Databind.
-  Jackson  Annotation.

Artefakt `jackson-databind` zawiera pozostałe więc wystarczy, że dodamy ten artefakt jako zależność. 

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
	<version>2.7.4</version>
</dependency>
```
### Moduły
[//]: # "modules"
Biblioteka udostępnia wiele modułów.

|                                |                                                              |
| ------------------------------ | ------------------------------------------------------------ |
| jackson-databind-nullable      | Dostarcza wrapper JsonNullable. Służy on do przechowywania wartość NULL |
| jackson-modules-java8          | Różnego rodzaju moduły wspierające Java8                     |
| jackson-datatype-jsr310        |                                                              |
| jackson-module-parameter-names |                                                              |

Moduły należy dodać do ObjectMapper

```java
objectMapper = new ObjectMapper();

// JavaTimeModule moduł między innymi odpowiedzialny za serializację/deserializację obiektów jak OffsetDateTime
objectMapper.registerModule(new JavaTimeModule());
objectMapper.registerModule(new JsonNullableModule());
```
### Spring aktywacja modułów
[//]: # "spring-init-modules"

```java
@Configuration
public class JacksonConfiguration {
    @Bean
    public JavaTimeModule javaTimeModule() {
        return new JavaTimeModule();
    }

    @Bean
    public JsonNullableModule jsonNullableModule() {
        return new JsonNullableModule();
    }
}
```
### Widoki
[//]: # "views"
Jest to mechanizm pozwalający na defniowanie widoków. W ramach zdefiniowanych widoków możemy ustawić które pola powinny się wysłietlać. Te informacje są brane pod uwagę prze serializacji danych.

Najprostrzy przypadek wygląda tak:

```java
// Definicja widoków
public class Views {
    public static class Public {
    }
}

// Encja
public class User {
    public int id;

    @JsonView(Views.Public.class)
    public String name;
}

@Test
public void whenUseJsonViewToSerialize_thenCorrect()
  throws JsonProcessingException {

    User user = new User(1, "John");

    ObjectMapper mapper = new ObjectMapper();
    mapper.disable(MapperFeature.DEFAULT_VIEW_INCLUSION);

    String result = mapper
      // Przy serializacji podajemy w ramach którego widoku
      // chcemy odserializować dane.
      .writerWithView(Views.Public.class)
      .writeValueAsString(user);

    assertThat(result, containsString("John"));
    assertThat(result, not(containsString("1")));
}
```

Mechanizm ten pozwala na zdefiniowanie różnych widoków.

### Nieznane pola
[//]: "unknown-fields"

W trakcie tworzenia obiektu ustawimy opcje:

```java
ObjectMapper objectMapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
```

Możemy tą opcje ustawić na poziomie klasy:

```java
@JsonIgnoreProperties(ignoreUnknown = true)
public class MyDtoIgnoreUnknown { ... }
```

## Thymeleaf
[//]:"thymeleaf"
Jest to język szablonów. Jest to standardowy mechanizm w Springu.

**Ważną cechą jest to, że jest on również poprawnym HTML. Oznacza to, że może być odczytany przez przeglądarkę bez potrzeby kompilowania kodu.**

Podstawowe wyrażenia:

- `${...}` odwołanie się do zmiennej,
- `*{...}` wyrażenie wybierające,
- `#{...}` interpolowana wiadomość (i18n),
- `@{...}` : link (URL) expressions.
- `~{...}` : fragment expressions.

**Odwołanie się do zmiennej**

Odwołanie sie do zmiennej jest w określonym kontekście. W przypadku Springa tym kontekstem jest model.

Wyrażenie `` zostanie przekszatłcone w wywołanie `((Book)context.getVariable("book")).getAuthor().getName()`.

Dostępne są również inne wyrażenia, np. iterujące:

```
<li th:each="book : ${books}">
```

**Wyrażenie wybierające**

Działa podobnie jak odwołanie się do zmiennej. Wyrażenie wybierające pozwala na wybranie kontekstu.

```
<div th:object="${book}">
  ...
  <span th:text="*{title}">...</span>
  ...
</div>
```

W bloku wybieramy obiekt `book`. Nastepnie odwołujemy się do pola `title`  w tym obiekcie. Nie musimy pisać całej ścieżki.

**Odwołanie sie do i18n**

Wyrażenie pozwala na odwołanie się do elementu zdefiniowanego w zewnętrznych zasobach np. plikach `.properties`.

```
##{main.title}
##{message.entrycreated(${entryId})}
<table>
  ...
  <th th:text="#{header.address.city}">...</th>
  <th th:text="#{header.address.country}">...</th>
  ...
</table>
```

**Wyrażenie linku**

Pozwala na wygenerowanie linku w określonym kontekście.

```
<a th:href="@{/order/list}">...</a>
```

Może zostać zamienione na:

```
<a href="/myapp/order/list">...</a>
<a href="/myapp/order/list;jsessionid=23fa31abd41ea093">...</a>
```

W linku można dodac parametry:

```
<a th:href="@{/order/details(id=${orderId},type=${orderType})}">...</a>
```

Zostanie zamienione na:

```
<a href="/myapp/order/details?id=23&amp;type=online">...</a>
```

**Wyrażenie fragmentowe**

Wyrażenia fragmentów są łatwym sposobem reprezentowania fragmentów znaczników i przenoszenia ich po szablonach. Dzięki tym wyrażeniom fragmenty mogą być replikowane, przekazywane do innych szablonów jako argumenty i tak dalej.

```html
<div th:insert="~{commons :: main}">...</div>
```

Można wykorzystać w innym miejscu.

```html
<div th:with="frag=~{footer :: #main/text()}">
  <p th:insert="${frag}">
</div>
```

**Przykładowy szablon**

```html
<!DOCTYPE HTML>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Spring framework Guru</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta charset="UTF-8">
</head>
<body>
<h1>Books list</h1>
<table>
    <tr>
        <td>ID</td>
        <td>Title</td>
        <td>Publisher</td>
    </tr>
    <tr th:each="book : ${books}">
        <td th:text="${book.id}"></td>
        <td th:text="${book.title}"></td>
        <td th:text="${book.publisher.name}"></td>
    </tr>
</table>
</body>
</html>
```

**Wyrażenia warunkowe**

Wyrażenie warunkowe możemy zapisać na kilka sposób. Pierwszym sposobem jest użycie dyrektywy `th:if`. Pozwala ona określenie warunku który ma zostać spełniony aby wyświetlić element.

```html
<p th:if="${joke != null}" th:text="${joke.content}">
    Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invid...
</p>
```

Warunek możemy zapisać w krótki sposób:

```html
<p th:text="${joke != null ? joke.content : 'test'}">
    Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invi....
</p>
```
## Liquibase
[//]:"liquibase"
Liquibase to niezależna od bazy danych biblioteka typu open source do śledzenia, zarządzania i stosowania zmian schematu bazy danych. Biblioteka udostępnia wtyczki np. do Mavena za pomocą których można zautomatyzować zarządzanie wersjami bazy.

https://www.liquibase.org
### Użycie w kontekście SpringaBoota
Definiujemy zależność do projektu który ma budować aplikację.

```xml
<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
</dependency>
```

 W momencie uruchamiania aplikacji, uruchamia  się również Liquibase i sprawdza czy została zdefiniowana konfiguracja w ścieżce w `classpath:db/changelog/db.changelog-master.xml`. Jest to podstawowa ścieżka. Można ją zmienić za pomocą opcji `spring.liquibase.change-log`:

```prop
spring.liquibase.change-log=classpath:db/changelog/db.changelog-master.xml
```

Plik zawiera całą definicję.

```xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd">
    <include file="db.changelog-1.0.xml" relativeToChangelogFile="true"/>
</databaseChangeLog>
```

A ten np. załącza inna pliki.
### Generowanie ChangeLogu na postawie tabeli
Istnieje również możliwość wygenerowania pliku zmiana na postawie istniejącej bazy. Do tego potrzebujemy wtyczki.

```xml
<...>
    <build>
        <plugins>
            <plugin>
                <groupId>org.liquibase</groupId>
                <artifactId>liquibase-maven-plugin</artifactId>
                <version>3.4.1</version>
                <configuration>
                    <propertyFile>src/main/resources/liquibase.properties</propertyFile>
                </configuration>
            </plugin>
        </plugins>
    </build>
</...>
```

Oraz konfiguracji do połączenia się z bazą danych.

```properties
url=jdbc:mysql://192.168.99.100:6653/ted_importer?createDatabaseIfNotExist=true
username=root
password=ted
driver=com.mysql.jdbc.Driver
outputChangeLogFile=src/main/resources/liquibase-outputChangeLog.xml
```

Wykonujemy uruchamiamy polecenie.

```
mvn liquibase:generateChangeLog
```

Polecenie powinno spowodować wygenerowanie pliku zmian `src/main/resources/liquibase-outputChangeLog.xml`.
## Dozer mapper
[//]:"dozer"
Jest to biblioteka do mapowania i konwersji obiektów.

https://github.com/DozerMapper/dozer

### Konfiguracja

```xml
<dependency>
    <groupId>net.sf.dozer</groupId>
    <artifactId>dozer</artifactId>
    <version>5.5.1</version>
</dependency>
```

Dozer poza tym, że potrafi mapować jeden obiekt na drugi to również pozwala na konfigurację bardziej złożonych konwersji. Konfiguracja jest umieszczona w pliku XML.

### Przykład

```java
public class Source2 {
    private String id;
    private double points;

    public Source2() {}

    public Source2(String id, double points) {
        this.id = id;
        this.points = points;
    }
    
    // standard getters and setters
}

public class Dest2 {
    private int id;
    private int points;

    public Dest2() {}

    public Dest2(int id, int points) {
        super();
        this.id = id;
        this.points = points;
    }
    
    // standard getters and setters
}

@Test
public void givenSourceAndDestWithDifferentFieldTypes_
  whenMapsAndAutoConverts_thenCorrect() {
    Source2 source = new Source2("320", 15.2);
    Dest2 dest = mapper.map(source, Dest2.class);

    assertEquals(dest.getId(), 320);
    assertEquals(dest.getPoints(), 15);
}
```
### Konfiguracja XML
```xml
<?xml version="1.0" encoding="UTF-8"?>
<mappings xmlns="http://dozer.sourceforge.net" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://dozer.sourceforge.net
      http://dozer.sourceforge.net/schema/beanmapping.xsd">
    <mapping>
        <class-a>com.baeldung.dozer.Personne</class-a>
        <class-b>com.baeldung.dozer.Person</class-b>
        <field>
            <a>nom</a>
            <b>name</b>
        </field>
        <field>
            <a>surnom</a>
            <b>nickname</b>
        </field>
    </mapping>
</mappings>
```

Użycie:

```
@Test
public void givenSrcAndDestWithDifferentFieldNamesWithCustomMapper_
  whenMapsBidirectionally_thenCorrect() {
    configureMapper("dozer_mapping.xml");
    Person englishAppPerson = new Person("Dwayne Johnson", "The Rock", 44);
    Personne frenchAppPerson = mapper.map(englishAppPerson, Personne.class);

    assertEquals(frenchAppPerson.getNom(), englishAppPerson.getName());
    assertEquals(frenchAppPerson.getSurnom(),englishAppPerson.getNickname());
    assertEquals(frenchAppPerson.getAge(), englishAppPerson.getAge());
}
```
## OkHttp
[//]:"okhttp"
Biblioteka Http dla Androida i Javy.

```xml
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
    <version>4.9.1</version>
</dependency>
```

Przykładowe żądania.

```java
@Test
public void whenGetRequest_thenCorrect() throws IOException {
    Request request = new Request.Builder()
      .url(BASE_URL + "/date")
      .build();

    Call call = client.newCall(request);
    Response response = call.execute();

    assertThat(response.code(), equalTo(200));
}
```
## Jasper
[//]:"jasper"
![File:Jasper Logo.jpg - Wikimedia Commons](../.files/Jasper_Logo.jpg)

Jest to narzędzie do generowania raportów z danymi. Umożliwia tworzenia raportu a następnie generowanie go w różnych formatach HTML, PDF, XLS

## ASM OW
[//]:"asm-ow"
![image-20211117160051867](../.files/image-20211117160051867.png)

Jest to biblioteka do modyfikowania bytekodu Javy.

https://asm.ow2.io

## Java Loom
[//]:"java-loom"
Project Loom to próba wprowadzenia przez społeczność OpenJDK lekkiej konstrukcji współbieżności do Javy. Dotychczasowe prototypy Loom wprowadziły zmianę w JVM oraz w bibliotece Java.

https://www.baeldung.com/openjdk-project-loom

## JSF
[//]:"jsf"
JavaServer Faces – framework, bazujący na języku Java, który upraszcza tworzenie interfejsu użytkownika do aplikacji Java EE. Obecnie domyślną technologią widoku dla stron JSF jest technologia Facelets, jednak można korzystać także z innych rozwiązań. 

 ![JSF Architecture](../.files/jsf_architectute.jpg) 

### Processing steps

Six steps:

- Restore view phase
- Apply request values phase; process events
- Process validations phase; process events
- Update model values phase; process events
- Invoke application phase; process events
- Render response phase

 <img src="../.files/jsf_life_cycle.jpg" alt="JSF Life Cycle" style="zoom:150%;" /> 

**Phase 1: Restore view**

------

JSF begins the restore view phase as soon as a link or a button is clicked and JSF receives a request.

During this phase, JSF builds the view, wires event handlers and validators to UI components and saves the view in the FacesContext instance. The FacesContext instance will now contain all the information required to process a request.



**Phase 2: Apply request values**

------

After the component tree is created/restored, each component in the component tree uses the decode method to extract its new value from the request parameters. Component stores this value. If the conversion fails, an error message is generated and queued on FacesContext. This message will be displayed during the render response phase, along with any validation errors.

If any decode methods event listeners called renderResponse on the current FacesContext instance, the JSF moves to the render response phase.



**Phase 3: Process validation**

------

During this phase, JSF processes all validators registered on the component tree. It examines the component attribute rules for the validation and compares these rules to the local value stored for the component.

If the local value is invalid, JSF adds an error message to the FacesContext instance, and the life cycle advances to the render response phase and displays the same page again with the error message.



**Phase 4: Update model values**

------

After the JSF checks that the data is valid, it walks over the component tree and sets the corresponding server-side object properties to the components' local values. JSF will update the bean properties corresponding to the input component's value attribute.

If any updateModels methods called renderResponse on the current FacesContext instance, JSF moves to the render response phase.



**Phase 5: Invoke application**

------

During this phase, JSF handles any application-level events, such as submitting a form/linking to another page.



**Phase 6: Render response**

------

During this phase, JSF asks container/application server to render the page if the application is using JSP pages. For initial request, the components represented on the page will be added to the component tree as JSP container executes the page. If this is not an initial request, the component tree is already built so components need not be added again. In either case, the components will render themselves as the JSP container/Application server traverses the tags in the page.

After the content of the view is rendered, the response state is saved so that subsequent requests can access it and it is available to the restore view phase.
### Configuration web.xml

```xml
<?xml version = "1.0" encoding = "UTF-8"?>
<web-app xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xmlns = "http://java.sun.com/xml/ns/javaee" 
   xmlns:web = "http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
   xsi:schemaLocation = "http://java.sun.com/xml/ns/javaee 
   http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
   id = "WebApp_ID" version="2.5">
	
   <welcome-file-list>
      <welcome-file>faces/home.xhtml</welcome-file>
   </welcome-file-list>
	
   <!-- 
      FacesServlet is main servlet responsible to handle all request. 
      It acts as central controller.
      This servlet initializes the JSF components before the JSP is displayed.
   -->
	
   <servlet>
      <servlet-name>Faces Servlet</servlet-name>
      <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
      <load-on-startup>1</load-on-startup>
   </servlet>
	
   <servlet-mapping>
      <servlet-name>Faces Servlet</servlet-name>
      <url-pattern>/faces/*</url-pattern>
   </servlet-mapping>
	
   <servlet-mapping>
      <servlet-name>Faces Servlet</servlet-name>
      <url-pattern>*.jsf</url-pattern>
   </servlet-mapping>
	
   <servlet-mapping>
      <servlet-name>Faces Servlet</servlet-name>
      <url-pattern>*.faces</url-pattern>
   </servlet-mapping>
	
   <servlet-mapping>
      <servlet-name>Faces Servlet</servlet-name>
      <url-pattern>*.xhtml</url-pattern>
   </servlet-mapping>
</web-app>
```

```

#### Utworzenie modelu i strony
Strona:

​```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns = "http://www.w3.org/1999/xhtml">
   <head>
      <title>JSF Tutorial!</title>
   </head>

   <body>
      #{helloWorld.getMessage()}
   </body>
</html>
```

Model:

```java
package com.tutorialspoint.test;

import javax.faces.bean.ManagedBean;

@ManagedBean(name = "helloWorld", eager = true)
public class HelloWorld {
   
   public HelloWorld() {
      System.out.println("HelloWorld started!");
   }
	
   public String getMessage() {
      return "Hello World!";
   }
}
```
### Model dla widoku

Modele są komponentami. Model może być połączony z widokiem. Modele można defniować przez adnotacje lub przez plik konfiguracyjny.

Plik konfiguracyjny:

```xml
<managed-bean>
   <managed-bean-name>helloWorld</managed-bean-name>
   <managed-bean-class>com.tutorialspoint.test.HelloWorld</managed-bean-class>
   <managed-bean-scope>request</managed-bean-scope>
</managed-bean> 

<managed-bean>
   <managed-bean-name>message</managed-bean-name>
   <managed-bean-class>com.tutorialspoint.test.Message</managed-bean-class>
   <managed-bean-scope>request</managed-bean-scope>
</managed-bean> 
```

Adnotacje:

```java
@ManagedBean(name = "helloWorld", eager = true)
@RequestScoped
public class HelloWorld {
   @ManagedProperty(value = "#{message}")
   private Message message;
   ...
}
```

**@ManagedBean** marks a bean to be a managed bean with the name specified in name attribute. If the name attribute is not specified, then the managed bean name will default to class name portion of the fully qualified class name. In our case, it would be helloWorld.

Another important attribute is **eager**. If eager = "true" then managed bean is created before it is requested for the first time otherwise "lazy" initialization is used in which bean will be created only when it is requested.

Scope annotations set the scope into which the managed bean will be placed. If the scope is not specified, then bean will default to request scope. Each scope is briefly discussed in the following table.

| S.No | Scope & Description                                          |
| :--: | :----------------------------------------------------------- |
|  1   | **@RequestScoped**<br />Bean lives as long as the HTTP request-response lives. It gets created upon a HTTP request and gets destroyed when the HTTP response associated with the HTTP request is finished. |
|  2   | **@NoneScoped**<br />Bean lives as long as a single EL evaluation. It gets created upon an EL evaluation and gets destroyed immediately after the EL evaluation. |
|  3   | **@ViewScoped**<br />Bean lives as long as the user is interacting with the same JSF view in the browser window/tab. It gets created upon a HTTP request and gets destroyed once the user postbacks to a different view. |
|  4   | **@SessionScoped**<br />Bean lives as long as the HTTP session lives. It gets created upon the first HTTP request involving this bean in the session and gets destroyed when the HTTP session is invalidated. |
|  5   | **@ApplicationScoped**<br />Bean lives as long as the web application lives. It gets created upon the first HTTP request involving this bean in the application (or when the web application starts up and the eager=true attribute is set in @ManagedBean) and gets destroyed when the web application shuts down. |
|  6   | **@CustomScoped**<br />Bean lives as long as the bean's entry in the custom Map, which is created for this scope lives. |

**@ManagedProperty**

SF is a simple static Dependency Injection (DI) framework. Using **@ManagedProperty** annotation, a managed bean's property can be injected in another managed bean.

Let us create a test JSF application to test the above annotations for managed beans.

Przykład implementacji:

```java
package com.tutorialspoint.test;

import javax.faces.bean.ManagedBean;
import javax.faces.bean.ManagedProperty;
import javax.faces.bean.RequestScoped;

@ManagedBean(name = "helloWorld", eager = true)
@RequestScoped
public class HelloWorld {
   @ManagedProperty(value = "#{message}")
   private Message messageBean;
   private String message;
   
   public HelloWorld() {
      System.out.println("HelloWorld started!");   
   }
   
   public String getMessage() {
      
      if(messageBean != null) {
         message = messageBean.getMessage();
      }       
      return message;
   }
   
   public void setMessageBean(Message message) {
      this.messageBean = message;
   }
}
```

Oraz plik widoku:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns = "http://www.w3.org/1999/xhtml">
   <head>
      <title>JSF Tutorial!</title>
   </head>
   
   <body>
      #{helloWorld.message}
   </body>
</html>
```
### Components
JavaServer Faces HTML tag library represents HTML form components and other basic HTML elements, which are used to display or accept data from the user. A JSF form send this data to the server after submitting the form.

The following table contains the user interface components.

| Tag                     | Functions                                                    | Rendered As                                                  | Appearance                                                   |
| :---------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| h:inputText             | It allows a user to input a string.                          | An HTML `<input type="text">` element                        | A field                                                      |
| h:outputText            | It displays a line of text.                                  | Plain text                                                   | Plain text                                                   |
| h:form                  | It represents an input form.                                 | An HTML `<form>` element                                     | No appearance                                                |
| h:commandButton         | It submits a form to the application.                        | An HTML `<input type=value>` element for which the type value can be "submit", "reset", or "image" | A button                                                     |
| h:inputSecret           | It allows a user to input a string without the actual string appearing in the field. | An HTML `<input type="password">` element                    | A field that displays a row of characters instead of the actual string entered. |
| h:inputTextarea         | It allows a user to enter a multiline string.                | An HTML `<textarea>` element                                 | A multirow field                                             |
| h:commandLink           | It links to another page or location on a page.              | An HTML `<a href>` element                                   | A link                                                       |
| h:inputSecret           | It allows a user to input a string without the actual string appearing in the field. | An HTML `<input type="password">` element                    | A field that displays a row of characters instead of the actual string entered. |
| h:inputHidden           | It allows a page author to include a hidden variable in a page. | An HTML `<input type="hidden">` element                      | No appearance                                                |
| h:inputFile             | It allows a user to upload a file.                           | An HTML `<input type="file">` element                        | A field with a Browse button                                 |
| h:graphicImage          | It displays an image.                                        | An HTML `<img>` element                                      | An image                                                     |
| h:dataTable             | It represents a data wrapper.                                | An HTML `<table>` element                                    | A table that can be updated dynamically.                     |
| h:message               | It displays a localized message.                             | An HTML `<span>` tag if styles are used                      | A text string                                                |
| h:messages              | It displays localized messages.                              | A set of HTML `<span>` tags if styles are used               | A text string                                                |
| h:outputFormat          | It displays a formatted message.                             | Plain text                                                   | Plain text                                                   |
| h:outputLabel           | It displays a nested component as a label for a specified input field. | An HTML `<label>` element                                    | Plain text                                                   |
| h:outputLink            | It links to another page or location on a page without generating an action event. | An HTML `<a>` element                                        | A link                                                       |
| h:panelGrid             | It displays a table.                                         | An HTML `<table>` element with `<tr>` and `<td>` elements    | A table                                                      |
| h:panelGroup            | It groups a set of components under one parent.              | A HTML `<div>` or `<span>` element                           | A row in a table                                             |
| h:selectBooleanCheckbox | It allows a user to change the value of a Boolean choice.    | An HTML `<input type="checkbox"> `element                    | A check box                                                  |
| h:selectManyCheckbox    | It displays a set of check boxes from which the user can select multiple values. | A set of HTML` <input>` elements of type checkbox            | A group of check boxes                                       |
| h:selectManyListbox     | It allows a user to select multiple items from a set of items all displayed at once. | An HTML `<select>` element                                   | A box                                                        |
| h:selectManyMenu        | It allows a user to select multiple items from a set of items. | An HTML `<select>` element                                   | A menu                                                       |
| h:selectOneListbox      | It allows a user to select one item from a set of items all displayed at once. | An HTML `<select>` element                                   | A box                                                        |
| h:selectOneMenu         | It allows a user to select one item from a set of items.     | An HTML `<select>` element                                   | A menu                                                       |
| h:selectOneRadio        | It allows a user to select one item from a set of items.     | An HTML `<input type="radio">` element                       | A group of options                                           |
| h:column                | It represents a column of data in a data component.          | A column of data in an HTML table                            | A column                                                     |

## SQLJ
[//]:"sqlj"
SQLJ is a deprecated working title for efforts to combine Java and SQL. It was a common effort started around 1997 by engineers from IBM, Oracle, Compaq, Informix, Sybase, Cloudscape and Sun Microsystems.

Advantages and disadvantages

Some advantages of SQLJ over JDBC include:

 - SQLJ commands tend to be shorter than equivalent JDBC programs.
 - SQL syntax can be checked at compile time. The returned query results can also be checked strictly.
 - Preprocessor might generate static SQL which performs better than dynamic SQL
   because query plan is created on program compile time, stored in database and
   reused at runtime. Static SQL can guarantee access plan stability. IBM DB2 supports static SQL use in SQLJ programs.

Disadvantages include:

 - SQLJ requires a preprocessing step.
 - Many IDEs do not have SQLJ support.
 - SQLJ lacks support for most of the common persistence frameworks, such as Hibernate.

![1567940566018](../.files/1a5594bc-d708-46d9-a199-57a142bd0d1a.gif)

# Moduły

Nazywane również Jigsaw w Javie. Zostało to opisane w <http://openjdk.java.net/projects/jigsaw/quick-start>.

Inne rozwiązania:

- OSGi,
- jboss
  <https://github.com/jboss-modules/jboss-modules>

## Wprowadzenie
Od Java 9 został wprowadzany system modułów.

<https://www.zyxist.com/blog/zrozumiec-moduly-w-javie-9>

Wprowadzenie modułów wprowadza nowy poziom grupowania:

- klasa to pojemnik na pola i metody,
- pakiet to pojemnik na klasy oraz interfejsy,
- **moduł to pojemnik na pakiety**.

Oznacza to, że zyskujemy zupełnie nowe miejsce do wprowadzenia kontroli dostępu i możemy ukryć część naszych pakietów przed innymi modułami. Deklaracja moduły jest umieszczona w pliki `module-info.java`. Plik powinien być umieszczony w katalogu paczki.

Przykładowa deklaracja została umieszczona poniżej.

```java
module com.zyxist.foo {
   requires com.google.common;
   requires org.slf4j.api;
   exports com.zyxist.foo.api;
}
```

Powyższy zapis oznacza, że nasz moduł `com.zyxist.foo` importuje *"publiczne"* pakiety z Guavy i SLF4j oraz wystawia swoje własne publiczne API. Pisząc kod w obrębie tego modułu nie możemy odwoływać się do wewnętrznych klas oraz interfejsów Guavy, co zabezpiecza nas przed przypadkowym wykorzystaniem czegoś, czego nie dotyczy polityka utrzymywania wstecznej kompatybilności. Atrybut `exports` pozwala nam zrobić to samo w drugą stronę: gdy wypuścimy nasz moduł w świat, jasno zaznaczamy że dozwolone jest korzystanie wyłącznie z klas stworzonych w tym jednym, konkretnym pakiecie, a pozostałe inne są naszą prywatną sprawą, do której nikt nie powinien się wtrącać. Myślę, że jest to też duża pomoc dla developerów, którzy dopiero zaczynają pracę w zespole i poznają projekt. Teraz wystarczy jeden rzut oka, aby zauważyć, co jest publicznym API, a co nim nie jest i czy należy się pilnować, czy nie.

Istnieją dwa style nazywania większych jednostek w Javie:

- projektowy: **guava**, **junit**, **spark.core**
- odwrotny DNS: `com.google.common`, `org.junit`, ...

Trzy kropki pojawiły się celowo, bowiem znaleźliśmy konflikt - czy w **spark.core** chodzi o Spark Framework używający pakietów `com.sparkjava.core`, czy o Apache Spark z pakietami `org.apache.spark.core`? W zasadzie ten przykład już powinien w zupełności wystarczyć do wydedukowania, którego stylu powinniśmy używać dla modułów - maszyna wirtualna bowiem odmówi nam startu, jeśli podrzucimy jej dwa różne moduły mające tę samą nazwę. Styl projektowy doskonale sprawdza się w systemach budowania, gdzie towarzyszy mu jeszcze grupa. Na poziomie kodu źródłowego mamy jednak bardzo dobrze ugruntowaną konwencję, która chroni nas z powodzeniem przed kolizjami od lat 90. A skoro moduł to pojemnik na pakiety, rozsądnym wydaje się nazwanie modułu od "wspólnego mianownika". Wtedy moduł staje się jednocześnie oświadczeniem, że przejmujemy na własność ten konkretny kawałek dostępnej przestrzeni nazw.

Obecnie używanie stylu odwrotnych nazw DNS jest [oficjalną rekomendacją](http://openjdk.java.net/projects/jigsaw/spec/issues/#AutomaticModuleNames).

Dla istniejących modułów Jigsaw działa w ten sposób, że zastępuje istniejący obecnie mechanizm *classpath* przez *modulepath*. W języku programowania mającym za sobą 20 lat historii oznacza to jednak, że trzeba coś zrobić z napisanym dotychczas kodem. W szczególności może wydarzyć się sytuacja, w której chcielibyśmy zbudować modułową aplikację, ale jedna z naszych zależności nie miałaby odpowiednich deskryptorów. Rozwiązaniem zaproponowanym przez twórców Javy są *automatyczne moduły*. Innymi słowy, Java potraktuje zwykłe archiwum JAR jak moduł zbudowany wg następujących reguł:

- wszystkie pakiety są publicznie dostępne,
- automatyczny moduł zależy od wszystkiego, co znajduje się w *modulepath* ORAZ WYJĄTKOWO także *classpath* (normalnie nie jest to dozwolone),
- nazwa modułu wyliczana jest z nazwy archiwum, np. `guava.jar` » `guava`.
## Deskryptor modułu
Deskryptorem modułu jest plik `module-info.java` znajdujący się z katalogu głównym paczki. Deskryptor składa się z pól opisujących z tego moduł korzysta oraz co dostarcza.

- Nazwa - nazwa naszego modułu,
- Zależności - lista innych modułów, od których ten moduł zależy,
- Pakiety publiczne - lista wszystkich pakietów, które chcemy uzyskać z zewnątrz modułu,
- Oferowane usługi - możemy zapewnić wdrożenia usług, które mogą być wykorzystywane przez inne moduły,
- Consumed Services - pozwala bieżącemu modułowi być konsumentem usługi,
- Uprawnienia do refleksji - wyraźnie pozwala innym klasom na użycie refleksji w celu uzyskania dostępu do prywatnych członków pakietu

Grupy modułów:

- Moduły systemowe - są to moduły wymienione po uruchomieniu powyższej komendy * list-modules *. Obejmują one moduły Java SE i JDK.
- Moduły aplikacji - te moduły zwykle budujemy, gdy decydujemy się na użycie modułów. Są one nazwane i zdefiniowane w skompilowanym pliku * module-info.class * zawartym w skompilowanym pliku JAR.
- Automatyczne moduły - Możemy dołączyć nieoficjalne moduły, dodając istniejące pliki JAR do ścieżki modułu. Nazwa modułu będzie pochodzić od nazwy JAR. Automatyczne moduły będą miały pełny dostęp do odczytu do każdego innego modułu ładowanego przez ścieżkę.
- Moduł bez nazwy - Gdy klasa lub plik JAR jest ładowany do ścieżki klasy, ale nie do ścieżki modułu, jest on automatycznie dodawany do modułu bez nazwy. Jest to moduł typu catch-all, który zapewnia zgodność wsteczną z wcześniej napisanym kodem Java.
### Struktura deskryptora
```java
module my.module {
    requires module.name;
    requires static module.name;
    requires transitive module.name;

    // Exports
    exports com.my.package.name;
    export com.my.package.name to com.specific.package;

    uses class.name;
    provides MyInterface with MyInterfaceImpl;

    // opens
    opens com.my.package;
    opens com.my.package to moduleOne, moduleTwo, etc.;
}
```

- `requires` definiuje zależności modułu. W tym przypadku wymagany jest moduł `module.name`. Na etapie kompilacji oraz uruchomienia.
- `requires static` definiuje zależność na etapie kompilacji, zależność nie jest wymagana na etapie działania. Np. mamy funkcje która wyświetla dane na wyjściu jakiegoś urządzenia. Do obsługi urządzenia potrzebny jest moduł `out.printer` z tym, że nie każdy kto korzysta z naszego modułu chce mieć obsługę tego urządzenia, wiec też nie jest wymagane aby miał moduł `out.printer`.
  Jeśli chcemy zdefiniować zależność (jak by opcjanalną) to używamy `static`.
  `requires static out.printer`.
- `requires transitive`  jest to przekazanie zależność. Np. jeśli korzystam z modułu `A`, a moduł `A` korzysta z modułu `B` i `C` to w obrębie swojego modułu muszę zdefiniować również, że wymagam `B` i `C`. Pomimo, że sam w kodzie z tych modułów nie korzystam. Dlatego zależność zdefiniowana jako   `transitive`  powoduje, że wszystkie zależności `A` zostaną automatycznie dodane do mojego modułu.
-  `exports` eksportuje publiczne elementy z określonej paczki. Dana paczka musi być wyeksportowana aby mogła zostać zaczyna przez inny moduł.
- `export ... to ...`, pozwala na wyeksportowanie paczki dla określonego modułu. Normalny eksport wystawia paczkę na "caly świat".
- `uses` określa jaka usługa jest wykorzystywana, mechanizm usług został opisany w inny rozdziale,
- `provides` informuje jaką usługę dostarcza moduł,
- `opens` otwiera paczkę w module dla mechanizmów refleksji. Nie które modułu np. kontener zależności Guice korzysta z mechanizmu refleksji aby np. określić zlewności (`@Inject`).
- `opens ... to ...,....` działa tak jak `opens` tylko dla określonych modułów.
## Opcje związane z modułami
- module-path - definiuje ścieżki do katalogów z modułami, moduły mogą być w formacie Jar albo nie spakowanie,
- add-reads – Instead of relying on the module declaration file, we can use the command line equivalent of the requires directive; –add-reads.
- add-exports – Command line replacement for the exports directive.
- add-opens – Replace the open clause in the module declaration file.
- add-modules – Adds the list of modules into the default set of modules
- list-modules – Prints a list of all modules and their version strings
- patch-module – Add or override classes in a modules
- illegal-access=permit|warn|deny – Either relax strong encapsulation by showing a single global warning, shows every warning, or fails with errors. The default is permit.
### Opcja `--add-exports`
Opcja występuje w `java`  i `javac`. Opcji można użyć aby zdefiniować eksport dodatkowe eksporty między modułami. Np. w projekcie Httpio okazało się w jeden z modułów zewnętrznych wymagał innego modułu zewnętrznego. Wynikało to być może ze źle zdefiniowanych deskryptorów, albo te moduły nie były dostosowane do działa jako moduły. Wyświetlał mi się komunikat:

```
error: package com.sun.java.swing.plaf.nimbus is not visible
import com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel;
                              ^
  (package com.sun.java.swing.plaf.nimbus is declared
   in module java.desktop, which does not export it)
1 error
```

Oznacza to, że `com.sun.java.swing.plaf.nimbus` jest nie widoczny dla `java.desktop`. Moduł `...nibus` nie eksportuje wymaganej paczki.

Dodajemy opcję `--add-exports` , powoduje to, że eksport jest zdefiniowany i możliwe jest kompilacja oraz uruchomienie.

```shell
javac
    --add-exports java.desktop/com.sun.java.swing.plaf.nimbus=ALL-UNNAMED
    --class-path $dependencies
    -d $target-folder
    $source-files


# Inny eksport
--add-exports javafx.graphics/com.sun.javafx.scene.traversal=org.controlsfx.controls
```

 Powyższy zapis oznacza, że dla modułu `java.desktop` udostępniamy w trybie do odczytu moduł `com.sun.java.swing.plaf.nimbus`.

Jest to prawie jednoznaczne z tym, że paczka `com.sun.java.swing.plaf.nimbus` w pliku `module-info.java`  umieszcza taki eksport.

```java
module com.sun.java.swing.plaf.nimbus {
    exports com.sun.java.swing.plaf.nimbus;
}
```
### Opcja `--add-opens`
Umożliwia zdefiniowanie otwarcia modułu dla mechanizmu reflekcji dla innego modułu.

Dość często występuje sytuacja gdy np. określony moduł nie udostępnia elementów dla mechanizmu reflekcji, a inny moduł korzysta z tego mechanizmu.

Miałem taką sytuację:

```
module java.base does not "opens java.lang" to module com.google.guice
```

Oznacza to, że moduł `java.base` nie udostępnia elementu `java.lang` dla modułu `com.google.guice` w do refleksi. Moduł Guice tego wymaga aby się dowiedzieć np. jakie obiekty mają zostać wstrzyknięte.

Ta sytuacja mogła by być naprawiona, jeśli dodali byśmy do modułu `java.base` dodatkowe otwarcie. Niestety można zrobić dość łatwo z poziomu deskryptora modułu.

Opcja `--add-opens` umożliwia zdefiniowanie takiego otwarcia na etapie kompilacji i uruchomienia.

W tym przypadku musiałem dodać opcję:

````
--add-opens java.base/java.lang=com.google.guice
````

Istnieje również duża grupa modułów `UNNAMED`. Są to moduły niedostosowane do standardów modułów. Dla tych wszystkich modułów dodajemy otwarcia w ten sposób.

```
--add-opens java.base/java.lang=ALL-UNNAMED
```
## Tworzenie modułów
W tym przykładzie stworze trzy moduły:

- httpio.app,
- httpio.gui,
- httpio.logic.

Struktura katalogów wygląda następująco:

```
httpio.app
├── httpio
│   └── app
│       └── App.java
└── module-info.java
httpio.gui
├── httpio
│   └── gui
│       └── Display.java
└── module-info.java
httpio.logic
├── httpio
│   └── logic
│       └── Counter.java
└── module-info.java

```

Katalog zawiera kropki w nazwie (jest to taka konwencja). Każdy moduł może zawiera dowolne zasoby oraz mieć swoją własną strukturę. Np. w modułach korzystających z Mavena struktura będzie taka jak w przypadku zwykłej aplikacji (src/main/java ...).

Plik `module-info.java` jest tgz. deskryptorem moduły. Opisuje on jakie elementy moduł wystawia na zewnątrz oraz jakie wymaga.

```java
package httpio.app;

import httpio.logic.Counter;
import httpio.gui.Display;

public class App {
    public static void main(String[] args) {

        Counter counter = new Counter();

        int sum = counter.sum(10, 10);

        Display display = new Display();

        display.print(sum);
    }
}

// ----------------

package httpio.gui;

public class Display {

    public void print(int value) {
        System.out.println("value is : " + value);
    }
}

// ---------------

package httpio.logic;

public class Counter {
    public int sum(int a, int b) {
        return a + b;
    }
}
```

Moduł `httpio.App` zawiera klasę `App` która uruchamia aplikacje. `App` korzysta z modułu `httpio.gui` oraz `httpio.logic`.

Skompilujmy kod.

```shell
# Tworzymy katalogi na wyniki kompilacji
mkdir -p mods/httpio.{app,gui,logic}

# Kompulujemy moduły
javac -d mods/httpio.gui httpio.gui/module-info.java httpio.gui/httpio/gui/Display.java
javac -d mods/httpio.logic httpio.logic/module-info.java httpio.logic/httpio/logic/Counter.java

# Moduł httpio.app musimy kompilować z podana ścieżko z lokalizoacja pozostałych modułów
javac --module-path mods -d mods/httpio.app httpio.app/module-info.java httpio.app/httpio/app/App.java

```

W trakcie próby kompilacji `httpio.app` dostaniemy komunikat:

```
httpio.app/httpio/app/App.java:3: error: package httpio.logic is not visible
import httpio.logic.Counter;
             ^
  (package httpio.logic is declared in module httpio.logic, but module httpio.app does not read it)
httpio.app/httpio/app/App.java:4: error: package httpio.display does not exist
import httpio.display.Display;
                     ^
httpio.app/httpio/app/App.java:13: error: cannot find symbol
        Display display = new Display();
        ^
  symbol:   class Display
  location: class App
httpio.app/httpio/app/App.java:13: error: cannot find symbol
        Display display = new Display();
                              ^
  symbol:   class Display
  location: class App
4 errors
```

Oznacza to, że klasy `httpio.logic.Counter`, `httpio.display.Display` są zadeklarowane ale nie są widoczne (moduł `httpio.app` nie ma do nich dostępy).

Konfigurujemy moduły.

```java
module httpio.app {
    requires httpio.logic;
    requires httpio.gui;
}

module httpio.logic {
    exports httpio.logic;
}

module httpio.logic {
    exports httpio.logic;
}
```

Po takiej konfiguracji moduł `httpio.app` może zostać skompilowane.

Zmieńmy konfiguracje dla modułu `httpio.logic` tak aby nie eksportowała nic.

```java
module httpio.logic {
    // exports httpio.logic;
}
```

Po rekompilacji moduły `httpio.logic` oraz próbie skompilowania `httpio.app` dostajemy komunikat:

```
httpio.app/httpio/app/App.java:3: error: package httpio.logic is not visible
import httpio.logic.Counter;
             ^
  (package httpio.logic is declared in module httpio.logic, which does not export it)
1 error
```

W ten sposób ukryliśmy cały pakiet `logic`.

Tak skompilowane pakiety możemy uruchomić.

```shell
java --module-path mods/ -m httpio.app/httpio.app.Ap
```

Jeśli przeniesiemy moduły np. do katalogu `src` to możliwe jest skompilowanie wszystkich modułów jednym poleceniem.

```shell
javac -d mods/ --module-source-path src/ $(find src -name "*.java")
```

Opcja `--module-source-path` definiuje w którym katalogu znajdują się katalogi źródłowe dla modułów.
## Pakowanie modułów
Moduły skompilowane w katalogach możemy spakować do plików `jar`. Plik `jar` jest łatwiej rozpowszechniać.

```shell
jar --create --file=lib/httpio.gui@1.0.0.jar --module-version=1.0.0 -C mods/httpio.gui .
jar --create --file=lib/httpio.logic@1.0.0.jar --module-version=1.0.0 -C mods/httpio.logic .
jar --create --file=lib/httpio.app@1.0.0.jar --module-version=1.0.0 --main-class=httpio.app.App -C mods/httpio.app .
```

W przypadku `httpio.app` mamy zdefiniowaną klasę podstawową.

Mając tak spakowane moduły możemy je uruchomić.

```shell
java --module-path lib/ --module httpio.app
```

Java uruchamia określony moduł. Moduł ma ustawioną klasę `main`. Przekazując parametr `--module-path` przekazujemy informacje gdzie znajdują się zasoby (biblioteki) - możemy podać kilka ścieżek.

W trakcie uruchamiania Java przeszukuje ścieżki i załącza odpowiednie moduły. Podobnie jak miało to miejsce w przypadku `CLASSPATH`.

Dla testów usunąłem `httpio.logic@1.0.0.jar`. Ten moduł mam w wersji niespakowanej w katalogu `mods`.  Ponownie spróbowałem uruchomić aplikację tylko z dwiema zdefiniowanymi ścieżkami do modułów.

```shell
java --module-path="lib;mods" --module httpio.app
```

Aplikacja się uruchomiła, cześć modułów `httpio.app, httpio.gui` zostały zaczytane z `lib` z formy `jar`. Natomiast moduł `httpio.logic` został odczytany z `mod` z wersji przed spakowanie.

Java odczytała spakowane moduły oraz te tylko skompilowane.

Możliwe jest również odczytanie informacji o module.

```shell
$ jar --describe-module --file=lib/httpio.app\@1.0.0.jar
httpio.app@1.0.0 jar:file:///F:/tmp/lib/httpio.app@1.0.0.jar/!module-info.class
requires httpio.gui
requires httpio.logic
requires java.base mandated
contains httpio.app
main-class httpio.app.App
```

Tak skompilowane i spakowane moduły możemy spakować do jednej wykonywalnej paczki. Do tworzenia takich wykonywalnych paczek służy narzędzie `jlink`. Sposób pakowania opisałem  w osobnym rozdziale.

# Java EE

JavaEE (Java for Enterprise Edition) jest platformą do tworzenia aplikacji biznesowych agregującą zestaw specyfikacji dla języka Java, które w założeniu mają upraszczać rozwiązywanie złożonych i powtarzalnych problemów związanych z wytwarzaniem oprogramowania.

Początkowo platforma nosiła nazwę J2EE (Java 2 Platform Enterprise Edition) i zawierała tylko wąski wycinek tego co obecnie, m.in.:

- JDBC jako główną specyfikację komunikacji z bazami danych
- Java servlets jako komponenty komunikacji sieciowej w oparcui o protokół HTTP
- JSP (Java ServerPages) pozwalające tworzyć dynamiczne strony HTML
- EJB (Enterprise Java Beans stanowiące podstawowe komponenty budowy warstwy usług aplikacji
- i wiele więcej

Pierwsze wersje J2EE nie były zbytnio lubiane przez programistów. Pomimo iż oparte o Javę dawały spore możliwości skalowania, rozproszenia komponentów i ogólnej wydajności, to sam model był dosyć skomplikowany. Szczególną rolę odegrała tutaj dosyć znienawidzona technologia EJB (w wersji wcześniejszej niż 3), która była jedną z przyczyn powstania najpopularniejszego dziś frameworka Spring.

Z powodu wielu narzekań i słabnącej popularności J2EE na rzecz frameworków takich jak [Spring](https://javastart.pl/baza-wiedzy/frameworki/spring/), czy Struts, w wersji 5 postanowiono odciąć się od wcześniejszej numeracji (1.1, 1.2, itd) oraz samej nazwy J2EE zastępując ją krótszą wersją Java EE 5.

Co ciekawe w ofertach pracy nadal bardzo często pojawia się historyczne nazewnictwo, co najczęściej sugeruje, że rekruter ma niewielkie pojęcie o samej Javie.

Najważniejsze zmiany, które przyniosła Java EE 5 to zupełna zmiana modelu EJB i dodanie specyfikacji mapowania obiektowo-relacyjnego JPA bazującego na doświadczeniach frameworka Hibernate.

Wersje 6 i 7 to dalsze prace nad tym, aby platforma była coraz lżejsza i intuicyjna, wprowadzenie frameworka MVC w postaci JSF (JavaServer Faces) oraz standardu wstrzykiwania zależności pomiędzy różnymi komponentami w postaci [CDI](https://javastart.pl/baza-wiedzy/frameworki/cdi) (Contexts and Dependency Injection).
## Specyfikacje
Java EE to w rzeczywistości zbiór specyfikacji opisujących zachowanie poszczególnych jej elementów. Nie są to więc żadne elementy w rozumieniu semantycznym (nie znajdziemy tutaj nowych typów danych, czy nowych rodzajów pętli), a jedynie zbiór interfejsów oraz opis ich działania. Warto wymienić tutaj takie elementy jak :

- **CDI** (Context and dependency injection) - wstrzykiwanie zależności
- **JPA** (Java Persistence API) - mapowanie obiektowo relacyjne
- **EJB** (Enterprise Java Beans) - warstwa usług ze wsparciem dla zarządzania transakcjami
- [**JaxRS**](https://javastart.pl/baza-wiedzy/frameworki/jax-rs/) - specyfikacja dedykowana do tworzenia aplikacji REST
- **JSF** (Java ServerFaces) - framework MVC integrujący się z innymi elementami JEE![specyfikacje jee7](../.files/jee7-specifications.jpg) 
## Serwery Javy EE
Wśród serwerów dedykowanych dla technologii Java EE można dokonać podziału na takie, które są wyłącznie kontenerami serwletów, np. Tomcat, czy Jetty oraz serwery z pełnym wsparciem Javy EE takie jak JBoss/Wildfly, Glassfish, WebLogic, WebSphere, które rozwijane są przez różne firmy.



![Serwery JEE](../.files/jee-servers.png)



Co ciekawe najpopularniejszym serwerem jest Tomcat, który jest jednym z najprostszych w tym zestawieniu. Jego popularność wynika przede wszystkim z tego, że jest on mocno powiązany ze Spring Framework. Różnica pomiędzy kontenerami serwletów, a serwerami aplikacji polega przede wszystkim na ich możliwościach. W serwerze aplikacji wszystkie biblioteki takie jak Hibernate są już nam dostarczone, w przypadku kontenerów serwletów będziemy musieli zadbać o wszystkie biblioteki samodzielnie.

# Serwlety
Servlet jest podstawowym elementem aplikacji biznesowych tworzonych w języku Java. W rzeczywistości jest to klasa rozszerzająca klasę HttpServlet, która jest zdolna do przetwarzania żądań HTTP. Serwlety wykorzystywane są zarówno w aplikacjach Javy EE jak i tych tworzonych w Spring MVC.

Serwlety do poprawnego działania wymagają kontenera serwletów, wśród których najpopularniejsze to Tomcat, czy Jetty.
## Przykładowy Servlet
```java
package com.journaldev.servlet.session;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet implementation class LoginServlet
 */
@WebServlet("/LoginServlet")
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final String userID = "admin";
	private final String password = "password";

	protected void doPost(HttpServletRequest request,
			HttpServletResponse response) throws ServletException, IOException {

		// get request parameters for userID and password
		String user = request.getParameter("user");
		String pwd = request.getParameter("pwd");
		
		if(userID.equals(user) && password.equals(pwd)){
			HttpSession session = request.getSession();
			session.setAttribute("user", "Pankaj");
			//setting session to expiry in 30 mins
			session.setMaxInactiveInterval(30*60);
			Cookie userName = new Cookie("user", user);
			userName.setMaxAge(30*60);
			response.addCookie(userName);
			response.sendRedirect("LoginSuccess.jsp");
		}else{
			RequestDispatcher rd = getServletContext().getRequestDispatcher("/login.html");
			PrintWriter out= response.getWriter();
			out.println("<font color=red>Either user name or password is wrong.</font>");
			rd.include(request, response);
		}

	}
}
```
## Mapowanie adresu URL
W obecnej specyfikacji Javy EE, Servlety dostępne są w wersji 3.1, a od Javy EE 8 pojawi się ich wersja 4.0. Największą zmianę przyniosły Servlety 3.0, w których wprowadzono możliwość określenia docelowego adresu URL nie tylko poprzez plik web.xml (deskryptor wdrożenia), ale również w sposób deklaratywny poprzez adnotację **@WebServlet**.

W starszych wersjach serwletów mapowanie ustawialiśmy w pliku web.xml w następujący sposób:

*web.xml*

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://xmlns.jcp.org/xml/ns/javaee"
	xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
	version="3.1">
	
	<servlet>
		<servlet-name>Hello</servlet-name>
		<servlet-class>pl.javastart.servlet.HelloServlet</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>Hello</servlet-name>
		<url-pattern>/hi</url-pattern>
	</servlet-mapping>
</web-app>
```

Dwie kluczowe sekcje to `<servlet>`, która zawiera definicję servletu oraz `<servlet-mapping>` zawierająca mapowanie adresu URL. Jeśli więc wyślemy żądanie do naszej aplikacji pod adres `/hi`, to wywołana zostanie jedna z metod klasy *HelloServlet*. Dostępne metody to:

- doGet()

- doPost()

- doTrace()

- toHead()

- doPut()

- doOptions()

jak nazwy sugerują odpowiadają one poszczególnym metodom HTTP, czyli GET, POST, TRACE...

Od specyfikacji Servlet 3.0 plik web.xml stał się opcjonalny ze względu na silny zwrot w kierunku konfiguracji opartych o adnotacje i automatyczne konfiguracje. Od Javy EE6 (servlet 3.0) najczęściej spotkamy się więc z mapowaniem postaci:

```java
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;

@WebServlet("/hi")
public class HelloServlet extends HttpServlet {
	//...
}
```
## Cykl życia
Cykl życia Servletu wygląda tak, że przy pierwszym odwołaniu do niego kontener (np. Tomcat) tworzy obiekt klasy reprezentującej serwlet zmapowany na dany adres URL. Zycie obiektu składa się z kilku etapów:

- utworzenie obiektu serwletu poprzez konstruktor

- wywołanie metody init()

- wielokrotne wywoływanie metod doGet, doPost itp.

- wywołanie metody destroy()

Ważne jest to, że powstanie tylko jeden taki obiekt i będzie współdzielony pomiędzy wszystkich użytkowników naszej aplikacji, dlatego należy zwrócić szczególną uwagę na kwestie wielowątkowości - np. definiowanie w serwletach współdzielonych, niesynchronizowanych pól klasy.
## Żądanie i odpowiedź
Każda z metod wspomnianych w punkcie Mapowane adresu URL przyjmuje dwa parametry:

- HttpServletRequest

- HttpServletResponse

które reprezentują odpowiednio żądanie i odpowiedź HTTP. Z punktu widzenia programisty z pierwszego obiektu możemy odczytać parametry żądania, ciasteczka, czy też odwołać się do sesji powiązanej z użytkownikiem, natomiast korzystając z obiektu response możemy wysłać odpowiedź.

![](../../../.files\114ab3ec-6159-485f-b8af-8659306c54df.png)
## Filtry
Filtry serwletów to wtykowe komponenty java, których możemy używać do przechwytywania i przetwarzania żądań, zanim zostaną one wysłane do serwletów i odpowiedzi po zakończeniu kodu serwletu i zanim kontener odeśle odpowiedź do klienta.

Niektóre typowe zadania, które możemy wykonać za pomocą filtrów serwletu to:

- Parametry żądania rejestrowania do rejestrowania plików.
- Uwierzytelnianie i uwierzytelnianie żądania zasobów.
- Formatowanie treści żądania lub nagłówka przed wysłaniem go do serwletu.
- Kompresowanie danych odpowiedzi wysyłanych do klienta.
- Zmień odpowiedź, dodając pliki cookie, informacje w nagłówku itp.

Filtry moga zostać zdefiniowane za pomoca pliku konfiguracyjnego `web.xml`.

```xml
<filter>
  <filter-name>RequestLoggingFilter</filter-name> <!-- mandatory -->
  <filter-class>com.journaldev.servlet.filters.RequestLoggingFilter</filter-class> <!-- mandatory -->
  <init-param> <!-- optional -->
  <param-name>test</param-name>
  <param-value>testValue</param-value>
  </init-param>
</filter>

<filter-mapping>
  <filter-name>RequestLoggingFilter</filter-name> <!-- mandatory -->
  <url-pattern>/*</url-pattern> <!-- either url-pattern or servlet-name is mandatory -->
  <servlet-name>LoginServlet</servlet-name>
  <dispatcher>REQUEST</dispatcher>
</filter-mapping>
```

Lub za pomoca adnotacji `javax.servlet.annotation.WebFilter`.
### Przykładowy filtr autentykujacy
```java

package com.journaldev.servlet.filters;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

@WebFilter("/AuthenticationFilter")
public class AuthenticationFilter implements Filter {

	private ServletContext context;
	
	public void init(FilterConfig fConfig) throws ServletException {
		this.context = fConfig.getServletContext();
		this.context.log("AuthenticationFilter initialized");
	}
	
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {

		HttpServletRequest req = (HttpServletRequest) request;
		HttpServletResponse res = (HttpServletResponse) response;
		
		String uri = req.getRequestURI();
		this.context.log("Requested Resource::"+uri);
		
		HttpSession session = req.getSession(false);
		
		if(session == null && !(uri.endsWith("html") || uri.endsWith("LoginServlet"))){
			this.context.log("Unauthorized access request");
			res.sendRedirect("login.html");
		}else{
			// pass the request along the filter chain
			chain.doFilter(request, response);
		}
	}

	public void destroy() {
		//close any resources here
	}
}
```
## Sesja
Sesja jest implementowana przez kontener servletów. Referencje do obiektu sesji można pobrać z obiektu zgłoszenia (`HttpServletRequest`).

W interfejsie `HttpServletRequest` jest definicja metody `getSession`. Metoda zwraca obiekt implementujący interfejs `javax.servlet.http.HttpSession`.

Mechanizm kontenerów powinien implementować odpowiedni mechanizm sesji (który będzie implementował interfejs `javax.servlet.http.HttpSession`)

W przypadku Tomcata sesja jest implementowana przez `org.apache.catalina.session.StandardSessionFacade`. W zasadzie ta klasa deleguje wszystkie metody do `org.apache.catalina.session.StandardSession` (tak mi się wydaje)
## Plik web.xml
Plik `web.xml` nazywany jest deskryptorem wdrożenia. W starszych wersjach specyfikacji serwletów tylko przy jego pomocy można było konfigurować aplikacje webowe.

Aktualnie plik `web.xml` nie jest wymagany, praktycznie wszystkie elementy można skonfigurować przy pomocy adnotacji. Jednak nadal zdarzają się aplikacje gdzie taki plik jest wykorzystywany. W związku z tym dobrze jest wiedzieć o jego istnieniu.

Plik `web.xml` powinien znajdować się bezpośrednio w katalogu WEB-INF wewnątrz pliku war.

Plik `web.xml` informuje kontener serwletów o wersji specyfikacji serwletów. Dla każdej wersji specyfikacji plik ten różni się nagłówkiem. Dla wersji 3.1 szablon pliku wygląda następująco

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <!-- tutaj są znaczniki do konfiguracji -->
</web-app>
```

Jak widzisz w głównym węzłem deskryptora wdrożenia jest `<web-app>`. Wewnątrz tego znacznika znajduje się właściwe elementy konfigurujące aplikację webową.
### Servlety
Podstawowa konfiguracja serwletu sprowadza się do nadania mu nazwy i podpięcia go pod odpowiedni adres URL. Zobacz jak taki efekt można osiągnąć przy pomocy znaczników XML i adnotacji. 

```xml
<servlet>
    <servlet-name>my-servlet</servlet-name>
    <servlet-class>
        	pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredServlet
    </servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>my-servlet</servlet-name>
    <url-pattern>/servlet-url-xml</url-pattern>
</servlet-mapping>
```

Powyższy fragment xml zawiera kilka znaczników. Pierwszy z nich `<servlet>` informuje kontener serwletów o tym, ze w klasie `pl.samouczekprogram ... .XMLConfiguredServlet` znajduje się serwlet. Nadałem mu nazwę `my-servlet`. Następnie wewnątrz ` <servlet-mapping> `, posługując się wcześniej nadaną nazwą podpinam serwlet pod adres URL `/servlet-url-xml`. 

Ten sam efekt można osiągnąć za pomocą adnotacji:

```java
@WebServlet(name = "my-servlet", urlPatterns = "/servlet-url-annotations")
public class AnnotationConfiguredServlet extends HttpServlet
```
### Filtry
Aby skonfigurować podstawowy filtr należy nadać mu nazwę i podpiąć go pod serwlet czy adres URL. Poniżej możesz porównać oba sposoby konfiguracji. 

```xml
<filter>
    <filter-name>my-filter</filter-name>
    <filter-class>
        pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredFilter
    </filter-class>
</filter>
 
<filter-mapping>
    <filter-name>my-filter</filter-name>
    <url-pattern>/servlet-url-xml</url-pattern>
</filter-mapping>
 
<filter-mapping>
    <filter-name>my-filter</filter-name>
    <servlet-name>my-servlet</servlet-name>
</filter-mapping>
```

Za pomocą adnotacji:

```java
@WebFilter(
    filterName = "my-filter", 
    servletNames = "my-servlet", 
    urlPatterns = "/servlet-url-annotations"
)
public class AnnotationConfiguredFilter implements Filter
```
### Konfiguracja obiektu nasłuchującego
W tym przypadku sprawa jest prosta. Cała konfiguracja sprowadza się do poinformowania kontenera serwletów o istnieniu takiego obiektu.

```xml
<listener>
    <listener-class>
        pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredListener
    </listener-class>
</listener>
```

Za pomocą adnotacji:

```java
@WebListener
public class AnnotationConfiguredListener implements ServletRequestListener
```
### Dodatkowe informacje
**Kiedy plik `web.xml` jest niezbędny**

Są sytuacje w których plik web.xml jest niezbędny. W przypadku kiedy istotna jest kolejność wykonania filtrów, obiektów nasłuchujących czy przypisania serwletów do adresów URL plik web.xml jest niezbędny. Specyfikacja serwletów jasno mówi o tym, że bez tego pliku kolejność wywołania tych elementów nie jest jasno określona.

**Modułowość konfiguracji**

Konfigurację podobną do tej z pliku `web.xml` można zawrzeć w plikach `web-fragment.xml`. Taki plik może znajdować się w każdym pliku jar, który znajduje się wewnątrz pliku war (ponownie odsyłam do [artykułu opisującego strukturę aplikacji webowej](https://www.samouczekprogramisty.pl/serwlety-w-aplikacjach-webowych/)). Konkretnie w katalogu `META-INF` wewnątrz pliku jar.

Wewnątrz pliku `web-fragment.xml` możemy użyć tych samych znaczników jak pliku `web.xml`. Różnicą jest tutaj znacznik główny. W tym przypadku jest to `` a nie ``.

**Ostatnie słowo ma `web.xml`**

Chociaż dla niektórych osób adnotacje czy pliki `web-fragment.xml` mogą być preferowanym wyborem to `web.xml` ma ostatnie słowo. Mam tu na myśli atrybut `metadata-complete`. Atrybut ten można ustawić na znaczniku ` <web-app> `. Jeśli przyjmie on wartość `true`, wówczas adnotacje i pliki `web-fragment.xml` będą ignorowane. W takim przypadku cała konfiguracja aplikacji webowej musi znajdować się w pliku `web.xml`.

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1"
         metadata-complete=”true”>
 
    <!-- tutaj są znaczniki do konfiguracji -->
 
</web-app>
```

# Grafika

Graphics is mechanism to manipulate the image. We can add some text or lines, shapes etc.
## Image
There are a number of common tasks when working with images.

- Loading an external GIF, PNG JPEG image format file into the internal image representation used by Java 2D.
- Directly creating a Java 2D image and rendering to it.
- Drawing the contents of a Java 2D image on to a drawing surface.
- Saving the contents of a Java 2D image to an external GIF, PNG, or JPEG image file.

The are two main classes that work with images:

- The `java.awt.Image` class is the superclass that represents graphical images as rectangular arrays of pixels.
- The `java.awt.image.BufferedImage` class, which extends the `Image` class to allow the application to operate directly with image data (for example, retrieving or setting up the pixel color). Applications can directly construct instances of this class.

The `BufferedImage` class is a cornerstone of the Java 2D immediate-mode imaging API. It manages the image in memory and provides methods for storing, interpreting, and obtaining pixel data. Since `BufferedImage` is a subclass of `Image` it can be rendered by the `Graphics` and `Graphics2D` methods that accept an `Image` parameter.

A `BufferedImage` is essentially an `Image` with an accessible data buffer. It is therefore more efficient to work directly with `BufferedImage`. A `BufferedImage` has a *ColorModel* and a *Raster* of image data. The ColorModel provides a color interpretation of the image's pixel data.
### IO
To load an image from a specific file use the following code:

```java
BufferedImage img = null;
try {
    img = ImageIO.read(new File("strawberry.jpg"));
} catch (IOException e) {
}
```

Image I/O recognises the contents of the file as a JPEG format image, and decodes it into a `BufferedImage` which can be directly used by Java 2D.

If the code is running in an applet, then its just as easy to obtain the image from the applet codebase:

```java
try {
    URL url = new URL(getCodeBase(), "examples/strawberry.jpg");
    img = ImageIO.read(url);
} catch (IOException e) {
}
```

The `getCodeBase` method used in this example returns the URL of the directory containing this applet when the applet is deployed on a web server. If the applet is deployed locally, `getCodeBase` returns null and the applet will not run.

Then we can display image in JPanel for example.

```java
private static class ImagePanel extends JPanel {
    private final Image image;

    public ImagePanel(Image image) {
        this.image = image;

        setPreferredSize(new Dimension(image.getWidth(null), image.getHeight(null)));
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);

        g.drawImage(image, 0, 0, null);
    }
}
```
### Adding text
```java
BufferedImage image = ImageIO.read(AddingText.class.getResourceAsStream("/dog.jpg"));

Font font = new Font("Arial", Font.BOLD, 18);

Graphics g = image.getGraphics();

g.setFont(font);
g.setColor(Color.GREEN);
g.drawString("Test", 0, 20);

Display.display(image);

```
### Centered Text
```java
Graphics g = image.getGraphics();
 
FontMetrics metrics = g.getFontMetrics(font);
int positionX = (image.getWidth() - metrics.stringWidth(text)) / 2;
int positionY = (image.getHeight() - metrics.getHeight()) / 2 + metrics.getAscent();
 
g.drawString(attributedText.getIterator(), positionX, positionY);
```
### Positioning text
```java
// Bottom Right
int positionX = (image.getWidth() - metrics.stringWidth(text));
int positionY = (image.getHeight() - metrics.getHeight()) + metrics.getAscent();

// Top Left
int positionX = 0;
int positionY = metrics.getAscent();

```
### Adapting Text Size Based on Image
When we draw the text in the image, we might find that this text exceeds the size of the image. To solve this, we have to **adapt the size of the font** that we're using based on the image size.

First, we need to obtain the expected width and height of the text using the base font. In order to achieve this, we'll make use of the classes [*FontMetrics*](https://docs.oracle.com/javase/8/docs/api/java/awt/FontMetrics.html), *[GlyphVector](https://docs.oracle.com/javase/8/docs/api/java/awt/font/GlyphVector.html),* and [*Shape*](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html).

```java
FontMetrics ruler = graphics.getFontMetrics(baseFont);
GlyphVector vector = baseFont.createGlyphVector(ruler.getFontRenderContext(), text);
    
Shape outline = vector.getOutline(0, 0);
    
double expectedWidth = outline.getBounds().getWidth();
double expectedHeight = outline.getBounds().getHeight();
```

The next step is to check if the resize of the font is necessary. For this purpose, let's compare the expected size of the text and the size of the image:

```java
boolean textFits = image.getWidth() >= expectedWidth && image.getHeight() >= expectedHeight;
```

Finally, if our text doesn't fit in the image, we have to reduce the font size. We'll use the method *deriveFont* for that:

```java
double widthBasedFontSize = (baseFont.getSize2D()*image.getWidth())/expectedWidth;
double heightBasedFontSize = (baseFont.getSize2D()*image.getHeight())/expectedHeight;
 
double newFontSize = widthBasedFontSize < heightBasedFontSize ? widthBasedFontSize : heightBasedFontSize;
newFont = baseFont.deriveFont(baseFont.getStyle(), (float)newFontSize);
```

Note that we need to obtain the new font size based on both width and height and apply the lowest of them.
## Pozostałe
### ImageJ
ImageJ is a public domain Java image processing program inspired by [NIH Image](https://rsb.info.nih.gov/nih-image/) for the Macintosh. It runs, either as an online applet or as a downloadable application, on any computer with a Java 1.4 or later virtual machine. Downloadable distributions are [available](https://rsb.info.nih.gov/ij/download.html) for Windows, Mac OS, Mac OS X and Linux.

It can display, edit, analyze, process, save and print 8-bit, 16-bit and 32-bit images. It can read many image formats including TIFF, GIF, JPEG, BMP, DICOM, FITS and "raw". It supports "stacks", a series of images that share a single window. It is multithreaded, so time-consuming operations such as image file reading can be performed in parallel with other operations.

It can calculate area and pixel value statistics of user-defined selections. It can measure distances and angles. It can create density histograms and line profile plots. It supports standard image processing functions such as contrast manipulation, sharpening, smoothing, edge detection and median filtering.

It does geometric transformations such as scaling, rotation and flips. Image can be zoomed up to 32:1 and down to 1:32. All analysis and processing functions are available at any magnification factor. The program supports any number of windows (images) simultaneously, limited only by available memory.

https://imagej.nih.gov/ij/docs/intro.html

# Bezpieczeństwo
https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html

Platforma Java zdecydowanie kładzie nacisk na bezpieczeństwo, w tym bezpieczeństwo języka, kryptografię, infrastrukturę klucza publicznego, uwierzytelnianie, bezpieczną komunikację i kontrolę dostępu. 
## JCA
Jest to skrót Java Cryptography Architecture - jest ważnym elementem platformy i zawiera architekturę „dostawcy” oraz zestaw interfejsów API do: 

- podpisów cyfrowych, 
- skrótów wiadomości (skrótów), 
- certyfikatów,
- sprawdzania poprawności certyfikatów, 
- szyfrowania (symetryczne / asymetryczne szyfry blokowe / strumieniowe), 
- generowania kluczy,
- zarządzanie nimi,
- bezpieczne generowanie liczb losowych. 

Te interfejsy API pozwalają programistom łatwo zintegrować zabezpieczenia z kodem aplikacji.

Jednymi z podstawowych założeń JCA jest: niezaleźność od platformy, niezależność od konkretnych implementacji, rozszerzalność.
## CSP
Jest to skrót od Cryptographic Service Provider - jest to obiekt dostarczający poszczególne implementacje związane kryptografią.

Klasa java.security.Provider jest podstawową klasą która zawiera wszystkie definicję obiektów kryptograficznych. 

W kodzie mamy nastepujące mechanizmy: AlgorithmParameterGenerator, AlgorithmParameters, KeyFactory, KeyPairGenerator, KeyStore, MessageDigest, SecureRandom, Signature, CertificateFactory, CertPathBuilder, CertPathValidator, CertStore, Cipher, ExemptionMechanism, Mac, KeyAgreement, KeyGenerator, SecretKeyFactory, KeyManagerFactory, SSLContext, TrustManagerFactory, GssApiMechanism, SaslClientFactory, SaslServerFactory, Policy, Configuration, XMLSignatureFactory, KeyInfoFactory, TransformService, TerminalFactory.

Implementację możemy popbrać przez odwołanie się przez typ obiektu i nazwę implementacji:

```java
    md = MessageDigest.getInstance("SHA-256");
    md = MessageDigest.getInstance("SHA-256", "ProviderC");
```

Dostarczona konfiguracja zależy od konfiguracji dostawców. `ProviderC` - jest to nazwa dostawcy.

![diagram showing an application requesting an SHA-256 algorithem from a specific provider](../../../.files/jssec_dt_012.png)

JDK może dostarczać wielu różnych dostawców: Sun, SunJSSE, SunJCE, SunRsaSign.

Listę wspieranych dostawców oraz dostarczanych metchanizmów/algorytmów można wyświetlić w taki sposób:

```java
import java.security.*;

for (Provider provider: Security.getProviders()) {
  System.out.println(provider.getName());
  for (String key: provider.stringPropertyNames())
    System.out.println("\t" + key + "\t" + provider.getProperty(key));
}
```

```
SUN
	Alg.Alias.Signature.SHA1/DSA	SHA1withDSA
	Alg.Alias.Signature.1.2.840.10040.4.3	SHA1withDSA
	Alg.Alias.Signature.DSS	SHA1withDSA
	SecureRandom.SHA1PRNG ImplementedIn	Software
	KeyStore.JKS	sun.security.provider.JavaKeyStore$DualFormatJKS
	Alg.Alias.MessageDigest.SHA-1	SHA
	MessageDigest.SHA	sun.security.provider.SHA
	KeyStore.CaseExactJKS	sun.security.provider.JavaKeyStore$CaseExactJKS
	CertStore.com.sun.security.IndexedCollection ImplementedIn	Software
	Signature.SHA256withDSA	sun.security.provider.DSA$SHA256withDSA
```
## Signature
...
## Keys
Java wyróżnia kilka kontraktów wykorzystywanych w kontekście operacji na kluczach.

| Interfejs/Klasa | Opis                                                         |
| --------------- | ------------------------------------------------------------ |
| `Key`           | Generyczny interfejs reprezentujący klucz. Istnieje kilka mechanizm które pozwalają na pozyskanie klucza: `KeyGenerator, KeyPairGenerator,KeyFactory, KeyStore`,  lub certyfikaty. |
| `KeyPair`       | Reprezentuje parę klucza publicznego i prywatnego.           |
| `PublicKey`     | Klucz publiczny                                              |
| `PrivateKey`    | Klucz prywatny                                               |
| `KeySpec`       | Jest to specyfikacja w której zapisany jest klucz. Interfejs `Key` zawiera odkodowany klucz. Klucze mogą być zapisane w różnych formatach `.pem, .der, .key...` z określonych formatów należy ten klucz wydobyć. |
## Trustcacerts
Trust Certificate is keystore which contains PKI objects to use in different operations on cryptography. One of examples is checking SSL for requests. Generally file is encoded as keystore and is located at `$JAVA_HOME\jre\lib\security\cacerts`.

We can use keytool to add/remote or check certificates in storage.

```shell
keytool -importcert -trustcacerts -file idp-encryption.crt -alias usos-idp-encryption -keystore "$JAVA_HOME\jre\lib\security\cacerts"
keytool -importcert -trustcacerts -file idp-signing.crt -alias usos-idp-signing -keystore "$JAVA_HOME\jre\lib\security\cacerts"
keytool -importcert -trustcacerts -file rootCA.pem -alias usos-rootca -keystore "$JAVA_HOME\jre\lib\security\cacerts"
keytool -importcert -trustcacerts -file rootCA.pem -alias usos-rootca -keystore "$JAVA_HOME\jre\lib\security\cacerts"

keytool -list -trustcacerts -keystore "$JAVA_HOME\jre\lib\security\cacerts"

keytool -delete -alias usos-idp-encryption -keystore "$JAVA_HOME\jre\lib\security\cacerts" -storepass changeit
keytool -delete -alias usos-idp-signing -keystore "$JAVA_HOME\jre\lib\security\cacerts" -storepass changeit
keytool -delete -alias usos-rootCA -keystore "$JAVA_HOME\jre\lib\security\cacerts" -storepass changeit
```
## Pozostałe
### DSA
Asymetryczny algorytm stworzony przez NIST w 1991 roku dla potrzeb DSS. Został opatentowany przez NIST, można go jednak używać za darmo, także w zastosowaniach komercyjnych.

# Aspekty

## AspectJ
AspectJ to pierwszy język AOP ogólnego przeznaczenia, który stał się na tyle dobry, że zyskał znaczenie w kontekście budowy aplikacji biznesowych. Oryginalnie został stworzony przez firmę PARC (Xerox PARC), specjalizującą się w R&D. Aby zachęcić do rozwoju technologii AspectJ, w grudniu 2002 PARC przekazało AspectJ do zdobywającego coraz większą popularność, otwartego projektu **eclipse.org**. 

Na początku AspectJ bazował na regularnych klasach, nie był budowany w oparciu o adnotacje. Zmieniło się to dopiero razem z wydaniem wersji AspectJ 5, gdzie po raz pierwszy został wprowadzony styl @AspectJ.

https://www.baeldung.com/aspectj

https://www.baeldung.com/java-jcabi-aspects
# JMH - Microbenchmarking
Jest to komponent Javy dostarczający mechanizmy do mierzenia czasu wykonania kodu. W JVM trzeba pamiętać, że naiwne podejście polegające na zmierzeniu czasu nie zadziała, dzieje się tak dlatego, że wirtualna maszyna wykonuje szereg różnych optymalizacji. Dobrze to opisują artykuły **Avoiding Benchmarking Pitfalls on the JVM** oraz **Microbenchmarking with Java**.

JMH wprowadza takie pojęcia jak Fork, Warmup, Iteracje. 

**Fork** nazywane też trial jest to osobny proces JVM w którym wykonywany jest test. Dzieje, się tak, że pomiędzy poszczególnymi uruchomieniami testów mogą zachodzić różne działa JVM które mogą wpłynąć na test. Dlatego JMH uruchamia osobne procesu na każdego testu dzięki temu działanie JVM ma mniejszy wpływ na czas.

**Warmup** czyli rozgrzewanie JVMa w czasie którego uruchamiany jest test ale bez mierzenia czasu. Ma to na celu wywołanie wszystkich zabiegów które wykonuje JVM aby niebyły one wykonywane w trakcie testu i nie wpływały na jego czas. Czas trwania tego procesu jest zdefiniowany przez długość iteracji i jej liczę.

**Iteracje i czas** - JMH głównie bierze pod uwagę czas w jakim określony etap się wykonuje i liczba powtórzeń (iteracji). **Ważne, iteracja to nie jest jedno uruchomienie testu tylko ileś uruchomień testu w określonym czasie**

![Java microbenchmark harness Terminology](../../../.files/Java-microbenchmark-harness-Terminology.png)

**Measurements** - jest to okres pomiaru czasu wykonania testu. Podobnie jak w przypadku Warmup ustawiamy ile czasu ma trwać iteracja i ile jest iteracji. 

## Uruchomienie testu
```xml
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.28</version>
</dependency>
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.28</version>
</dependency>
```

Przykładowy test poniżej:

```java
@Benchmark
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@Fork(value = 1, warmups = 4)
@Warmup(iterations = 3, time = 1)
@Measurement(iterations = 5, time = 2)
public int testFactorialWithRecursiveMethodWithLongNumber() {
    return Factorial.getFactorialRec(LONG_NUMBER);
}
```

**@Benchmark** - wskazuje na metody, które będą poddane pomiarowi.
**@BenchmarkMode** -  tryb przeprowadzania testu, wyróżniamy następujące tryby:

- Throughput – przepustowość – ile razy kod da radę wykonać się w ciągu sekundy,

- AverageTime – średni czas ze wszystkich prób, jaki był potrzebny na wykonanie kodu,
- Sample Time – statystyczne podejście do mierzenia czasu wykonania, wraz z podziałem na histogram oraz percentyle,
- Single Shot Time – ile czasu zajmie wykonanie benchmarku za pierwszym razem – bez rozgrzewki – Java warm-up,
- All – wszystkie powyższe tryby razem.

**@OutputTimeUnit** - jednostka czasu w jakiej zostaną zaprezentowane wyniki,
**@Fork** - liczba procesów w których uruchamiane są testy, warmups to liczba procesów rozgrzewkowych,
**@Warmup** -  liczba iteracji rozgrzewkowych, time – czas – domyślnie w sekundach,
**@Measurement** - liczba iteracji w podanym czasie time (domyślnie w sekundach) branych pod uwagę w czasie, wykonywania pomiaru.

## Stan testu
Test może posiadać stan w którym będziemy przechowywać informacje. Aby zainicjować stan musimy oznaczyć test adnotacją `@State`. Następnie możemy zdefiniować metodę inicjującą test za pomocą adnotacji `@Setup`.

```java
@State(Scope.Benchmark)
public class ListIterateBenchmarks extends BaseBenchmark {
    private List<Integer> numbers;

    @Setup(Level.Invocation)
    public void setUp() {
        int size = 10000;

        numbers = new ArrayList<>(size);

        for(int i=0; i < size; i++) {
            numbers.add(i);
        }
    }
    // ...
}
```

Stan może być przechowywany na poziomie testu (`Scope.Benchmark`) , wątku (`Scope.Thread	`) lub grupy testów (`Scope.Group`). Tak samo możemy inicjować metodę `setUp` w różnym momencie (`Trial, Iteration, Invocation`).

## Optymalizacje JVM
### Martwy kod
Należy uważać przy pisaniu testów ponieważ kompilator może dokonać optymalizacji kodu co spowoduje, że w rzeczywistości wykona się trochę inny kod niż ten które myślimy. Najprostszym przykładem optymalizacji martwego kodu. Weźmy takie przypadki testowe:

```java
@Benchmark
public void deadCode(){
    int a = 1;
    int b = 2;
    int sum = a + b;
}

@Benchmark
public void deadCode(){
    int a = 1;
    int b = 2;
    int sum = a + b;
    
    return sum;
}

@Benchmark
public void blackHoleConsume(Blackhole blackhole){
    int a = 1;
    int b = 2;
    int sum = a + b;
    blackhole.consume(sum);
}
```

Tego typu optymalizację możemy dezaktywować przez np. zwrócenie wyniku testu lub zastosowanie tgz. Blackhole. W obu przypadkach wskazujemy, że ta zmienna jest potrzebna i kompilator nie próbuje optymalizować przez usunięcie jej.

Wyniki

```
Benchmark                   Mode  Cnt           Score          Error  Units
DeadCode.blackHoleConsume  thrpt    5   435606566.030 ± 17237726.727  ops/s
DeadCode.deadCode          thrpt    5  3652411182.146 ± 88932266.478  ops/s
DeadCode.returnValue       thrpt    5   434312877.247 ± 20589656.127  ops/s
```

Wynik z pominięciem optymalizacji jest ponad 8 razy wolniejszy!

### Wyliczanie wartości stałych
Czyli optymalizacja po stronie **JVM** (**składanie stałych**) która polega na obliczaniu wyrażeń w czasie kompilacji – przykład kodu który w ten sposób jest optymalizowany to:

```java
public class BenchmarkConstantFolding {
	// ...
    public int testConstantFolding() {
        int a = 1;
        int b = 2;
        int sum = a + b;
        return sum;
    }
}
```

W przypadku metody `testConstantFolding` kompilator może uznać, że wynik jest zawsze stały i równy 3 więc nie ma sensu obliczać tej wartości za każdym razem i kompilator w ramach optymalizacji wszystkie wywołania tej metody może zastąpić wartością 3.

Aby dezaktywować tą optymalizacji musimy wprowadzić zmienną z zewnątrz która może wpłynąć na wynik.

```java
public class BenchmarkConstantFolding {
	// ...
    public int testConstantFolding(Params params) {
        int a = params.a; 
        int b = params.b;
        int sum = a + b;
        return sum;
    }
}
```

Wynik testu:

```
Benchmark                                     Mode  Cnt  Score   Error  Units
BenchmarkConstantFolding.testConstantFolding  avgt       0,010          us/op

Bez optymalizacji
BenchmarkConstantFolding.testConstantFolding  avgt       0,019          us/op
```

### Optymalizacja pętli
```java
@Param({"10", "10000", "10000000"})
private int n;
@Benchmark
public int loop() {
    int sum = 0;
    for (int i = 0; i < n; i++) {
    	sum++;
    }
    return sum;
}
```

Mimo znaczącej różnicy w ilości iteracji pętli łączny czas na wykonanie całej pętli jest praktycznie taki sam. Żeby uchronić się przed tego typu optymalizacjami, najlepiej zrezygnować z wykorzystania pętli w benchmarku i testom poddać tylko logikę z ciała pętli.

```
Benchmark                (n)   Mode  Cnt          Score          Error  Units
LoopBenchmark.loop        10  thrpt    5  365791813.120 ± 28541569.462  ops/s
LoopBenchmark.loop     10000  thrpt    5  374484447.982 ± 13230154.673  ops/s
LoopBenchmark.loop  10000000  thrpt    5  363040228.406 ± 38938864.195  ops/s
```

Inny przypadek optymalizacji pętli.

```java
while(i<100) {
 a = Sin(x)/Cos(x) + i;
 i++;
}

// PO

t = Sin(x)/Cos(x);
while(i<100) {
 a = t + i;
 i++;
}
```

Jeszcze inny przykład pętli:

```java
int doSomeCalculations(int x) {
      return 2*x;
}

@Benchmark
public int deadCodeEliminationBenchmarkExample() {
      int result;
      for(int x = 0; x < 100; ++x) {
            result = doSomeCalculations(x);
      }
      return result;
}
```

W powyższym przykładzie kompilator może dojść do wniosku, że nie ma sensu wykonywanie wszystkich iteracji jak tylko liczy sie ostatnia. Więc kod może zostać zoptymalizowany w ten sposób, że zostanie wykonana tylko ostatnia iteracja.

Tą optymalizację można wyłączyć np. w taki sposób:

```java
@Benchmark
public int noDeadCodeEliminationBenchmarkExample(Blackhole hole) {
      int result;
      for(int x = 0; x < 100; ++x) {
            result = doSomeCalculations(x);
            hole.consume(result);
      }
      return result;
}
```

Dodajemy `hole.consume(result);` symulując, że potrzebujemy wyniku w każdej iteracji.

## Adnotacje
### `@Measurement`
Adnotacja pozwala na ustawienie procesu pomiaru. 

To są iteracje, które naprawdę mają znaczenie w ostatecznych wynikach. Ich ilość jest liczona i sumowana po wszystkich biegach.
Konfiguracja parametrów jest taka sama jak dla iteracji rozgrzewania, z wyjątkiem tego, że używamy tutaj adnotacji `@Measurement`. Ta adnotacja ma zastosowanie do metod i klas.

```java
@Measurement(iterations = 5)
```

### `@Setup, @TearDown`
Mamy możliwość wykorzystania dwóch dodatkowych mechanizmów:

- **Setup** (wykonywane przed przekazaniem parametrów do danego benchmarku), domyślnie **Level.Trial** czyli raz na wszystkie iteracje testowe oraz rozgrzewające.
- **TearDown** (po przekazaniu obiektu do benchmarku).

```java
@State(Scope.Group)
public class Params {
 	// ... 
    @Setup
    public synchronized void setup() {
        System.out.println("run setup " + threadsId);
    }
 
    @TearDown
    public synchronized void tearDown() {
        System.out.println("run tearDown " + threadsId);
    }
    // ... 
}
```

Uruchomienie testu:

```java
public class BenchmarkRunner {
    public static void main(String[] args) throws Exception {
        org.openjdk.jmh.Main.main(args);
    }
}
```

### `@Threads`
Jest odpowiedzialna za ustawienie liczy wątków które jednocześnie zostaną uruchomione dla testu.

```java
@Threads(value = 4)
```

### `@Timeout`
Ustawia limit czasu dla każdej iteracji testu porównawczego (bez względu na to, czy rozgrzewka, czy pomiar) w określonej jednostce czasu.
Dostosowane przez adnotację:

```java
@Timeout(time = 10, timeUnit = TimeUnit.SECONDS)
```

### `@Warmup`
Pozwala na zdefiniowanie przebiegu procesu tgz. grzania maszyny wirtualnej. Są to iteracje, które są uruchamiane tylko po to, aby wywołać wszystkie standardowe procesy w JVM, tj. Optymalizacje JIT, znaczniki GC. Wyniki są ignorowane w ogólnej, końcowej punktacji. Ilość iteracji rozgrzewki lub czas dla każdego z nich.

```java
@Warmup(iterations = 20, time = 1, timeUnit = TimeUnit.SECONDS)
```

`iterations`– ustawia ilość iteracji rozgrzewania dla każdego benchmarku
`time` – określa, ile czasu zajmie każda iteracja rozgrzewkowa w określonym timeUnit
`timeUnit` – prawie każda możliwa jednostka od TimeUnit.NANOSECONDS do TimeUnit.DAYS (standard SI)

# JMS - Komunikacja przez komunikaty
Skrót od Java Message Service standardowy zestaw interfejsów i modeli asynchronicznego przesyłania komunikatów w języku programowania Java. Specyfikacja JMS jest darmowa i przygotowana przez firmę Sun. Istnieje kilka implementacji tego standardu takich jak:

- Amazon SQS,
- **Apache ActiveMQ**
- JBoss Messaging,
- IBM MQ,
- Oracle AQ,
- **RabbitMQ**.


# JNDI - Usługi katalogowe
Jest to skrót od Java Naming and Directory Interface jest interfejsem Javy usług katalogowych, który umożliwia klientom odkrywanie i wyszukiwanie danych oraz obiektów za pomocą nazw.

Interfejs JNDI jest wykorzystywany przez interfejsy Java RMI oraz Java EE w celu wyszukiwania obiektów w sieci. JINI posiada swój własny serwis do wyszukiwania i nie korzysta z interfejsu JNDI.

Interfejs posiada:

- mechanizm łączący obiekt z nazwą
- interfejs wyszukiwania katalogowego, który pozwala stosować podstawowe zapytania
- interfejs zdarzeń, który pozwala klientowi na określenie wejść, które zostały zmienione
- rozszerzenie LDAP, które obsługuje dodatkowe możliwości protokołu LDAP

# JMX - Zarządzanie JVM 

Jest to API do JVM pozwalające do zarządzani maszyną wirtualna Javy lokalnie oraz zdalnie.

# JPA - Mapowanie obiektowo-relacyjne

Oficjalny standard mapowania obiektowo-relacyjnego firmy Sun Microsystems dla języka programowania Java. 
# JSR-303 - Standard walidacji
Specyfikacja Bean Validation ewoluuje. Wszystko zaczęło się od specyfikacji w wersji 1.0 wydanej w 2009 roku. Najnowsza wersja tej specyfikacji to 2.0. Jest ona częścią Java Enterprise Edition 8. Dodatkowo implementacji tej specyfikacji można używać w Java SE. Walidacja odbywa się w oparciu o reguły (ang. constraint), które stwierdzają, czy dany element jest poprawny.

Specyfikacja pozwala na przypisywanie reguł do poszczególnych elementów za pomocą adnotacji i XML1. 

W pierwszym kroku importujemy pakiet zawierająćy podstawową definicje API.

```xml
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
    <version>2.0.1.Final</version>
</dependency>
```

Jeśli chcemy aby komunikaty były interpelowane to musimy dodać.

```xml
<dependency>
    <groupId>javax.el</groupId>
    <artifactId>javax.el-api</artifactId>
    <version>3.0.0</version>
</dependency>
<dependency>
    <groupId>org.glassfish.web</groupId>
    <artifactId>el-impl</artifactId>
    <version>2.2</version>
</dependency>
```

Pierwsza zależność to  definicja Api EL (Expression Language) język wyrażęń oraz implementacja `el-impl` tej specyfikacji.

W ramach tej podstawowej specyfikacji mamy zdefniowane kilkanaście walidatorów. 

```
AssertFalse
AssertTrue
DecimalMax
DecimalMin
Digits
Email
Future
FutureOrPresent
Max
Min
Negative
NegativeOrZero
NotBlank
NotEmpty
NotNull
Null
Past
PastOrPresent
Pattern
Positive
PositiveOrZero
Size
```

Są to adnotację, które są następnie implementowane przez zewnęŧrzne biblioteki (Hibernate). Poniżej mam przykład komponentu z oznaczonymi walidacjami.

```java
@UserValidator
public class User {

    @NotNull
    @NotBlank
    private String firstName;

    @NotNull
    @NotBlank
    private String lastName;

    @NotNull
    @Min(value = 1, message = "Wiek powinien mieć minumum {min}")
    @Max(value = 100)
    private int age;

    private List<Contact> contacts = new Vector<>();
}
```

Poza tymi zdefniowanymi w API (`NotNull, NotBlank, Min, Max ...`) jest mój własny walidator `UserValidator`. Taki walidator definiujemy w taki sposób, że w pierwszym kroku tworzymy adnotację:

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value = {ElementType.TYPE})
@Constraint(validatedBy = {UserConstraint.class})
public @interface UserValidator {
    public Class<?>[] groups() default {};

    public String message() default "{validation.user.error}";

    public Class<? extends Payload>[] payload() default {};
}
```

W definicji adnotacji defniujemy walidatory/stałe przez pole `Constraint` i pole `validatedBy`. Te walidatory zostaną wywołane w momencie walidacji.

Sam walidator wygląda następująco:

```java
public class UserConstraint implements ConstraintValidator<UserValidator, User> {
    @Override
    public void initialize(UserValidator constraintAnnotation) {

    }

    @Override
    public boolean isValid(User user, ConstraintValidatorContext constraintValidatorContext) {
        return false;
    }
}
```

Użycie walidatora wygląda następująco:

```java
User user = new User();

Validator validator = Validation.byDefaultProvider()
    .configure()
    .buildValidatorFactory()
    .getValidator();

Set<ConstraintViolation<User>> result = validator.validate(user);

result.forEach(consumer -> {
    System.out.println(consumer.getMessage());
});
```

W wyniku walidacji zotaje zwrócony zbiór błędów jeśli takie wystąpią.
## Adnotacja @Valid
Walidacja uruchamiana jest kaskadowo.

```java
public class MembershipBonus {

    @Valid
    private PaidAccount userAccount;

    @NotEmpty
    private String bonusName;

    public MembershipBonus(@Valid PaidAccount userAccount, @NotEmpty String bonusName) {
        this.userAccount = userAccount;
        this.bonusName = bonusName;
    }

    public PaidAccount getUserAccount() {
        return userAccount;
    }

    public String getBonusName() {
        return bonusName;
    }
}
```

W przykładzie tym użyta jest adnotacja @Valid. Zwraca ona uwagę na to, że instancja klasy PaidAccount także musi być sprawdzona pod kątem poprawności. To czy PaidAccount jest poprawne czy nie określone jest przez adnotacje wewnątrz tej klasy.
## Adnotacja @Validated
Odnotacja @Valid pozwala na wymuszenie aby obiekt musi zostać zwalidowany. Możemy tej adnotacji użyć np. przy żądaniu.

```java
@RequestMapping(value = "/saveBasicInfo", method = RequestMethod.POST)
public String saveBasicInfo(@Valid @ModelAttribute("useraccount") UserAccount useraccount,   BindingResult result, 
  ModelMap model) {
    if (result.hasErrors()) {
        return "error";
    }
    return "success";
}
```

Działa to w ten sposób, że cały obiekt jest walidowany. Czasami są sytuację, że chcemy aby zwalidowana została pewna grupa pól/atrybutów np. gdyb mamy formularz krokowy. W takiej sytuacji możemy użyć adnotacji @Validated, która pozwala zdefniować która grupa reguł ma zostać uruchomiona.

```java
@RequestMapping(value = "/saveBasicInfoStep1", method = RequestMethod.POST)
public String saveBasicInfoStep1(
    @Validated(BasicInfo.class) 
    @ModelAttribute("useraccount") UserAccount useraccount, 
    BindingResult result, ModelMap model) {
    if (result.hasErrors()) {
        return "error";
    }
    return "success";
}
```
## Najczęściej używane reguły
- `@NotNull` – dany element nie może mieć wartości `null`,
- `@NotBlank` – dany element nie może mieć wartości `null` i musi zawierać co najmniej jeden znak (nie może to być spacja, tabulator etc.),
- `@NotEmpty` – dany element nie może mieć wartości `null` i musi zawierać co najmniej jeden znak,
- `@Min(X)` – dany element musi być liczbą i jego wartość musi być większa bądź równa `X`,
- `@Max(X)` – dany element musi być liczbą i jego wartość musi być mniejsza bądź równa `X`,
- `@Email` – dane element musi zawierać poprawny adres e-mail,
- `@Pattern(regexp=X)` – dany element musi pasować do [wyrażenia regularnego](https://www.samouczekprogramisty.pl/wyrazenia-regularne-w-jezyku-java/) `X`.
- `@Size(min=X, max=Y)` – dany element musi mieć rozmiar określony przez elementy adnotacji `min` i `max`. Obie wartości są opcjonalne.

# JNI
**Native Interface** (**JNI**) - macierzysty interfejs programistyczny dla języka Java, który umożliwia uruchamianie koduw Javie wewnątrz wirtualnej maszyny Javy, we współpracy z aplikacjami i bibliotekami napisanymi w innych językach programowania, jak C, C++ czy asembler.
## Dyrektywa `native`
`native` słowo kluczowe jest stosowane do metody w celu wskazania, że metoda jest zaimplementowana w kodzie natywnym przy użyciu JNI.

```java
// Main.java
public class Main {
    public native int square(int i);
    public static void main(String[] args) {
        System.loadLibrary("Main");
        System.out.println(new Main().square(2));
    }
}
```

```java
// Main.c
#include <jni.h>
#include "Main.h"// Generowny przez javah

JNIEXPORT jint JNICALL Java_Main_square(
    JNIEnv *env, jobject obj, jint i) {
  return i * i;
}
```

Compile and run:

```java
sudo apt-get install build-essential openjdk-7-jdk
export JAVA_HOME='/usr/lib/jvm/java-7-openjdk-amd64'
javac Main.java
javah -jni Main
gcc -shared -fpic -o libMain.so -I${JAVA_HOME}/include \
  -I${JAVA_HOME}/include/linux Main.c
java -Djava.library.path=. Main
```

Output:

```java
4
```
## Wywołania wewnętrzne
Po angielsku sa one określane jako "intrinsic". Jest to typ wywołania, który w trakcie kompilacji może zostać podmieniona przez kompilator na lepszą konstrukcję. Jeśli kompilator uzna, że to nie ma sensu użyje standardowej implementacji.

W przypadku funkcji natywnych (JNI) kompilator nie wie co jest w środku i nie może jej zoptymalizować.

> The main difference is that a JVM **knows** the implementation of an intrinsic method and can substitute the original java-code with machine-dependent well-optimized instructions (sometimes even with a single processor instruction), whereas the implementation of a JNI method is **unknown** to a JVM.

Poniżej jest przykład pętli:

```java
AtomicInteger i = new AtomicInteger();
        int total = 0;
        for(int x=0;x<300;x++) {
            total = i.incrementAndGet();
        }
        System.out.println("Total Value - " + total);
```

Która po kompilacji wygląda następująco:

```
  0x00000000031fa22f: and     esi,1ff8h
  0x00000000031fa235: cmp     esi,0h
  0x00000000031fa238: je      31fa256h          ;*getstatic unsafe
                                                ; - java.util.concurrent.atomic.AtomicInteger::incrementAndGet@0 (line 186)

  0x00000000031fa23e: mov     eax,1h
  0x00000000031fa243: lock xadd dword ptr [rdx+0ch],eax
  0x00000000031fa248: inc     eax
  0x00000000031fa24a: add     rsp,40h
```

Zwróć uwagę, że wywołanie `incrementAndGet` zostało zoptymalizowane do jednego polecenia procesora, a nie wywołania funkcji.

```
lock xadd dword ptr [rdx+0ch],eax
```

# JIT - Obsługa transakcji

Jest to skrót od Java Transaction API. Jest to zbiór definicji (tak jak JPA) opisujących mechanizmy tranzakcji w Javie.

JTA definiuje dwa pakiety:

- javax.transaction,
- javax.transaction.xa.

Tranzakce mogą być obsługiwane na róznych poziomacha, można wyróżnić:

**Transakcje lokalne**. Serwer aplikacji umożliwia wykonywania operacji w sposób transakcyjny na pojedynczym zasobie, np. na bazie danych. Przy czym zarządzanie transakcjami realizuje programista korzystając z właściwości konkretnego zasobu, np. transakcje w obrębie pojedynczej bazy danych realizujemy z poziomu API zdefiniowanego przez specyfikację JDBC. Rola serwera aplikacji ogranicza się tutaj jedynie do udostępnienia zasobów, na których operuje aplikacja, np. źródła danych do bazy danych (`javax.sql.DataSource`).

**Transakcje zarządzane przez programistę** z wykorzystaniem interfejsów zdefiniowanych przez specyfikację **JTA**. Są to takie transakcje, w których programista pisząc kod, jawnie określa początek i koniec transakcji korzystając z JTA. Musi również umieć obsłużyć szereg sytuacji brzegowych, czy wyjątkowych związanych z korzystaniem z tych interfejsów.

**Transakcje zarządzane przez kontener, tzw. deklaratywne**. W tym przypadku programista tworzy komponenty EJB i w deskryptorze komponentów określa jakie ma być zachowanie transakcyjne poszczególnych metod. Całością obsługi transakcji zajmuje się serwer aplikacji, a ściślej kontener komponentów EJB we współpracy z menedżerem transakcji.

Środowisko transakcyjne dla aplikacji JEE jest określone przez dwie specyfikacje:

- **Java Transaction API (JTA)** - definiuje ona sposób zarządzania transakcjami z punktu widzenia programisty. Określa również sposób współpracy z zasobami uczestniczącymi w transakcji rozproszonej (jest to odwzorowanie fragmentu standardu X/Open DTP - XA Interface).
- **Java Transaction Service (JTS)** - określa sposób implementacji menedżera transakcji (w szczególności wspierającego JTA), aczkolwiek specyfikacja JEE nie wymaga, żeby JTA było koniecznie implementowane w postaci JTS. Na rynku istnieje sporo implementacji JTA nie korzystających z JTS. JTS jest wymagane, jeśli myślimy o współpracy menedżerów transakcji w środowisku rozproszonym (transakcja rozproszona pomiędzy kilkoma serwerami aplikacji różnych dostawców). JTS jest tak naprawdę mapowaniem CORBA Object Transaction Service na język Java.

Najłatwiej zrozumieć związek pomiędzy tymi specyfikacjami przez analogię. JTA ma się mniej więcej tak do JTS jak specyfikacja JDBC do sterownika do bazy danych. Z punktu widzenia programisty praktyczne znaczenie ma JTA

Przyjrzyjmy się teraz interfejsom jakie w serwerze aplikacji używane są do współpracy poszczególnych elementów uczestniczących w przetwarzaniu transakcji.

![Uczestnicy transakcji rozproszonych w środowisku serwera aplikacji JEE](../../../.files/JeP_007_2010_03_Transakcje_006.png)

Dla aplikacji pracującej w serwerze aplikacji, która chce zarządzać transakcją został przygotowany interfejs `javax.transaction.UserTransaction`. Wywołania tego interfejsu serwer aplikacji deleguje do interfejsu `javax.transaction.TransacationManager`, który stanowi reprezentację menedżera transakcji w serwerze aplikacji (implementacja tego interfejsu stanowi serce menedżera transakcji).

Artykułem tym rozpoczynam cykl związany z szeroko pojętą tematyką budowy systemów transakcyjnych w środowisku Java Enterprise. Temu podstawowemu zagadnieniu związanemu bezpośrednio z tworzeniem solidnych systemów informatycznych poświęcono do tej pory niewiele książek i artykułów, a zdobycie praktycznej wiedzy w tym zakresie jest stosunkowo trudne. Z tego powodu w ramach cyklu w kolejnych artykułach postaram się w sposób systematyczny przedstawić następujące zagadnienia:

- Podstawowe pojęcia i mechanizmy związane z budową systemów transakcyjnych.
- Sposób obsługi transakcji w serwerze aplikacji.
- Korzystanie z baz danych i systemów kolejkowania a transakcje w serwerze aplikacji.
- Transakcje w komponentach EJB.
- Strategie obsługi transakcji w aplikacjach JEE.
- Problemy i ograniczenia związane z budową transakcyjnych aplikacji w technologii JEE.

Szczególną uwagę będę starał się poświęcić rzeczywistym problemom na jakie możemy się natknąć tworząc systemy transakcyjne i praktycznym rozwiązaniom, które możemy zastosować w codziennej pracy.

**Wprowadzenie**

------

Zastosowanie systemów transakcyjnych w aplikacjach bankowych, e-commerce, czy innych, w których w grę wchodzą pieniądze w zasadzie nie podlegają dyskusji. Ale można się zastanawiać, czy warto do prostszych systemów internetowych, systemów zarządzania treścią czy np. aplikacji forum internetowego dokładać jeszcze dodatkowy aspekt w postaci transakcji. Według mnie warto, co najmniej z jednego powodu. Dzięki transakcjom możemy zachować spójność danych w systemie. Nie ma nic gorszego niż próba naprawy niespójności danych. Dodajmy, że próba bez gwarancji sukcesu. Jednym słowem używając transakcji gwarantujemy sobie pewien poziom spokoju.

Rozważania na temat transakcji zacznę od przypomnienia kilku podstawowych definicji.

**Transakcja** - zestaw operacji na danych, który traktujemy jaką jedną całość i który cechuje się następującymi właściwościami:

- Jest niepodzielny (*atomicity*), czyli albo wszystkie operacje w ramach transakcji zostaną wykonane albo żadna.
- Zachowuje spójność danych (*consistency*). To znaczy, że jeśli na dane obrabiane przez system nałożone są pewne warunki logiczne, to warunki te muszą być spełnione zarówno przed jak i po wykonaniu transakcji. Należy zwrócić uwagę, że nie ma wymagania, aby w trakcie trwania transakcji dane były spójne!
- Jest izolowany (*isolation*). Jeśli w jednym systemie wiele transakcji wykonywane jest współbieżnie to z punktu widzenia pojedynczej transakcji powinno to wyglądać tak, jakby wszystkie transakcje były wykonywane po kolei. Mówimy wtedy, że transakcje wykonywane są we wzajemnej izolacji. Ta właściwość, szczególnie w odniesieniu do baz danych przysparza sporo problemów. Jest to spowodowane potrzebą zwiększenia wydajności kosztem niepełnej izolacji transakcji. Temat ten postaram się szczegółowo omówić w części związanej z bazami danych.
- Jest trwały (*durability*). Zmiana danych, których dokonała transakcja muszą być trwałe, nawet w przypadku awarii systemu tuż po zakończeniu transakcji.

Wymienione wyżej właściwości określane są skrótem **ACID** pochodzącym od pierwszych liter ich angielskich nazw. A samą transakcję zazwyczaj określa się jako *transaction*, ale często również używa terminu *unit of work* (UOW).

**System transakcyjny** (*transactional system*) – system, w którym wszystkie operacje na danych grupowane są w transakcje.

**Zasób transakcyjny** (*transactional resource*) – system (podsystem), który umożliwia operowanie na danych w sposób transakcyjny (np. baza danych).

**Zakres transakcji** (*transaction scope*) – obszar działania programu od momentu rozpoczęcia transakcji do jej zatwierdzenia lub wycofania.

**Zatwierdzanie transakcji** (*transaction commit*) – operacja trwałego wprowadzenia zmian w danych, które zaszły od momentu rozpoczęcia transakcji.

**Wycofanie transakcji** (*transaction rollback*) – operacje wycofania wszystkich zmian w danych, które zaszły od momentu rozpoczęcia transakcji.

Typowym przykładem systemu transakcyjnego (a jednocześnie zasobu transakcyjnego) są systemy relacyjnych baz danych. Przez wiele lat systemy baz danych były w praktyce synonimem systemów transakcyjnych. Wymagania związane z budową złożonych systemów, w szczególności systemów, które muszą się integrować z innymi systemami zmieniły świat systemów transakcyjnych. Nie da się jednak zaprzeczyć, że bazy danych grają w nim jedną z głównych ról.

**Transakcje rozproszone**

------

Aby zagadnienie integracji systemów dokładniej zilustrować przyjrzyjmy się dość typowej konstrukcji współczesnego sklepu internetowego poglądowo przedstawionej na rysunku 1. System sklepu jest wyposażony we własną bazę danych, w której gromadzone są zarówno informacje o ofercie sklepu jak i o zamówieniach składanych przez klientów.

Ale to nie wszystko. Zamówione towary trzeba jakoś dostarczać. Obsługą tego procesu zajmuje się zazwyczaj odrębny system wspierających logistykę dostaw. Zamówienia trzeba również rozliczać, fakturować itd. Dochodzi więc system rozliczeń płatności, czy system finansowo księgowy. Oczywiście można to dalej komplikować przez dodawanie kolejnych systemów, takich jak obsługa płatności elektronicznych, system gospodarki magazynowej, systemy powiadomień o statusie zamówień (mail, sms) itd.

Oczywiście końcowego użytkownika nie interesuje to, ile systemów w rzeczywistości stoi za aplikacją sklepu internetowego. Składając zamówienie spodziewa się on, że dostanie towar i fakturę, czyli traktuje swoje działanie jako pojedynczą transakcję. To na aplikacji sklepu ciąży zadanie doprowadzenia do sytuacji, w której wszystkie systemy zagrają razem.

![Przykład sklepu internetowego w architekturze rozproszonej](../../../.files/JeP_007_2010_03_Transakcje_001.png)

Rysunek 1. Przykład sklepu internetowego w architekturze rozproszonej

Taki mniej więcej jest obraz współczesnych systemów informatycznych, które nam przychodzi w ostatnim czasie tworzyć, a w których występuje nieustająca potrzeba integracji różnych systemów.

Rodzi to z kolei innego rodzaju problem, mianowicie problem transakcji rozproszonej, czyli takiej w której pojedyncza aplikacja wykonuje operacje na różnych systemach, które nic o sobie nie wiedzą, jednocześnie zachowując wszystkie właściwości transakcji, o których wspominałem na początku (**ACID**).

Oczekiwany przebieg transakcji rozproszonej wygląda następująco:

- Rozpoczęcie transakcji.
- Użycie kilku zasobów transakcyjnych.
- Zatwierdzenie lub wycofanie transakcji, co powinno spowodować określone skutki we wszystkich zasobach uczestniczących w transakcji.

Implementacja pojedynczego systemu transakcyjnego, takiego jak na przykład relacyjna baza danych nie jest zadaniem trywialnym. W przypadku systemu, który musi wspierać transakcje rozproszone skala trudności znacząco rośnie. Podstawową trudnością jest rozwiązanie problemu komunikacji między systemami, które często były tworzone jako całkowicie niezależne produkty. Poradzono sobie z tym konstruując oprogramowanie menedżera transakcji i wymyślając dwufazowy protokół zatwierdzania transakcji, o którym teraz kilka słów.

**Dwufazowy protokół zatwierdzania transakcji**

------

Przyjrzyjmy się jak działa dwufazowy protokół zatwierdzania transakcji. Przykład na rysunku 2 pokazuje dwa niezależne systemy A i B, które muszą uczestniczyć w transakcji rozproszonej. Wprowadzony jest również menedżer transakcji, który w imieniu aplikacji korzystającej z systemów A i B zarządza transakcją. Po wykonaniu operacji na systemach A i B, aplikacja żąda od menedżera zatwierdzenia transakcji.

Implementacja pojedynczego systemu transakcyjnego,
takiego jak na przykład relacyjna baza danych
nie jest zadaniem trywialnym

![Infrastruktura systemu zarządzania transakcjami rozproszonymi](../../../.files/JeP_007_2010_03_Transakcje_002.png)

Rysunek 2. Infrastruktura systemu zarządzania transakcjami rozproszonymi

Menedżer transakcji w pierwszej fazie, którą określa się fazą przygotowania (*prepare*), pyta wszystkie systemy, czy są gotowe do zatwierdzenia swoich lokalnych zmian. Każdy system może udzielić jednej z dwóch odpowiedzi: tak lub nie. Jeśli choć jeden z systemów nie zgodzi się na zatwierdzenie transakcji menedżer transakcji w fazie drugiej do wszystkich systemów wysyła rozkaz wycofania transakcji (tą sytuację ilustruje rysunek 3). Jeśli wszystkie systemy odpowiedzą, że są gotowe do zatwierdzenia transakcji menedżer transakcji w fazie drugiej do wszystkich systemów wysyła rozkaz zatwierdzenia transakcji (tą sytuację ilustruje rysunek 4). Po zatwierdzeniu lub wycofaniu transakcji sterowanie wraca do aplikacji.

![Dwufazowy protokół zatwierdzenia transakcji – wycofanie transakcji](../../../.files/JeP_007_2010_03_Transakcje_003.png)

Rysunek 3. Dwufazowy protokół zatwierdzenia transakcji – wycofanie transakcji

![Dwufazowy protokół zatwierdzenia transakcji – zatwierdzenie transakcji](../../../.files/JeP_007_2010_03_Transakcje_004.png)

Rysunek 4. Dwufazowy protokół zatwierdzenia transakcji – zatwierdzenie transakcji

W rzeczywistych implementacjach, gdzie mamy do czynienia z systemami rozproszonymi w sensie logicznym lub fizycznym zachodzi szereg warunków brzegowych, z którymi zarówno systemy i menedżer transakcji musi sobie radzić. Przede wszystkim występuje szereg możliwości wystąpienia awarii:

- jednego z systemów,
- komunikacji między systemem a menedżerem transakcji,
- wreszcie samego menedżera transakcji.

System transakcyjny musi sobie z tymi problemami umieć radzić. Temat związany z odtwarzaniem systemów po awarii jest bardzo obszerny i nie mamy tutaj miejsca na jego choćby skromne omówienie. Warto według mnie zwrócić uwagę jedynie na to, że w większości przypadków przywrócenie systemu do działania po awarii może następować automatycznie. Jedynie część specyficznych awarii związanych z awarią samego menedżera transakcji uniemożliwia automatyczne odtworzenie i wymaga interwencji operatora.

Istotą dwufazowego protokołu zatwierdzania transakcji jest to, że jeżeli w pierwszej fazie system zgłosił gotowość do zatwierdzenia transakcji, to w drugiej fazie nie może się już z tej decyzji wycofać. Takie zachowanie musi gwarantować implementacja systemu uczestniczącego w transakcji rozproszonej. Jest to więc swoistego rodzaju kontrakt między menedżerem transakcji rozproszonej a systemem w niej uczestniczącym.

**Uczestnicy transakcji rozproszonej**

------

Architektura systemu, w którym realizowane są transakcje rozproszone składa się z trzech głównych elementów (patrz rysunek 5):

- Aplikacji, czyli tego co zazwyczaj piszemy jako deweloperzy systemów.
- Zasobów transakcyjnych, z których nasza aplikacja korzysta (np. baz danych).
- Menedżera transakcji, który zarządza transakcją rozproszoną w imieniu aplikacji (zwykle dostarczany przez serwer aplikacji).

![Uczestnicy transakcji rozproszonej](../../../.files/JeP_007_2010_03_Transakcje_005.png)

Rysunek 5. Uczestnicy transakcji rozproszonej

Każdy z tych elementów ma swoje specyficzne zadania do zrealizowania. Zacznijmy od zadań, które ciążą na aplikacji:

- Aplikacja (a więc my) przede wszystkim zarządza zakresem transakcji, czyli decyduje gdzie transakcja ma się zacząć, a gdzie zakończyć.
- Przeprowadza operacje na zasobach transakcyjnych, takich jak bazy danych, systemy kolejkowania czy transakcyjne systemy plików.

Przyjrzyjmy się teraz zadaniom menedżera transakcji:

- Menedżer transakcji przede wszystkim tworzy transakcję i zarządza kontekstem transakcji.
- Kojarzy również transakcję z zasobami w niej uczestniczącymi.
- Wreszcie prowadzi operacje zatwierdzania lub wycofywania transakcji bazując na dwufazowym protokole zatwierdzania.

Na koniec zadania zasobów transakcyjnych:

- Podstawową ich rolą jest umożliwienie aplikacji operowanie na danych, które przechowują.
- Dodatkowo zasoby transakcyjne muszą umieć współpracować z menedżerem transakcji, w szczególności w ramach dwufazowego protokołu zatwierdzania.

Kilka zdań wyjaśnienia należy się pojęciu kontekstu transakcji (*transaction context*). Kontekst transakcji to nic innego jak bieżący stan transakcji, w szczególności identyfikator transakcji oraz informacje o zasobach uczestniczących w transakcji. W czasie trwania transakcji jej kontekst przekazywany jest poszczególnym uczestnikom transakcji, co jest znane pod pojęciem propagacji kontekstu transakcji.

Na tym chciałbym zakończyć ogólne wprowadzenie do systemów transakcyjnych. Więcej szczegółów można znaleźć w materiałach pomocniczych [3,5]. Teraz przejdźmy do omówienia jak to jest zrealizowane w serwerze JEE.

**Transakcje w środowisku serwera aplikacyjnego JEE**

------

Zacznijmy od omówienia modeli transakcji jakie serwer aplikacji udostępnia deweloperem piszącym aplikacje. W praktyce mamy możliwość pisania systemów transakcyjnych na trzy różne sposoby.

W czasie trwania transakcji
jej kontekst przekazywany jest
poszczególnym uczestnikom transakcji

**Transakcje lokalne**. Serwer aplikacji umożliwia wykonywania operacji w sposób transakcyjny na pojedynczym zasobie, np. na bazie danych. Przy czym zarządzanie transakcjami realizuje programista korzystając z właściwości konkretnego zasobu, np. transakcje w obrębie pojedynczej bazy danych realizujemy z poziomu API zdefiniowanego przez specyfikację JDBC. Rola serwera aplikacji ogranicza się tutaj jedynie do udostępnienia zasobów, na których operuje aplikacja, np. źródła danych do bazy danych (`javax.sql.DataSource`).

**Transakcje zarządzane przez programistę** z wykorzystaniem interfejsów zdefiniowanych przez specyfikację **JTA**. Są to takie transakcje, w których programista pisząc kod, jawnie określa początek i koniec transakcji korzystając z JTA. Musi również umieć obsłużyć szereg sytuacji brzegowych, czy wyjątkowych związanych z korzystaniem z tych interfejsów.

**Transakcje zarządzane przez kontener, tzw. deklaratywne**. W tym przypadku programista tworzy komponenty EJB i w deskryptorze komponentów określa jakie ma być zachowanie transakcyjne poszczególnych metod. Całością obsługi transakcji zajmuje się serwer aplikacji, a ściślej kontener komponentów EJB we współpracy z menedżerem transakcji.

Transakcje lokalne oraz transakcję zarządzane przez kontener omówię w oddzielnych artykułach. Natomiast w tym artykule przedstawię dokładniej transakcje zarządzane przez programistę, które moim zdaniem najlepiej ilustrują wsparcie serwera aplikacji w tworzeniu systemów transakcyjnych.

Środowisko transakcyjne dla aplikacji JEE jest określone przez dwie specyfikacje:

- **Java Transaction API (JTA)** - definiuje ona sposób zarządzania transakcjami z punktu widzenia programisty. Określa również sposób współpracy z zasobami uczestniczącymi w transakcji rozproszonej (jest to odwzorowanie fragmentu standardu X/Open DTP - XA Interface).
- **Java Transaction Service (JTS)** - określa sposób implementacji menedżera transakcji (w szczególności wspierającego JTA), aczkolwiek specyfikacja JEE nie wymaga, żeby JTA było koniecznie implementowane w postaci JTS. Na rynku istnieje sporo implementacji JTA nie korzystających z JTS. JTS jest wymagane, jeśli myślimy o współpracy menedżerów transakcji w środowisku rozproszonym (transakcja rozproszona pomiędzy kilkoma serwerami aplikacji różnych dostawców). JTS jest tak naprawdę mapowaniem CORBA Object Transaction Service na język Java.

Najłatwiej zrozumieć związek pomiędzy tymi specyfikacjami przez analogię. JTA ma się mniej więcej tak do JTS jak specyfikacja JDBC do sterownika do bazy danych. Z punktu widzenia programisty praktyczne znaczenie ma JTA i tym będę się wyłącznie zajmował.

Przyjrzyjmy się teraz interfejsom jakie w serwerze aplikacji używane są do współpracy poszczególnych elementów uczestniczących w przetwarzaniu transakcji. Szczegóły przedstawiłem na rysunku 6.

![Uczestnicy transakcji rozproszonych w środowisku serwera aplikacji JEE](../../../.files/JeP_007_2010_03_Transakcje_006-1587590825072.png)

Rysunek 6. Uczestnicy transakcji rozproszonych w środowisku serwera aplikacji JEE

Dla aplikacji pracującej w serwerze aplikacji, która chce zarządzać transakcją został przygotowany interfejs `javax.transaction.UserTransaction`. Wywołania tego interfejsu serwer aplikacji deleguje do interfejsu `javax.transaction.TransacationManager`, który stanowi reprezentację menedżera transakcji w serwerze aplikacji (implementacja tego interfejsu stanowi serce menedżera transakcji).

JTA ma się mniej więcej tak do JTS
jak specyfikacja JDBC do sterownika do bazy danych

Aplikacja z poszczególnymi zasobami transakcyjnymi komunikuje się przez interfejsy specyficzne dla danych zasobów, np. przez interfejs JDBC albo JMS. Zachowanie transakcyjne zasobów jest przezroczyste z punktu widzenia aplikacji. Oczywiście sterowniki do zasobów muszą być odpowiednio zaimplementowane, ale zadanie to spoczywa na dostawcy sterownika, a nie na programiście aplikacji.

Pozostaje jeszcze interfejs `XAResource`, za pomocą którego odbywa się komunikacja między menedżerem transakcji a zasobami transakcyjnymi. Aby móc uczestniczyć w transakcji rozproszonej zasoby te muszą implementować `javax.transaction.xa.XAResource`. Interfejs ten stanowi kontrakt określający sposób współpracy menedżera transakcji z zasobami transakcyjnymi.
# RMI - Zdalne wywołania
Skrót od Remote Method Invocation zdalne wywołanie metod) to mechanizm umożliwiający zdalne wywołanie metod obiektów. Obiekty te mogą znajdować się w innych maszynach wirtualnych Javy, które mogą znajdować się na innych komputerach.

# EJB
**Enterprise JavaBeans** - technologia działająca po stronie serwera, która jest jednym z elementów specyfikacji [JEE](https://pl.wikipedia.org/wiki/JEE). EJB jest podobny do podzbioru możliwości JEE w kontekście zarządzania ziarnami (ang. *beans*), udostępniającymi usługi takie jak transakcyjność, trwałość, rozproszenie, bezpieczeństwo, wielodostęp itp. Jedyną rzeczą wymaganą od programisty korzystającego ze specyfikacji EJB jest dostosowanie się do pewnego interfejsu EJB (wymogów implementacyjnych), którego zastosowanie zwalnia użytkownika EJB (dostawcy ziarna lub całego modułu ziaren EJB) z konieczności opracowywania własnych metod obsługi komponentów.

Idea EJB opiera się na tworzeniu [komponentów](https://pl.wikipedia.org/wiki/Komponent) (ziaren EJB), które mogą być osadzane na [serwerze aplikacji](https://pl.wikipedia.org/wiki/Serwer_aplikacji) (tzw. *kontenerze EJB*), który z kolei udostępnia je do wykonania lokalnie (dostęp z części aplikacji uruchomionej na tej samej wirtualnej maszynie) lub zdalnie poprzez protokół [RMI](https://pl.wikipedia.org/wiki/RMI) over IIOP.

Wyróżnia się trzy typy komponentów (ziaren):

| S.No | Typ i opis                                                   |
| ---- | ------------------------------------------------------------ |
| 1    | **Session Bean** przetrzymuje informacje w sesji dla konkretnego użytkownika. Dane mogą być stanowe lub stanowe. |
| 2    | **Entity Bean** przetrzymuje informacje o użytkownikach.     |
| 3    | **Message Driven Bean** przekazują informacje.               |
## Web serwisy
### Handlery
Handlery pozwalają na implementację kodu który zmodyfikuje wyjście i wejście wiadomości SOAP.

W pierwszym kroku musimy zdefiniować `@HandlerChain` ze wskazaniem na plik zawierający definicję handlerów:

```java
@Stateless
@WebService(
        serviceName = "DocumentsService",
        portName = "Documents",
        // endpointInterface = "com.pentacomp.xidp.ws.ArtifactResolutionServiceInterface",
        targetNamespace = "http://wb.kir.pl/wbservices/Documents",
        wsdlLocation = "wsdl/documentsService.wsdl"
)
@WebContext(urlPattern = "documentsService")
@HandlerChain(file = "/META-INF/d-handler-chain.xml")
// @TransactionManagement(TransactionManagementType.CONTAINER)
// @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
public class DocumentsService implements DocumentsServiceInterface {
    // ...
}
```

Plik `d-handler-chain.xml`

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<javaee:handler-chains xmlns:javaee="http://java.sun.com/xml/ns/javaee">
	<javaee:handler-chain>
		<javaee:handler>
			<javaee:handler-class>com.pentacomp.xidp.ws.DocumentsServiceSOAPHandler</javaee:handler-class>
		</javaee:handler>
	</javaee:handler-chain>
</javaee:handler-chains>

```

Następnie handler:

```java
public class DocumentsServiceSOAPHandler implements SOAPHandler<SOAPMessageContext> {
    private static final Logger LOGGER = Logger.getLogger(DocumentsServiceSOAPHandler.class);

    @EJB
    private transient XIdpConfiguration configuration;

    /**
     * {@inheritDoc}
     */
    @Override
    public Set<QName> getHeaders() {
        return null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean handleMessage(SOAPMessageContext context) {
        LOGGER.trace(">> handleMessage");

        context.getHeaders()

        // LOGGER.trace("<< handleMessage");
        return true;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean handleFault(SOAPMessageContext context) {
        return true;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void close(MessageContext context) {
    }

}
```

# JavaFX
![Architecture of a JavaFX application - maimArt - Crafted Software](../../../.files/PJQSpIvpcD3N_Y4kdaKbEbQL2ZxtgNtJkzozxeii2blNwxeOkTMdMGFRNe52rNgwquNyTbtSqEr5sfKCc2McZY-p7OKU8zMKfInEpNGxaaREsanb)

Java FX jest domyślną biblioteką definiowania graficznego interfejsu użytkownika w języku Java począwszy od wersji 8. Zastąpiła ona starsze biblioteki takie jak Swing i AWT. Charakteryzuje się przede wszystkim dobrą separacją warstw, wsparciem dla architektury MVC  i udostępnia do tego użyteczne narzędzie o nazwie Scene Builder.
## Instalacja JFX
W wersjach wcześniejszych JavaFX była częścią pakietu JDK. Od wersji 11 została przeniesiona jako samodzielny moduł.

Dla `JDK < 11` nie było konieczności instalowania pakietu osobno. Od wersji 11 wzwyż wymagane jest doinstalowanie JFXa osobno i dołączenie do do środowiska.

W wersji Javy po dołączeniu powinna pojawić się informacje:

```
openjdk version "1.8.0_212"
OpenJDK Runtime Environment (build 1.8.0_212-b01)
OpenJDK 64-Bit Server VM (build 25.212-b01, mixed mode)
```
## Różnice pomiędzy Javą FX i Swingiem
Najważniejsze zmiany odróżniające ją od Swinga to przede wszystkim możliwość definiowania widoku aplikacji (tego jak wygląda) w języku **XML**, a nie tak jak było wcześniej w kodzie Javy. Ma to wiele zalet, przede wszystkim dużo łatwiejszą edycję, szybkość tworzenia kodu, możliwość rozdzielenia roli w zespole (ktoś inny może projektować to jak program wygląda, a ktoś inny może być odpowiedzialny za to co robi). Dedykowane narzędzie (Scene Builder) nie generuje komentarzy w stylu "nie dotykaj, bo zepsujesz" tak jak często miało to miejsce w kodzie wygenerowanym choćby przez NetBeansa.

Druga ważna rzecz, to możliwość modyfikacji wyglądu kontrolek, np. koloru przycisków, czcionki tekstów, rozmiaru poszczególnych elementów przy pomocy stylów **CSS**, które znamy m.in. ze stron internetowych. Jest to niesamowicie wygodne, nie trzeba już więcej wywoływać metod typu `setSize()`, `setColor()` itp. Wystarczy zmodyfikować jeden plik, który gromadzi wszystkie cechy.

JavaFX to również dużo lepsze wsparcie dla odtwarzania mediów, bez problemu odtworzymy w niej pliki MP3 oraz filmy w otwartych formatach. Dosłownie w 5 minut będziemy także w stanie zbudować prostą przeglądarkę internetową, ponieważ istnieją gotowe komponenty świetnie radzące sobie z obsługą HTML i Javascriptu.

Co również ważne, jeżeli bardzo brakowałoby Ci jakiegoś elementu Swinga, to przy pomocy specjalnej klasy `SwingNode` możesz je w większości wykorzystać w swojej aplikacji stworzonej w FXach.
## `Hello World` w JavaFX
```java
package helloworld;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class HelloWorld extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("Hello World!");
        Button btn = new Button();
        btn.setText("Say 'Hello World'");
        btn.setOnAction(new EventHandler<ActionEvent>() {

            @Override
            public void handle(ActionEvent event) {
                System.out.println("Hello World!");
            }
        });

        StackPane root = new StackPane();
        root.getChildren().add(btn);
        primaryStage.setScene(new Scene(root, 300, 250));
        primaryStage.show();
    }
}
```

Zwróć uwagę na:

- podstawowa klasa rozszerza `javafx.application.Application`,
- metoda `start()` jest wywoływana jako pierwsza,
- JavaFX definiuje `Stage` oraz `Scene`. `Stage` jest kontenerem najwyższego poziomu, natomiast `Scene` jest kontenerem dla zawartości,
- scena opiera się na hierarchicznej strukturze elementów widoku.

![Description of Figure 1-1 follows](../../../.files/c8f4be69-32ad-4523-ac11-233fa7fa5ac5.png)
## Podstawowe klasy
| Klasa                                | Opis                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `TableView`                          | Klasa do obsługi tabeli.                                     |
| `TableColumn`                        | Klasa do obsługi pojedyńczej kolumny.                        |
| `TableColumn.CellDataFeatures`       |                                                              |
| `TableCell`                          | Klasa do obsługi pojedyńczej komórki.                        |
| `TextFieldTableCell`                 | Podstawowa implementacja edycji komórki za pomocą `TextField` |
| `javafx.scene.control.Cell`          | Ogólna klasa reprezentująca komórkę w różnych kontrolkach.   |
| `javafx.scene.control.TablePosition` | Reprezentuje pozycję w wierszu/kolumnie/komórce              |
## Przykładowy formularz logowania
```java
package com.httpio.app;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class App extends Application {
    Text messageControl;

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);

        gridPane.setPadding(new Insets(25, 25, 25, 25));

        Scene scene = new Scene(gridPane, 200, 200);

        Text title = new Text("Login to HTTPio");
        title.setFont(Font.font("Tahoma", FontWeight.NORMAL, 20));

        gridPane.add(title, 0, 0, 2, 1);;

        // Username
        Label userNameLabel = new Label("Username");
        gridPane.add(userNameLabel, 0, 1);

        TextField userNameTextField = new TextField();
        gridPane.add(userNameTextField, 1, 1);

        // Username
        Label passwordLabel = new Label("Password");
        gridPane.add(passwordLabel, 0, 2);

        PasswordField passwordTextField = new PasswordField();
        gridPane.add(passwordTextField, 1, 2);

        // Login botton
        Button loginButton = new Button("Login");
        HBox loginWrapper = new HBox(10);

        loginWrapper.setAlignment(Pos.BOTTOM_RIGHT);
        loginWrapper.getChildren().add(loginButton);

        gridPane.add(loginWrapper, 1, 4);

        // Message
        messageControl = new Text();

        HBox messageControlWrapper = new HBox(messageControl);

        messageControlWrapper.setAlignment(Pos.CENTER);

        gridPane.add(messageControlWrapper, 0, 3, 2, 1);

        // loginButton.setOnAction(new EventHandler<ActionEvent>() {
        //     @Override
        //     public void handle(ActionEvent event) {

        //     }
        // });

        loginButton.setOnAction((ActionEvent event) -> {
            messageControl.setFill(Color.FIREBRICK);
            messageControl.setText("Error during login.");
        });

        // Add text
        primaryStage.setScene(scene);
        primaryStage.show();
    }
}
```
## Wyszukiwanie elementów po ID
Obiekty zdefiniowane w FXML mogą być wyszukane za pomocą metody `Scene.lookup`.

```java
Scene scene = new Scene(root, 1024, 700);

buttonSend = (Button) scene.lookup("#buttonSend");
headersVBox = (VBox) scene.lookup("#headersVBox");
```
## Wykorzystanie CSS
JavaFX  ma wsparcie dla styli CSS.

W pierwszym kroku wczytujemy style do sceny.

```java
scene.getStylesheets().add(App.class.getResource("/style.css").toExternalForm());
```

Następnie definiujemy podstawowe style np. takie jak niżej.

```css
.root {
    -fx-background-image: url("background.png");
}

.label {
    -fx-fcolor: white;
    -fx-font-size: 12px;
    -fx-font-weight: bold;
    -fx-text-fill: #333333;
    // -fx-effect: dropshadow( gaussian , rgba(255,255,255,0.5) , 0,0,0,1 );
}

.error {
    -fx-fill: FIREBRICK;
}

##welcome-text {
   -fx-font-size: 32px;
   -fx-font-family: "Arial Black";
   -fx-fill: #818181;
   -fx-effect: innershadow( three-pass-box , rgba(0,0,0,0.7) , 6, 0.0 , 0 , 2 );
}

##actiontarget {
  -fx-fill: FIREBRICK;
  -fx-font-weight: bold;
  -fx-effect: dropshadow( gaussian , rgba(255,255,255,0.5) , 0,0,0,1 );
}

.button {
    -fx-text-fill: white;
    -fx-font-family: "Arial Narrow";
    -fx-font-weight: bold;
    -fx-background-color: linear-gradient(#61a2b1, #2A5058);
    -fx-effect: dropshadow( three-pass-box , rgba(0,0,0,0.6) , 5, 0.0 , 0 , 1 );
}

.button:hover {
    -fx-background-color: linear-gradient(#2A5058, #61a2b1);
}
```

Należy pamiętać o tym, że atrybuty trochę się różnią od tych używanych w przeglądarkach. Np. odpowiednikiem atrybuty `color` jest `fill`.

Klasa `.root` to klasa wskazująca na ekran główny.

Na poszczególnym elementom możemy identyfikatory za pomocą których odwołamy się do ich w stylach.

```java
title.setId("title");
title.setId("welcome-text");

```

Lub dodawać nowe klasy.

```java
loginButton.setOnAction((ActionEvent event) -> {
    messageControl.getStyleClass().clear();
    messageControl.getStyleClass().add("error");

    // messageControl.setFill(Color.FIREBRICK);
    messageControl.setText("Error during login.");
});
```
## Wielowątkowość
https://docs.oracle.com/javafx/2/threads/jfxpub-threads.htm

JavaFX do wyświetlania sceny korzysta z własnego wątku. Jeśli chcemy np. wykonać zadanie które wymaga dużej ilości to wykonanie tego zadania w wątku JavaFX spowoduje, że interfejs użytkownika się zatrzyma. Jest to sytuacja niepożądana.

Jeśli chcemy wykonać zadanie iw innym wątku to oczywiście możemy taki wątek uruchomić. Trzeba zwrócić uwagę na to, że jeśli w tym wątku wykonujemy jakieś zmiany z GUI to nie możemy robić tego bezpośrednio ponieważ może to spowodować błędy w wątku głównym wykorzystywanym przez JavaFX.

W poniższym przykładzie, mam zadanie `Task` , które po wykonaniu zmieniało atrybut `lastResponse` która była połączona z elementem UI.

```java
package com.httpio.app.tasks;

import com.httpio.app.models.Profile;
import com.httpio.app.models.Request;
import com.httpio.app.services.HTTPSender;
import javafx.application.Platform;
import javafx.concurrent.Task;

public class ExecuteRequest extends Task<Void> {
    // ...

    @Override
    protected Void call() throws Exception {
        updateProgress(1, 3);

        HTTPSender.Response response = httpSender.send(request, profile);

        updateProgress(2, 3);

        // Wywołanie metody powodowało, że aktualizowała jest właściwość
        // lastReponse. Ta natomiast była połączona z elementem UI.
        request.setLastResponse(response);

        updateProgress(3, 3);

        return null;
    }
}
```

Powyższy kod generował błąd.

```
Exception in thread "Thread-14" java.lang.IllegalStateException: Not on FX application thread; currentThread = Thread-14
```

**Ogólnie nie wykonujemy zmian w UI w wątku innym niż w wątku JavaFX**

Błąd można naprawić wprowadzając zmianę:

```java
// Platform.runLater(new Runnable);
Platform.runLater(new Runnable() {
    @Override
    public void run() {
        request.setLastResponse(response);
    }
});

```

Metoda `Platform.runLater` przyjmuje obiekt implementujący `Runnable`. Samo wywołanie powoduje, że JavaFX umieszcza wywołanie w kolejce i wykonuje je w najbliższym możliwym momencie.
### Pakiet `javafx.concurrent`
Platforma Java zapewnia pełny zestaw bibliotek współbieżności dostępnych za pośrednictwem pakietu `java.util.concurrent`. Pakiet `javafx.concurrent` wykorzystuje istniejący interfejs API, uwzględniając wątek aplikacji JavaFX i inne ograniczenia napotykane przez programistów GUI.

Pakiet współbieżny składa się z interfejsu `Worker` oraz dwóch podstawowych klas, `Task` i `Service`, z których obie implementują interfejs `Worker`. Interfejs roboczy udostępnia interfejsy API przydatne pracownikowi pracującemu w tle do komunikacji z interfejsem użytkownika. Klasa `Task` to w pełni obserwowalna implementacja klasy `java.util.concurrent.FutureTask`.
Klasa `Task` umożliwia programistom wdrażanie zadań asynchronicznych w aplikacjach JavaFX.

Klasa Service wykonuje zadania.

Klasa `WorkerStateEvent` określa zdarzenie, które występuje, ilekroć zmienia się stan implementacji `Worker`.

Zarówno klasy `Task`, jak i `Service` implementują interfejs `EventTarget`, a tym samym obsługują nasłuchiwanie zdarzeń stanu.
### Klasa Task
Klasa implementuje wszystkie elementy składowe wymagane do dobrej współpracy z elementami UI. Są to np. atrybuty pod które możemy się podbindować (np. wskaźnik postępu zadania) lub atrybut `state` reprezentujący stan zadania.

Klasa Task implementuje interfejs `Worker`, sam interfejs definiuje minimum funkcjonalności jaki musi być zaimplementowany.

Przykładowe zadanie:

```java
import javafx.concurrent.Task;

Task<Integer> task = new Task<Integer>() {
    @Override protected Integer call() throws Exception {
        int iterations;
        for (iterations = 0; iterations < 100000; iterations++) {
            if (isCancelled()) {
               break;
            }
            System.out.println("Iteration " + iterations);
        }
        return iterations;
    }
};
```

Zadanie możemy uruchomić bezpośrednio w nowym wątku:

```java
Thread th = new Thread(task);

th.setDaemon(true);

th.start();
```

Lub za pomocą `ExecutorService`:

```java
ExecutorService.submit(task);
```

Można również wykonać jest za pomocą `Platform.runLater`. **Minusem takiego uruchomienia jest to, że zadanie zostanie uruchomione w wątku JavaFX co spowoduje, że interfejs zostanie zablokowany na czas działania.**

Należy pamiętać, że jeśli w zadaniu są wykonywane jakiekolwiek zmiany które moga mieć wpływ na UI to te zmiany powinny być wykonywane przez główny wątek. W innym przypadku może spowodować to wystąpienie błędów. Pisałem o tym wcześniej w kontekście metody `setLastReponse`.

Klasa rozszerza `java.util.concurrent.FutureTask`. Klasa `FutureTask` jest częścią Javy i reprezentuje zadanie które zostanie wykonane asynchronicznie (może teraz albo w przyszłości).

Przykład innej implementacji zadania:

```java
import javafx.concurrent.Task;

Task<Integer> task = new Task<Integer>() {
    @Override protected Integer call() throws Exception {
        int iterations;
        for (iterations = 0; iterations < 1000; iterations++) {
            if (isCancelled()) {
                updateMessage("Cancelled");
                break;
            }
            updateMessage("Iteration " + iterations);
            updateProgress(iterations, 1000);

            //Block the thread for a short time, but be sure
            //to check the InterruptedException for cancellation
            try {
                Thread.sleep(100);
            } catch (InterruptedException interrupted) {
                if (isCancelled()) {
                    updateMessage("Cancelled");
                    break;
                }
            }
        }
        return iterations;
    }
};
```
### Klasa Service
Reprezentuje zadanie które może być wykonywane wielokrotnie.
## Kontrolka `TableView`
Jest to kontrolka odpowiedzialna za wyświetlanie danych w formie tabelarycznej.
## Zmiana obiektu w metodzie `updateItem`
Metoda `updateItem` jest jedną ze standardowych metod w implementacji `Cell` dla wielu kontrolek.

Jedną z takich kontrolek jest `TreeView`, gdzie aby ustawić sposób wyświetlania zawartości kontrolki definiujemy `Callback` zwracający obiekt `TreeCell`.  W obiekt `TreeCell`  implementujemy metodę `updateItem`.

```java
protected void updateItem(T item, boolean empty) {
    super.updateItem(item, empty);

    if (empty) {
        setGraphic(null);
    } else {
        if (!inited) {
            setOnMouseClicked(new EventHandler<MouseEvent>() {
                @Override
                public void handle(MouseEvent event) {
                    if (onItemClicked != null) {
                        onItemClicked.call(item);
                    }
                }
            });

            inited = true;
        }

        // ...
    }
}
```

W przykładzie powyżej implementuje metodę oraz tworzę zdarzenie które ma zostać wykonane po kliknięciu na komórkę. W tym zdarzeniu należy zwrócić uwagę na to, że zapisywana jest referencja do elementu.  Przy następnym odświeżeniu, nie wykonywałem drugi przypięci zdarzenia, ponieważ `inited=true`.

Takie podejście okazało się błędne, ponieważ w momencie rozwinięcia elementu, ta konkretna komórka `TreeCell` zaczeła być wykorzystywana do innego elementu.

Czyli nie ma powiązania między elementem a komórką, jedna komórka może obsługiwać różne elementy. Wynik był taki, że na ekranie widniały dane z elementu `A`, natomiast zdarzenie było powiązane z elementem `B` co przy kliknięciu powodowało, że był zwracany element `B`.

Myślę, że podobne sytuacja pojawia się da innych komórek. W sumie ma to sens, ponieważ do obsługi komórek mamy ograniczoną ilość obiektów, a nie tyle obiektów ile elementów. Co np. w przypadku `TableView` odgrywało by pewnie znaczenie.

W poprawnym zapisie, za każdym razem na nowo powinienem przypisywać zdarzenie.

```java
protected void updateItem(T item, boolean empty) {
    super.updateItem(item, empty);

    if (empty) {
        setGraphic(null);
    } else {
        setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                if (onItemClicked != null) {
                    onItemClicked.call(item);
                }
            }
        });
        // ...
    }
}
```
## Klasa `ObservableList`
Jest to lista która udostępnia metody do obserwowania zmian.

Implementuje ona interfejsy:

- Collection
- Iterable
- List
- Observable
## Drag and Drop
JavaFX wspiera funkcjonalność przeciągnij i upuść.

Przeciągać można do:

- Nodes,
- Scenes.

Przeciągane mogą być dowolne elementy: tekst, grafika, linki itp. Obiekty mogą być przeciągane między aplikacjami różnego typu (niekoniecznie Javy).
### Tryby przesyłania (Transfer Modes)
Definiują typ transferu, mogą być to:

- `COPY`,
- `MOVE`,
- `LINK`.

Zdefiniowany transfer musi być obsługiwany przez obiekt docelowy.
### Przykład
Mamy dwa obiekty `Text`.

```java
final Text source = new Text(50, 100, "DRAG ME");
final Text target = new Text(300, 100, "DROP HERE");
```

W obiekcie źródłowym definiujemy `EventHandler` który zostanie wywołany w momencie wykrycia przesuwania.

```java
source.setOnDragDetected(new EventHandler<MouseEvent>() {
    public void handle(MouseEvent event) {
        /* drag was detected, start a drag-and-drop gesture*/
        /* allow any transfer mode */
        Dragboard db = source.startDragAndDrop(TransferMode.ANY);

        /* Put a string on a dragboard */
        ClipboardContent content = new ClipboardContent();
        content.putString(source.getText());
        db.setContent(content);

        event.consume();
    }
});
```

`Dragboard` jest rozszerzeniem `Clipboard` które jest mechanizmem schowka. Sam mechanizm schowka został opisany w innym rozdziale.

Metoda `startDragAndDrop` wywołana z informacją o trybie transferu.

`ClipboardContent` jest uniwersalnym kontenerem do przechowywania różnego typu danych.

`event.consume()` uruchamia proces przenoszenia.

Następnie, należy ustawiać `EventHandler` który obsłuży zdarzenie najechania na element docelowy.

```java
target.setOnDragOver(new EventHandler<DragEvent>() {
    public void handle(DragEvent event) {
        /* data is dragged over the target */
        /* accept it only if it is not dragged from the same node
         * and if it has a string data */
        if (event.getGestureSource() != target &&
                event.getDragboard().hasString()) {
            /* allow for both copying and moving, whatever user chooses */
            event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
        }

        event.consume();
    }
});
```

Przeciągając obiekt nad obiekt docelowy zostaje uruchomiony `DRAG_OVER`.

W definicji `DRAG_OVER` określamy czy przenoszony obiekt może być upuszczony w miejscu docelowym.

 Musimy zdefiniować jeszcze `DRAG_ENTERED`, którego zadaniem jest graficzne przedstawienie w trakcie przesuwana nad obiektami. Np. zmiana koloru obiektu.

```java
target.setOnDragEntered(new EventHandler<DragEvent>() {
    public void handle(DragEvent event) {
    /* the drag-and-drop gesture entered the target */
    /* show to the user that it is an actual gesture target */
         if (event.getGestureSource() != target &&
                 event.getDragboard().hasString()) {
             target.setFill(Color.GREEN);
         }

         event.consume();
    }
});
```


## Schowek
https://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/Clipboard.html

```java
final Clipboard clipboard = Clipboard.getSystemClipboard();
final ClipboardContent content = new ClipboardContent();
content.putString("Some text");
content.putHtml("<b>Some</b> text");
clipboard.setContent(content);
```

```
if (clipboard.hasString()) { ... }
```

```
ClipboardContent content = new ClipboardContent();
content.putString("some text");
content.put(DataFormat.PLAIN_TEXT, "other text");
```
## Bindowanie
Jest to mechanizm za pomocą którego możemy połączyć właściwości między obiektami. Jest to dość praktyczne np. gdy łączymy elementy GUI z danymi znajdującymi się w obiektach.

```java
class A {
    IntegerProperty age = new SimpleIntegerProperty(10);
    ListProperty<Item> items = new SimpleListProperty<Item>(FXCollections.observableArrayList());

    ObjectProperty<Item> item = new SimpleObjectProperty<>();

    @Override
    public String toString() {
        return item.toString();
    }

    public IntegerProperty ageProperty() {
        return age;
    }

    public int getAge() {
        return age.get();
    }

    public ListProperty<Item> itemsProperty() {
        return items;
    }

    public ObservableList<Item> getItems() {
        return items.get();
    }

    public ObjectProperty<Item> itemProperty() {
        return item;
    }
}
```

Każda właściwość powinna być owrapowana obiektem `ObjectProperty<T>` . Jest również lista klas dla typowych typów.

Dostępne są dwa mechanizmy połączenia, jedno kierunkowe oraz dwu kierunkowe. W przypadku jednokierunkowego obiekt A odczytuje dane z obiektu B, ale sam nie może ich zmienić. W przypadku dwukierunkowym, zmiany z A przechodzą do B.

Poniżej przykład z jednokierunkowym łączeniem.

```java
StringProperty a = new SimpleStringProperty("A");
StringProperty b = new SimpleStringProperty("B");

System.out.println("a: " + a.getValue()); // A
System.out.println("b: " + b.getValue()); // B

a.bind(b);

System.out.println("a: " + a.getValue()); // B
System.out.println("b: " + b.getValue()); // B

// Jeśli wartość jest połączona, to nie może zostać zmieniona.
// a.setValue("Nowa"); // A bound value cannot be set.

a.unbind();

System.out.println("a: " + a.getValue()); // B
System.out.println("b: " + b.getValue()); // B

a.setValue("Test");

System.out.println("a: " + a.getValue()); // Test
System.out.println("b: " + b.getValue()); // B

```

Należy pamiętać również o tym, że jeśli bindowany jest obiekt, np. lista to w przypadku bindowania jednokierunkowego obiekt A będzie mógł zmienić wartość, ale nie przez właściwość `Property` tylko musi pobrać właściwość z obiektu i działać na niej bezpośrednio.

Czyli, coś takiego nie jest możliwe.

```java
A a = new A();
A b = new A();

a.itemsProperty().bind(b.itemsProperty());
a.itemsProperty().setValue(FXCollections.observableArrayList());// A bound value cannot be set.

// Możemy dodać nowy obiekt do listy, nie możemy zmienić samej listy.
// a.itemsProperty().add(new Item(""));
```
## Format FXML
Jest to rozszerzenie formatu XML za pomocą którego możliwe jest zdefiniowanie interfejsu użytkownika.

Poniżej przykład definicji interfejsu.

```xml
<?xml version="1.0" encoding="UTF-8"?>

<?import java.net.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.*?>

<GridPane
    fx:controller="com.httpio.app.App"
    xmlns:fx="http://javafx.com/fxml"
    alignment="center"
    hgap="10"
    vgap="10"
>
        <padding>
            <Insets top="25" right="25" bottom="10" left="25"/>
        </padding>
        <gridLinesVisible>false</gridLinesVisible>

        <HBox
            GridPane.columnIndex="0"
            GridPane.rowIndex="0"
            GridPane.columnSpan="2"

            alignment="CENTER"
        >
            <Text
                text="Login to HTTPio"
            ></Text>
        </HBox>

        <Label
            GridPane.rowIndex="1"
            GridPane.columnIndex="0"

            text="Username"
        ></Label>

        <TextField
            GridPane.rowIndex="1"
            GridPane.columnIndex="1"
        ></TextField>

        <Label
            GridPane.rowIndex="2"
            GridPane.columnIndex="0"

            text="Password"
        ></Label>

        <PasswordField
            GridPane.rowIndex="2"
            GridPane.columnIndex="1"
        ></PasswordField>

        <Text
            GridPane.rowIndex="3"
            GridPane.columnIndex="0"
            GridPane.columnSpan="2"

            fx:id="message"
        ></Text>

        <HBox
            GridPane.columnIndex="0"
            GridPane.rowIndex="4"
            GridPane.columnSpan="2"

            alignment="BOTTOM_RIGHT"
        >
            <Button
                text="Login"
                onAction="#handleSubmitButtonAction"
            ></Button>
        </HBox>
</GridPane>
```

Tak zdefiniowany interfejs używamy w następujący sposób.

```java
Parent root = FXMLLoader.load(App.class.getResource("/login.fxml"));

Scene scene = new Scene(root, 200, 200);

stage.setScene(scene);
stage.show();

```

Zwróć uwagę na `    fx:controller="com.httpio.app.App"` ten atrybut informuje która klasa jest odpowiedzialna za obsługę zdarzeń.

Zwróć uwagę również na to w jaki sposób dochodzi do połączenie definicji obiektu w XML z obiektem w kodzie.

```xml
<Text
      GridPane.rowIndex="3"
      GridPane.columnIndex="0"
      GridPane.columnSpan="2"

      fx:id="message"
></Text>

```

Dla elementu jest nadawany identyfikator następnie w kontrolerze tworzony jest atrybut z adnotacją. Dzięki temu następuje połączenie.

```java
@FXML
private Text message;
```

Zwróć uwagę na samą strukturę XML. Ma on strukturę drzewiastą np. mamy `GridPane - HBox - Button`. Przekazywanie parametrów do obiektu nadrzędnego (rodzica) odbywa się przez dodanie odpowiednich atrybutów w obiekcie dziecka np. w `Button` mamy atrybuty `GridPane.*` które definiują położenie dziecka względem rodzica.

 ```xml
<HBox
      GridPane.columnIndex="0"
      GridPane.rowIndex="4"
      GridPane.columnSpan="2"

      alignment="BOTTOM_RIGHT"
      >
    <Button
            text="Login"
            onAction="#handleSubmitButtonAction"
     ></Button>
</HBox>
 ```

Innym ciekawym rozwiązaniem jest bindowanie akcji pod metody zawarte w klasie.

```xml
<Button
    text="Login"
	onAction="#handleSubmitButtonAction"
></Button>
```

Na dowolnej akcji zostanie wywołana metoda `handleSubmitButtonAction` w obiekcie `App`.

```xml
fx:controller="com.httpio.app.App"
```

W kontrolerze dzięki adnotacji silnik wie jaka metoda `handleSubmitButtonAction` ma zostać użyta, pomimo, że jest metodą prywatną.

```java
@FXML
protected void handleSubmitButtonAction(ActionEvent event) {
    message.setText("You can not login.");
    // actiontarget.setText("Sign in button pressed");
}

```

Jeśli nie użyjemy adnotacji to metoda musi być publiczna.

```java
public void handleSubmitButtonAction(ActionEvent event) {
    message.setText("You can not login.");
    // actiontarget.setText("Sign in button pressed");
}
```
### Skrypty
W definicji istnieje możliwość definiowania skryptów np. w JavaScript.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<?language javascript?>

<?import java.net.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.*?>

<GridPane
        xmlns:fx="http://javafx.com/fxml"
        alignment="center"
        hgap="10"
        vgap="10"
>
    <fx:script>
        function handleSubmitButtonAction() {
            message.setText("Calling the JavaScript");
        }
    </fx:script>

    <!-- ... -->
    <HBox
        GridPane.columnIndex="0"
        GridPane.rowIndex="4"
        GridPane.columnSpan="2"

        alignment="BOTTOM_RIGHT"
    >
        <Button
            text="Login"
            onAction="handleSubmitButtonAction(event)"
        ></Button>
    </HBox>
</GridPane>

```

Po naciśnięciu uruchamiana jest funkcja `handleSubmitButtonAction`.

Skrypty można pisać w:

- JavaScript,
- Groovy,
- Jython,
- Clojure .

Do XML zostało nam jeszcze dodanie styli.

```xml
<!-- ... -->
	<stylesheets>
        <URL value="@/style.css" />
    </stylesheets>
</GridPane>

```

Symbol `@` informuje, że plik jest w tej samej lokalizacji co plik XML.
## `TableView`
Jest to klasa do wyświetlania danych w formie tabelarycznej.

```java
Class TableView<S>
	java.lang.Object
		javafx.scene.Node
			javafx.scene.Parent
				javafx.scene.layout.Region
					javafx.scene.control.Control
						javafx.scene.control.TableView<S>

Type Parameters:
S - The type of the objects contained within the TableView items list.

All Implemented Interfaces:
Styleable, EventTarget, Skinnable
```

### Definiowanie `setCellValueFactory`
Dla każdej kolumny musi zostać zdefiniowana metoda określająca w jaki sposób jest tworzona zawartość komórki.

W większości przypadków będzie to podstawowy sposób korzystający z`PropertyValueFactory`. Wartość jest pobierana bezpośrednio z obiektu.

```java
TableColumn name = (TableColumn) headersTable.getColumns().get(0);
TableColumn value = (TableColumn) headersTable.getColumns().get(1);

name.setCellValueFactory(new PropertyValueFactory<Header, String>("name"));

```

Jest również możliwość zdefiniowania własnego formatu. Funkcja `setCellValueFactory` wymaga interfejsu3 `Callbacku` który jest wywoływany przy każdym formatowaniu zawartości komórki.

```java
value.setCellValueFactory(new Callback<CellDataFeatures<Header, String>, ObservableValue<String>>() {
    @Override
    public ObservableValue call(CellDataFeatures<Header, String> p) {
        return new ReadOnlyObjectWrapper(p.getValue().getValue());
    }
});

```
### Definiowanie `setCellFactory`
Metoda jest odpowiedzialna za ustawienie funkcji odpowiedzialnej za renderowanie zawartości kolumny.

Najprostszym przypadkiem jest ustawienie obiektu `TextFieldTableCell`. Rozszerza on klasę `TableCell` i implementuje metody który umieszczają obiekt `TextField` w miejsce komórki w trybie edycji.

Podstawowy mechanizm w trybie edycji umieszcza `Label`. Czyli brak edycji.

```java
value.setCellFactory(TextFieldTableCell.forTableColumn());
```

W powyższym przykładzie, ustawiamy prosty `TextFieldTableCell` z ustawionym już konwerterem. Jak zajrzymy co się dzieje w środku.

```java
public static <S> Callback<TableColumn<S,String>, TableCell<S,String>> forTableColumn() {
    return forTableColumn(new DefaultStringConverter());
}


public static <S,T> Callback<TableColumn<S,T>, TableCell<S,T>> forTableColumn(
    final StringConverter<T> converter) {
    return list -> new TextFieldTableCell<S,T>(converter);
}
```

Rozpoczęcie edycji.

```java
@Override public void startEdit() {
    if (! isEditable()
        || ! getTableView().isEditable()
        || ! getTableColumn().isEditable()) {
        return;
    }
    super.startEdit();

    if (isEditing()) {
        if (textField == null) {
            textField = CellUtils.createTextField(this, getConverter());
        }

        CellUtils.startEdit(this, getConverter(), null, null, textField);
    }
}

```

W trybie do edycji mamy.

```java
static <T> void startEdit(final Cell<T> cell,
                          final StringConverter<T> converter,
                          final HBox hbox,
                          final Node graphic,
                          final TextField textField) {
    if (textField != null) {
        textField.setText(getItemText(cell, converter));
    }
    cell.setText(null);

    if (graphic != null) {
        hbox.getChildren().setAll(graphic, textField);
        cell.setGraphic(hbox);
    } else {
        cell.setGraphic(textField);
    }

    textField.selectAll();

    // requesting focus so that key input can immediately go into the
    // TextField (see RT-28132)
    textField.requestFocus();
}

```

Zwróć uwagę na.

```java
hbox.getChildren().setAll(graphic, textField);
cell.setGraphic(hbox);
// oraz
cell.setGraphic(textField);
```

Oraz metoda odpowiedzialna za tworzenie `TextField`.

```java
static <T> TextField createTextField(final Cell<T> cell, final StringConverter<T> converter) {
    final TextField textField = new TextField(getItemText(cell, converter));

    // Use onAction here rather than onKeyReleased (with check for Enter),
    // as otherwise we encounter RT-34685
    textField.setOnAction(event -> {
        if (converter == null) {
            throw new IllegalStateException(
                "Attempting to convert text input into Object, but provided "
                + "StringConverter is null. Be sure to set a StringConverter "
                + "in your cell factory.");
        }
        cell.commitEdit(converter.fromString(textField.getText()));
        event.consume();
    });
    textField.setOnKeyReleased(t -> {
        if (t.getCode() == KeyCode.ESCAPE) {
            cell.cancelEdit();
            t.consume();
        }
    });
    return textField;
}

```

Faktor możemy zdefniować również w taki sposób.

```java
name.setCellFactory(new Callback<TableColumn, TableCell>() {
    @Override
    public TableCell call(TableColumn param) {
        return new TextFieldTableCell(new DefaultStringConverter());
    }
});
```

Czyli przekazujemy `Callback`, jest to interfejs funkcyjny. Następnie zwracamy inny obiekt kolumny `TextFieldTableCell`.
### Modyfikacja sposobu wyświetlania
```java
birthdayColumn.setCellFactory(column -> {
    return new TableCell<Person, LocalDate>() {
        @Override
        protected void updateItem(LocalDate item, boolean empty) {
            super.updateItem(item, empty);

            if (item == null || empty) {
                setText(null);
                setStyle("");
            } else {
                // Format date.
                setText(myDateFormatter.format(item));

                // Style all dates in March with a different color.
                if (item.getMonth() == Month.MARCH) {
                    setTextFill(Color.CHOCOLATE);
                    setStyle("-fx-background-color: yellow");
                } else {
                    setTextFill(Color.BLACK);
                    setStyle("");
                }
            }
        }
    };
});
```

# Współbieżność

## Współdziałanie wątków
W przypadku przetwarzania współbieżnego gdy kilka wątków przetwarza ten sam zasób/obiekt to może dojść do sytuacji gdy w tym samym momencie kilka wątków próbuje zmodyfikować/odczytać ten sam zasób . Taka sytuacja na ogół prowadzi do błędów. Jeden wątek zmienia dane, a drugi w między czasie je czyta.

Java udostępnia tgz. blok synchroniczny za pomocą którego, możemy zabezpieczyć się przed sytuacjami gdy wiele wątków jednocześnie próbuje pracować na tym samym zasobie lub np. zablokować możliwość jednoczesnego wykonania tego samego kodu przez wiele wątków.
### Operacja `Thread.join`
Za pomocą tej metody możemy ustawić aby wątek oczekiwał aż inny wątek się zakończy.

```java
private static class ThreadJoin extends Thread {
    private final String name;
    private final Thread waitFor;

    private ThreadJoin(String name, Thread waitFor) {
        this.name = name;
        this.waitFor = waitFor;
    }

    @Override
    public void run() {
        System.out.println(String.format("ThreadJoin %s with id %s - run", name, Thread.currentThread().getId()));

        try {
            // Aktualny wątek będzie czekał, aż wątek waitFor się zakończy.
            waitFor.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(String.format("ThreadJoin %s with id %s - run", name, Thread.currentThread().getId()));
    }
}

```

W powyższym przykładzie wątek ThreadJoin będzie czekał aż wątek waitFor się ukończy.
### Operacja `Thread.sleep`
Pozwala na zatrzymanie aktualnego wątku. Zatrzymanie spowoduje, że procesor będzie dostępny dla pozostałych wątków.

```java
private static class ThreadSleep extends Thread {
    private final String name;
    private final int sleep;

    public ThreadSleep(String name, int sleep) {
        this.name = name;
        this.sleep = sleep;
    }

    @Override
    public void run() {
        System.out.println(String.format("ThreadSleep %s with id %s - run", name, Thread.currentThread().getId()));

        try {
            Thread.sleep(sleep);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(String.format("ThreadSleep %s with id %s - finish", name, Thread.currentThread().getId()));
    }
}
```
### Operacja `Thread.yield`
Metoda pozwala na poinformowanie systemy, że aktualny wątek może zwolnić czas procesora dla innych wątków - tymczasowo.

Załóżmy, że mamy dwa zadania do wykonania w dwóch wątkach, a system może wykonywać tylko jeden wątek w jednym czasie. Pierwsze zadanie zajmie 5h, natomiast drugie 5 minut. Jeśli w pierwszej kolejności będzie wykonywane pierwsze zadanie to drugie zadanie będzie oczekiwało 5h tylko po to aby następnie działać przez 5 minut.

Metoda `Thread.yield` informuje system o tym, że wątek może zostać na chwilę zwolniony w innych celach.

**Działanie metody ma charakter sugestywny dla systemu. Każdy system może zachować się inaczej, może również olać tą informacje i zarządzać wątkami po swojemu.**

Poniżej przykład kodu szukającego liczb pierwszych. Między każdym sprawdzeniem wątek informuje o tym, że może zwolnić czas procesora dla innych zadań.

```java
int primaryNumber = 1;

for(int i = 0; i <= max; i++) {
    for(int j = 2; j <= i; j++) {
        if (i % j == 0) {
            if (i == j) {
                primaryNumber = i;
            } else {
                break;
            }
        }
    }

    // Możemy zwolnić na chwile dla innych zadań.
    if (yield) Thread.yield();
}
```
## Blok synchroniczny
Jest to konstrukcja `synchronized (${SEMAFOR/MUTEX}) {${KOD}}` za pomocą, której definiujemy jaki kod ma się wykonać. Wykona się tylko wtedy gdy semafor zostanie zwolniony. Jeśli mamy blok synchroniczny S<sub>1</sub>(M<sub>1</sub>) oraz semafor M<sub>1</sub>, oraz blok synchroniczny S<sub>1</sub>(M<sub>1</sub>) i wątek T<sub>2</sub>. To jeśli pierwszy zacznie działać wątek T<sub>1</sub> to T<sub>2</sub> będzie czekał aż T<sub>1</sub> zakończy działanie. W trakcie działa T<sub>1</sub> semafor M<sub>1</sub> jest ustawiony na aktywny. Jak T<sub>1</sub> zakończy działanie to M<sub>1</sub> zostanie ustawiony na nieaktywny i T<sub>2</sub> będzie mógł zacząć wykonywać S<sub>2</sub> gdzie zacznie działać to M<sub>1</sub> znowu zostanie ustawiony na aktywny.

```java
private final Queue queue;

public void run() {
    // Wątek A, B
    synchronized (queue) {
		// Ten fragment kodu będzie wykonany tylko przez jeden wątek w tym samym czasie
        // Jeśli wątek A pierwszy dojdzie do tego miejsca, to wątek B będzie oczekiwał, aż wątek A
        // wyjdzie z bloku synchronicznego lub przejdzie w stan czekania Object.wait
    }
}
```

Blok synchroniczny można zdefiniować również przez dodanie słowa `synchronized` do sygnatury metody.

```java
public synchronized void run() {
    // ...
}
```

Powyższy zapis jest tożsamy z:

```java
public void run() {
    synchronized (this) {
    	// ...
    }
}
```

Czyli blokada na cały obiekt. Blokowanie całego obiektu jest wygodne, ale nie zawsze ofektywne. Przykłądowa blokada na obiekcie `Watch`

```java
public class Watch {
    private final int time;
    public Watch(int time) { this.time = time; }
    public int getTime() { return time; }
}
```

Poniżej fragment kodu, gdzie jeden wątek blokuje obiekt `watch` na 5 sekund. W między czasie drugi wątek oczekuje aż obiekt zostanie zwolniony, dopiero po zwolnieniu drugi wątek może wykonać swój kod (zawarty w bloku synchroncznym). Zwróć uwagę, że został zastosowany blok synchroniczny dla metody, która nie jest synchroniczna. Bez bloku synchronicznego metoda została by się od razu wykonała.

```java
Watch watch = new Watch(10);

new Thread(() -> {
    System.out.println("Wątek A init");
    synchronized (watch) {
		Thread.sleep(5000);
    }
    System.out.println("Wątek A end");
}).start();

new Thread(() -> {
    synchronized (watch) {
        System.out.println("Wątek B " + watch.getTime());
    }
}).start();
```

Był konieczny blok synchroniczny dlatego, że metoda nie jest synchroniczna. Po zmianie metody `getTime` na:

```java
public synchronized int getTime() { return time; }
```

Metoda `getTime` zostanie wykonana dopiera wtedy gdy pierwszy wątek zwolni obiekt. Dzieje się tak dlatego, że metoda synchroniczna blokuje cały obiekt. Czyli w tym przypadku jest to tożsame z `synchronized(this) {...}` gdzie `this == watch`.

Podsumowując, podstawą jest blok synchroniczny kodu oraz semafor. Dla określonego semafora wykonuje sie na raz tylko jeden z bloków kodu. Blok synchroniczny możemy zadeklarować inline lub zdefniowaniować go jako metodę w obiekcie.  

**Obiektem nie musi być określony obiekt aplikacji może to być jaki kolwiek obiekt, za pomoca którego możemy synchronizować kilka wątków.**

### Metody synchroniczne

Jeśli oznaczymy metodę przez słowo `synchronized` to tak naprawdę jest to równoznaczne z `synchronized(this)` czyli blokowanie całego obiektu. Jeśli obiekt ma więcej metod to wykonanie wszystkich metod zostanie zatrzymane jeśli ta jedna synchroniczna jest w trakcie działania. Możemy mieć taka sytuację.

```java
class Car {
	public synchronized void ride() {}
}

Car car = new Car();
synchronized(car) {
    // ...
}
```

Metoda `ride` synchronizuje się na instancji Car ale jednocześnie inny kod może tworzyć blok synchroniczny na ten samej instancji w niekontrolowany sposób co ma wpływ na działanie instancji Car. Nie jest to najlepsza praktyka. **Lepsze jest stosowane prywatnych pól do przechowywania instancji do synchronizacji.**

```java
class Car {
    private final Object MUTEX_A = new Object();
	public void ride() {
        synchronized(MUTEX_A) {
            // ...
        }
    }
}
```

### String w bloku synchronicznym

Typ obiektu String nie jest najlepszym typem do stosowania jako obiekt do synchronizacji wątków dlatego, że jego instancje są współdzielone.

```java
String MUTEX_A = "MUTEX_A";
String MUTEX_B = new String("MUTEX_A").intern();
```

W obu tych przypadkach zostanie użyta instancja ze wspólnej puli. Musielibyśmy utworzyć string w taki sposób aby mieć pewność, że jest to nowa inctacja.

```java
String MUTEX_B = new String("MUTEX_A");
```

## Metody `wait/notify/notifyAll`

W momencie gdy wykonywany jest blok synchroniczny to inne wątki w ramach tego samego semafora będą oczekiwały aż aktualny wątek wykona blok synchroniczny. Jeśli np. w ramach bloku zostanie zdefiniowana nieskończona pętla to blok synchroniczny nie zostanie nigdy zakończony i inne wątki nie będą mógłby wykonać swoich bloków synchronicznych. Dojdzie do zakleszczenia wątków.  Czasami chcemy np. aby wątek wykonał określone zadania, a następnie odczekał określony czas i znowu cos sprawdził. Dobrym przykładem może być np. przetwarzanie kolejki, gdzie np. różne wątki mogą dodawać coś do kolejki a inne wątki pobierać elementy z kolejki. Czyli wątki związane z przetwarzaniem kolejki czekają aż coś się pojawi w kolejce, w momencie gdy się coś pojawi to mogą wykonać zadanie.

Można to wykonać np. w ramach nieskończonej pętli.

```java
// Dorobić przykład
```

Wykorzystanie metod `wait/notify/notifyAll`. Poniżej jest przykład takiej kolejki. 

```java
public class Queue {
    private List<String> messages = new Vector<>();

    public synchronized void addMessage(String message) {
        messages.add(message);
        notify();
    }

    public synchronized void addMessage(Collection<? extends String> messages) {
        this.messages.addAll(messages);
		notify();
    }

    public synchronized List<String> getMessages() {
        return messages;
    }
}
```

Oraz wątki które ją przetwarzają.

```java
Queue queue = new Queue();

Sender senderA = new Sender(queue);
Sender senderB = new Sender(queue);

new Thread(senderA, "Sender A").start();
new Thread(senderB, "Sender B").start();

while (true) {
    queue.addMessage("Hello");

    sleep(5000);

    queue.addMessage(Arrays.asList("Hi John", "Hi Billy", "Hi Foo"));

    sleep(5000);
}

// Sender
public class Sender implements Runnable {
    private final Queue queue;

    public Sender(Queue queue) {
        this.queue = queue;
    }

    @Override
    public synchronized void run() {
        synchronized (queue) {
            while (true) {
                if (!queue.getMessages().isEmpty()) {
                    for (String message : queue.getMessages()) {
                        print("send message " + message);
                    }
                    
                    queue.getMessages().clear();
                }

                Thread.sleep(5000);
                queue.wait();
            }
        }
    }
}
```

Czyli mamy dwa wątki które wysyłają wiadomość oraz jeden wątek, które tworzy wiadomości. Wątek w ramach klasy `Sender` ma blok synchroniczny z semaforem ustawionym na obiekcie kolejki `queue`. Oznacza to, że jeśli jakiś inny wątek będzie wykonywał blok synchroniczny z takim samym semaforem `queue` to ten kod będzie oczekiwał. No tutaj nie ma takiej sytuacji, w pierwszym kroku wywołuje się wątek w ramach `Sendera`. W bloku synchronicznym sprawdza czy nie ma powiadomień. Jeśli są to wysyła i następnie wykonuje metodę `queue.wait`. Czyli aktualny wątek przechodzi w stan czekania. **Powoduje to, że semafor zostaje zwolniony i inny wątki (drugi sender) mogą się wykonać**. W momencie dodania nowej wiadomości do kolejki jest wykonywana metoda `notify -> queue.notify -> Object.notify` . Wykonanie tej metody powoduje, że wątki Senderów A,B które są wstrzymane semaforem ``queue`  zostaną uruchomione (obudzone). Sprawdzą czy są powiadomienia do wysłania, wyślą i znowu przejdą w stan uśpienia.

**Metody `wait/notify/notifyAll` w ramach wspólnego semafora (obiektu) pozwalają się komunikować wątkom.**

Należy pamiętać, że metody mogą być użyte tylko w kontekście bloku synchronicznego, użycie ich poza tym kontekstem spowoduje pojawienie się wyjątku `IllegalMonitorStateException`.
## Mechanizm `volatile`
Wyrażenie `volatile` gwarantuje, że zmienna zostanie zapisana od razu w głównej pamięci RAM oraz wartość zmiennej będzie również pobierana bezpośrednio z pamięci RAM.

Ten mechanizm jest lepiej zrozumieć na przykład. W trakcie działa programu wielowątkowego poszczególne CPU korzystają z własnej pamięci podręcznej do przechowywania zmiennych. Jest tak dlatego, że odczyta z pamięci RAM wymaga więcej czasu niż odczyt z pamięci podręcznej procesora. 

![img](../.files/cpu.png)

W konsekwencji dana zmienna może występować w kilku miejscach. W pamięciach podręcznych procesorów oraz pamięci głównej RAM. W zależności od CPU, strategia działa może być różna. Procesor może zaczytywać więcej danych z wyprzedzeniem niż jest mu potrzebne aby w momencie gdy będzie je przetwarzał miał do nich szybki dostęp. Operację odczytu i zapisu danych do pamięci również mogą być optymalizowane w taki sposób np. w taki sposób że proces zbiera te operacje w buforze a następnie za jednym razem wykonuje zapisy i odczyty. Ten obszar pracy jest dla programisty dość niedeterministyczny. 

W przypadku kilku CPU istnieje szansa, że pamięci podręczne między CPU nie będą spójne. Poniżej przykład programu.

```java
public class TaskRunner {
    private static int number;
    private static boolean ready;

    private static class Reader extends Thread {
        @Override
        public void run() {
            while (!ready) {
                Thread.yield();
            }

            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new Reader().start();
        number = 42;
        ready = true;
    }
}
```

W powyższym przykładzie mam jeden główny wątek oraz wątek `Runnera`. Zmienne `number, ready` są współdzielone przez te dwa wątki. Po uruchomieniu wątek główny uruchamia wątek runnera. Ten czeka aż wątek główny ustawi zmienną `read` na `true`.  Jeśli te dwie zmienne `number, read` nie są `volatile` to oba każdy CPU może mieć własną kopię zmiennych w pamięci podręcznej. Jest ryzyko, że wystąpi taka sytuacja, że uruchomi się wątek runnnera który będzie w tgz. spinie (kręci się i oczekuje w pętli). Następnie główny wątek ustawi zmienne `numer, ready`. Tu jest kluczowy moment. Nie mamy pewności kiedy i w jakiej kolejności te zmienne z CPU głównego zostaną zaciągnięte do CPU runnera wiec możliwa jest np. taka sytuacja, że pierwsza będzie to wartość zmienne `ready` wtedy wątek runnera się wykona i wyświetli `0` . Może być sytuacja odwrotna wtedy program zadziałał by poprawnie lub obie zmienne poprawnie przejdą do CPU runnera (przez pamięć podręczną).

Aby uniknąć takich nieprzewidywalnych zachować stosuje się mechanizm `volatile`. 

```java
public class TaskRunner {

    private volatile static int number;
    private volatile static boolean ready;

    // same as before
}
```

Powoduje to:

1. **Wymusza on na CPU bezpośredniej pracy na zmiennej w pamięci.** Dzięki czemu zmiana jej wartości jest natychmiast dostępna dla innych CPU. Dane między wątkami są spójne.
2. Blokuje możliwość zmiany kolejności wykonywania programu. Czasami w trakcie kompilacji i optymalizacji wywołanie instrukcji może być inne. Oznaczenie zmiennej przez `volatile` wyłącza ten mechanizm dla wywołań które działają na takiej zmiennej.
3. Zmiana jest od razu dostępna dla innego wątku. Realizuje to zagadnienie widoczności współdzielonych zmiennych w programie wielowątkowym.

Mechanizm `volatile`  powinniśmy używać gdy chcemy mieć pewność, że wartość zmiennej będzie spójna między wątkami a nie musimy od razu stosować bloku synchronicznego. Ten sposób jest wydajniejszy.

Na ogół stosuje się przy prostych typach `int, long`  jeśli np. oznaczymy zmienną typu `[]` to ten mechanizm będzie działał tylko dla tej zmiennej ale nie dla obiektów w środku. Czyli będzie działał na wskaźnik.
## Mutex
Algorytmy wzajemnego wykluczania (w skrócie często nazywane mutex, z ang. mutual exclusion) są używane w przetwarzaniu współbieżnym w celu uniknięcia równoczesnego użycia wspólnego zasobu (np. zmiennej globalnej) przez różne wątki/procesy w częściach kodu zwanych sekcjami krytycznymi. Sekcja krytyczna jest fragmentem kodu, w którym wątki (lub procesy) odwołują się do wspólnego zasobu. Sama w sobie nie jest ani mechanizmem, ani algorytmem wzajemnego wykluczania. Program, proces lub wątek może posiadać sekcje krytyczne bez mechanizmów czy algorytmów implementujących wzajemne wykluczanie.
## Blokująca kolejka
Jest to jeden ze sposobów dzielenia pracy między wątkami. Polega on na tym, że mamy kolejkę która jest współdzielona przez kilka wątków. Jedne z nich do niej piszą inne z niej czytają. Przykładowa implementacja takiej kolejki.

```java
public class BlockingQueue {
    private List queue = new LinkedList();
    private int limit = 10;

    public BlockingQueue(int limit) {
        this.limit = limit;
    }

    public synchronized void enqueue(Object item) throws InterruptedException {
        // Dodanie elementu do kolejki jest synchroniczne. Jeśli kolejka jest zapełniona to wątek będzie oczekiwał.
        while (this.queue.size() == this.limit) {
            // Blokada zostanie dopiera zdjęta gdy zostanie wykonana metoda notifyAll. 
            // Gdy to się stanie to ponownie sprawdzimy czy kolejka nie jest pełna. 
            // Bo w sumie inny wątek może nas uprzedzić. Wiec ważne jest przy stosowaniu wait aby potem
            // sprawdzić czy warunki do działa są spełnione. To jest typowy schemat działania.
            wait();
        }

        if (this.queue.size() == 0) {
            notifyAll();
        }

        this.queue.add(item);
    }

    public synchronized Object dequeue() throws InterruptedException {
        // Jeśli nie mamy nic na kolejsce to czekam aż sie pojawi. 
        // Podobnie jak w przypadku dodawania, po wyjściu z wait zawsze sprawdzam czy warunki
        // do działania są spełnione.
        while (this.queue.size() == 0) {
            wait();
        }

        if (this.queue.size() == this.limit) {
            notifyAll();
        }
		
        // Pobieram element z list.
        return this.queue.remove(0);
    }
}
```
## Pozostałe
### Referencja atomowa
Jest to referencja do zmiennej z której w danym momencie może korzystać tylko jeden wątek. Taką referencję tworzymy w taki sposób:

```java
String initialReference = "the initially referenced string";
AtomicReference atomicReference = new AtomicReference(initialReference);
```

Ustawienie wartości i pobranie wartości.

```java
// Pobranie wartości
String reference = (String) atomicReference.get();

// Ustawienie wartości
atomicReference.set("New object referenced");
```

Porównanie i ustawienie.

```java
String initialReference = "initial value referenced";

AtomicReference<String> atomicStringReference = new AtomicReference<String>(initialReference);

String newReference = "new value referenced";
boolean exchanged = atomicStringReference.compareAndSet(initialReference, newReference);
System.out.println("exchanged: " + exchanged);

exchanged = atomicStringReference.compareAndSet(initialReference, newReference);
System.out.println("exchanged: " + exchanged);
```
### Demon
W naszych aplikacjach mamy dwa typy **wątków**. Jednym z nich są wątki **klienckie** (na przykład wątek **main**), natomiast drugim typem są wątki **demoniczne**. Maszyna wirtualna (**JVM**) kończy swoją pracę wtedy, gdy zakończy się ostatni wątek kliencki (**niedemoniczny**). Oznacza to, że jeśli w naszej aplikacji mamy wątki typu **demon**, aplikacja zamknie się pomimo tego, że jest wykonywana tam jakaś praca. Znając tą cechę, należy pamiętać, aby nie umieszczać tam żadnych zadań związanych z **I/O**!

Dany wątek może zostać oznaczony jako Demon. Oznacza to, że JVM nie będzie czekał aż wątek się zamknie aby zakończyć swoje działanie.

```java
Thread daemonThread = new Thread(job);
daemonThread.setDaemon(true);
daemonThread.start();
```

**Demony** wykorzystywane są przez **JVM** do odśmiecania pamięci czy też do przechowywania **referencji** obiektów do usunięcia. W naszym przypadku możemy umieszczać tam zadania związane z **monitoringiem** aplikacji, który może być zakończony w dowolnym momencie.
### ExecutorService
https://www.baeldung.com/java-executor-service-tutorial

ExecutorService to platforma udostępniana przez JDK, która upraszcza wykonywanie zadań w trybie asynchronicznym. Ogólnie rzecz biorąc, ExecutorService automatycznie udostępnia pulę wątków i interfejs API do przypisywania do niego zadań.

Sam ExecutorService jest interfejsem. Istnieje kilka metod (fabryk) tworzącym odpowiednie instancje.

ExecutorService możemy zainicjować ręcznie przekazując odpowiednie parametry:

```java
ExecutorService executorService =
  new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,
  new LinkedBlockingQueue<Runnable>());
```

Poniżej jest przykład z wykorzystaniem ustalonej ilości wątków.

```java
package com.learning;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * Hello world!
 */
public class App
{
    private static class TaskA implements Runnable {
        private int id;

        public TaskA(int id) {
            this.id = id;
        }

        @Override
        public void run() {
            System.out.println("Run " + id);

            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("Finish " + id);
        }
    }

    public static void main(String[] args ) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        ArrayList<Future<?>> results = new ArrayList<>();

        results.add(executorService.submit(new TaskA(1)));

        Thread.sleep(1000);

        results.add(executorService.submit(new TaskA(2)));

        Thread.sleep(1000);

        results.add(executorService.submit(new TaskA(3)));
        results.add(executorService.submit(new TaskA(4)));

        Thread.sleep(1000);

        results.add(executorService.submit(new TaskA(5)));

        while(true) {
            Thread.sleep(1000);
            Boolean isActive = false;

            for(Future<?> future: results) {
                if (!future.isDone()) {
                    isActive = true;
                }
            }

            if (!isActive) {
                break;
            }
        }

        System.out.println("Koniec");
    }
}
```

ExecutorService zarządza wykonywanymi zadaniami. Jeśli nie ma wątków to zadania czekają na ich przydzielenie.

```
Run 1
Run 2
Run 3
Finish 1
Run 4
Finish 2
Run 5
Finish 3
Finish 4
Finish 5
Koniec
```
### ScheduledExecutorService
https://www.baeldung.com/java-executor-service-tutorial

Uruchamia zadania i przydziela im wątki, dodatkowo pozwala na zdefiniowanie harmonogramu uruchamia zadań. Podobnie jak w przypadku ExecutorService, SheduledExecutorService jest interfejsem z kilkoma implementacjami.

```java
// Z jednym wątkiem
ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();

// Z wieloma wątkami
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);

```

W poniższym przykładzie tworze taki harmonogram z dwa wątkami.

```java
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);

// Wykonaj zadanie 1 po 1 sekundzie
scheduledExecutorService.schedule(new TaskA(1), 1, TimeUnit.SECONDS);

// Wykonaj zadanie 2 po 10 sekundzie
scheduledExecutorService.schedule(new TaskA(2), 3, TimeUnit.SECONDS);

// Wykonaj zadanie 3 po 20 sekundzie
scheduledExecutorService.schedule(new TaskA(3), 6, TimeUnit.SECONDS);

while(true) {
    Thread.sleep(1000);
    System.out.println("wait");
}
```

Wynik działania

```
wait
Run 1
wait
Run 2
wait
wait
wait
wait
Finish 1
Run 3
wait
Finish 2
wait
wait
wait
wait
Finish 3
```

Były dostępne tylko dwa wątki, dlatego zadanie 1, 2 zostały uruchomione  w pierwszej kolejności, zadanie 3 zostało uruchomione zaraz po 1.

Przykład z cyklicznym wywoływaniem zadań.

```java
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);

// Zadanie 1 zostanie wywołane z 1 sekundowym opóźnieniem, następnie będzie wywoływane co 2 sekundy.
scheduledExecutorService.scheduleAtFixedRate(new TaskA(1), 1, 2, TimeUnit.SECONDS);
scheduledExecutorService.scheduleAtFixedRate(new TaskA(2), 2, 2, TimeUnit.SECONDS);
scheduledExecutorService.scheduleAtFixedRate(new TaskA(3), 3, 2, TimeUnit.SECONDS);

while(true) {
    Thread.sleep(1000);
    System.out.println("wait");
}
```

Przy cyklicznym wywoływaniu jeśli określony typ zadania się nie skończy, to maszyna wirtualna będzie czekać przed kolejnym wywołaniem tego samego zadania.

### Operacja `Thread.join`
Za pomocą tej metody możemy ustawić aby wątek oczekiwał aż inny wątek się zakończy.

```java
private static class ThreadJoin extends Thread {
    private final String name;
    private final Thread waitFor;

    private ThreadJoin(String name, Thread waitFor) {
        this.name = name;
        this.waitFor = waitFor;
    }

    @Override
    public void run() {
        System.out.println(String.format("ThreadJoin %s with id %s - run", name, Thread.currentThread().getId()));

        try {
            // Aktualny wątek będzie czekał, aż wątek waitFor się zakończy.
            waitFor.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(String.format("ThreadJoin %s with id %s - run", name, Thread.currentThread().getId()));
    }
}

```

W powyższym przykładzie wątek ThreadJoin będzie czekał aż wątek waitFor się ukończy.
### Operacja `Thread.sleep`
Pozwala na zatrzymanie aktualnego wątku. Zatrzymanie spowoduje, że procesor będzie dostępny dla pozostałych wątków.

```java
private static class ThreadSleep extends Thread {
    private final String name;
    private final int sleep;

    public ThreadSleep(String name, int sleep) {
        this.name = name;
        this.sleep = sleep;
    }

    @Override
    public void run() {
        System.out.println(String.format("ThreadSleep %s with id %s - run", name, Thread.currentThread().getId()));

        try {
            Thread.sleep(sleep);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(String.format("ThreadSleep %s with id %s - finish", name, Thread.currentThread().getId()));
    }
}
```
### Operacja `Thread.yield`
Metoda pozwala na poinformowanie systemy, że aktualny wątek może zwolnić czas procesora dla innych wątków - tymczasowo.

Załóżmy, że mamy dwa zadania do wykonania w dwóch wątkach, a system może wykonywać tylko jeden wątek w jednym czasie. Pierwsze zadanie zajmie 5h, natomiast drugie 5 minut. Jeśli w pierwszej kolejności będzie wykonywane pierwsze zadanie to drugie zadanie będzie oczekiwało 5h tylko po to aby następnie działać przez 5 minut.

Metoda `Thread.yield` informuje system o tym, że wątek może zostać na chwilę zwolniony w innych celach.

**Działanie metody ma charakter sugestywny dla systemu. Każdy system może zachować się inaczej, może również olać tą informacje i zarządzać wątkami po swojemu.**

Poniżej przykład kodu szukającego liczb pierwszych. Między każdym sprawdzeniem wątek informuje o tym, że może zwolnić czas procesora dla innych zadań.

```java
int primaryNumber = 1;

for(int i = 0; i <= max; i++) {
    for(int j = 2; j <= i; j++) {
        if (i % j == 0) {
            if (i == j) {
                primaryNumber = i;
            } else {
                break;
            }
        }
    }

    // Możemy zwolnić na chwile dla innych zadań.
    if (yield) Thread.yield();
}
```

# Kompilacja

## JIT
Czyli tgz. kompilator Just-In-Time. Kod Javy jest kompilowany do tgz. bytecode jest to pośrednia forma zrozumiała dla maszyny wirtualnej JVM ale niekoniecznie dla procesowa, chociaż mogą istnieć procesory, które natywnie wspierają kod zapisany w taki sposób.

W trakcie wykonywania na maszynie wirtualnej bytecode jest tłumaczony na kod natywny. JIT jest to osobny komponent w ramach środowiska uruchomieniowego Javy. Jest on odpowiedzialny za kompilację bytecode w trakcie działania.

![img](../../../.files/jit.png)

Sposób skonfigurowania JITa może mieć istotne znaczenie dla wydajności aplikacji. Są dwa podstawowe kompilatory JIT:

- C1,
- C2.

Kompilator C1 uruchamiamy przez dodanie opcji `-client`. Jest on przeznaczony dla aplikacji klienckich. Kompilator C2 uruchamiamy przez dodanie opcji `-server`.

Istnieje również coś takiego jak kompilacja warstwowa (Tiered compilation) jest to połączenie C1 oraz C2.
### Działanie
W pierwszym kroku JVM pobiera bytecode metody. Kod jest przekazywany do JITa, ten aby poprawnie przetworzyć kod tworzy tgz. `trees` jest to forma zapisu zbliżona do natywnego kodu maszyny. JIT dokunume optymalizacji i natywny kod maszynowy. Proces optymalizacji może odbywać się na kilku wątkach. Istnieje parametr `XcompilationThreads` za pomocą, które możemy ustawić dostępnych wątków.

Cały optymaclizacji składa się z najstępujących kroków:

1. Inlining,
2. Local optimizations,
3. Control flow optimizations,
4. Global optimizations,
5. Native code generation
# Zarządzanie pamięcią
W Javie pamięć jest podzielona na stos oraz stertę. Podobnie jak w C i C++. Na stosie przechowywane są informacje związane z aktualnie przetwarzanymi funkcjami i zmiennymi. Na stercie znajdują się zainicjowane dane.
<img src="../../../.files/Java-Memory-Model.png" alt="img" style="zoom: 80%;" /> 

Pamięć JVM jest podzielona na dwie części: Young Gen, Old Memory.

**Young Gen** - jest zarządzana przez MinorGC. YoungGen składa się z sekcji Eden oraz dwóch sekcji Survivor Memory (S0, S1). Nowe obiekty są zapisywane w przestrzeni Eden, w momencie gdy przestrzeń Eden jest wypełniona M-GC przenosi obiekty do sekcji Survivor Memory (jeden z Sn jest zawsze pusty). Obiekty, które przetrwały po wielu cyklach GC, są przenoszone do przestrzeni pamięci Old memory. Zwykle odbywa się to poprzez ustawienie progu wieku dla obiektów młodego pokolenia, zanim będą mogły znaleźć się w Old Memory.

**Old Memory** - zawiera obiekty który istnieją dość długo, oraz te które zostały przeniesione z młodej pamięci (YoungMemory). Ten segment pamięci jest zarządzany przez MajorGC.W trakcie działania GC (Minor GC, Major GC) wszystkie wątki aplikacyjne zostają zatrzymane. Przetwarzanie Minor GC na ogół trwa dość krótko - bez widocznego wpływu na aplikacje. Działanie Major GC może wpłynąć na działanie aplikacji ze względu na to, że przetwarza wszystkie obiekty. Działanie Major GC powinno być minimalizowane.

**Permanent Generation** - zawiera metadane aplikacji wymagane przez JVM do opisania klas i metod używanych w aplikacji. Perm Gen nie jest częścią Java Heap memory.

Pozostałe obszary:

| Nazwa                 | Opis                                                         |
| --------------------- | ------------------------------------------------------------ |
| Method Area           | Jest częścią Perm Gen, zawiera informacje klasach i metoda   |
| Memory Pool           | Tworzone przez menedżerów pamięci JVM w celu utworzenia puli niezmiennych obiektów, jeśli implementacja je obsługuje. String Pool  jest dobrym przykładem tego rodzaju puli pamięci. Pula pamięci może należeć do Heap lub Perm Gen, w zależności od implementacji menedżera pamięci JVM. |
| Runtime Constant Pool | Zawiera stałe środowiska wykonawczego klasy i metody statyczne. Pula stałych środowiska wykonawczego jest częścią obszaru metody. |
| Java Stack Memory     | Pamięć stosu Java jest używana do wykonywania wątku. Zawierają one wartości specyficzne dla metody, które są krótkotrwałe, oraz odniesienia do innych obiektów w stercie, który jest pobierany z metody. |

## Parametry
W zasadzie mamy dwa główny parametry do zarządzania wielkością przydzielonej pamięci `-Xms, -Xmx`. Parametry możemy ustawić w trakcie uruchamiania polecenia `java -jar -Xms8m -Xmx12m ... ` .

Przeprowadziłem test działania JVM dla powyższych parametrów.

![image-20210901124636615](../../../.files/image-20210901124636615.png) 

`Max` odpowiada parametrowi `-Xmx`. Natomiast pomarańczowa linia odpowiada parametrowi `-Xms` , czyli na początku mamy zaalokowane 8MB wraz ze wzrostem zaalokowanej pamięci rośnie również pomarańczowa linia która oznacza całą zaalokowana pamięć. Alokowanie pamięci trwa do momentu aż zostanie osiągnięty maksymalny poziom 12MB ustawiony przez flagę `-Xmx`. Jeśli brakuje miejsca to JVM generuje wyjątek **java.lang.OutOfMemoryError** z komunikatem **Java heap space**.

| Przełącznik      | Opis                                                         |
| :--------------- | :----------------------------------------------------------- |
| -Xms             | Ustawia inicjalną wielkość sterty.                           |
| -Xmx             | Ustawia maksymalną wielkość sterty.            |
| -Xss             | Pozwala na ustawienie wielkości stosu dla wątku   |
| -Xmn             | For setting the size of the Young Generation, rest of the space goes for Old Generation. |
| -XX:PermGen      | For setting the initial size of the Permanent Generation memory |
| -XX:MaxPermGen   | For setting the maximum size of Perm Gen                     |
| -X:SurvivorRatio | For providing ratio of Eden space and Survivor Space, for example if Young Generation size is 10m and VM switch is -XX:SurvivorRatio=2 then 5m will be reserved for Eden Space and 2.5m each for both the Survivor spaces. The default value is 8. |
| -XX:NewRatio     | For providing ratio of old/new generation sizes. The default value is 2. |


## GC
Java zawiera kilka typów mechanizm GC:

| Typ                                   | Opcja                     | Opis                                                         |
| ------------------------------------- | ------------------------- | ------------------------------------------------------------ |
| Serial GC                             | `-XX:+UseSerialGC`        | Dane są przenoszone z obszaru YG do OG                       |
| Parallel GC                           | `-XX:+UseParallelGC`      | Działa podobnie jak Serial, tylko wykorzystuje dodatkowe wątki przy przenoszeniu z YG. Liczbe wątków regulujemy za pomocą flagi `-XX:ParallelGCThreads=n` |
| Parallel Old GC                       | `-XX:+UseParallelOldGC`   | Dzieła tak jak Parallel GC, tylko w obu przestrzeniach YG i OG |
| Concurrent Mark Sweep (CMS) Collector | `-XX:+UseConcMarkSweepGC` | CMS Collector jest również określany jako kolektor współbieżny o niskiej przerwie. Robi wyrzucanie elementów bezużytecznych dla starej generacji. Moduł zbierający CMS stara się zminimalizować przerwy wynikające z wyrzucania elementów bezużytecznych, wykonując większość operacji wyrzucania elementów bezużytecznych z wątkami aplikacji. Kolektor CMS w młodym pokoleniu korzysta z tego samego algorytmu co kolektor równoległy. Ten pojemnik na śmieci nadaje się do responsywnych aplikacji, w których nie stać nas na dłuższe czasy przerwy. Możemy ograniczyć liczbę wątków w kolektorze CMS za pomocą `-XX:ParallelCMSThreads=n` |
| G1 Garbage Collector                  | `-XX:+UseG1GC`            | Działa inaczej niż poprzednie, nie dzieli pamięci na obszary YG, OG a na równe sektory. Działa równolegle. Dostępny jest od Java 7. |
## Analiza pamięci
Java udostępnia mechanizmy do zrzucania pamięci. Potocznie się to nazywa HeapDump, dosłownie zrzut sterty. Zrzut pamięci można pozyskać na kilka sposobów.

Za pomocą poleceń `jmap, jcmd`. **Polecenie `jcmd` jest dość fajne i rozbudowane i zawiera o wiele więcej opcji diagnostycznych.**

PID polecenia możemy pobrać poleceniem `jcmd` nie podając parametrów.

```shell
jmap -dump:live,format=b,file=/tmp/dump.hprof 12587 # testowałem działa.
jcmd <pid> GC.heap_dump <file-path>
jcmd 12587 GC.heap_dump /tmp/dump.hprof
```

Udostępniają to również takie narzędzia jak VisualWM i jConsole. Zrzut pamięci można wykonać również z poziomu kodu.

```java
public static void dumpHeap(String filePath, boolean live) throws IOException {
    MBeanServer server = ManagementFactory.getPlatformMBeanServer();
    HotSpotDiagnosticMXBean mxBean = ManagementFactory.newPlatformMXBeanProxy(
      server, "com.sun.management:type=HotSpotDiagnostic", HotSpotDiagnosticMXBean.class);
    mxBean.dumpHeap(filePath, live);
}
```

### Automatyczny zrzut pamięci
Możliwe jest ustawienie aby został wykonany zrzut pamięci jeśli wystąpi błąd alokacji pamięci (`OutOfMemory`). Dodajemy parametr  przy wywołaniu `-XX:+HeapDumpOnOutOfMemoryError`. W momencie gdy JVM próbuje alokować więcej niż zostało mu przydzielone (parametr `-Xmx`) to zostanie wygenerowany plik ze zrzutem pamięci. Plik standardowo ma nazwę `java_pid1{PID}.hprof`.

Lista parametrów:

| Opcja                                              | Opis                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| -XX:+HeapDumpOnOutOfMemoryError                    | Informuje JVM o tym, że jeśli wystąpi błąd to ma zrzucić stertę do pliku. |
| -XX:HeapDumpPath=./java_pid{pid}.hprof             | Ścieżka do pliku. Słowo {pid} zostaje zastąpione identyfikatorem procesu. |
| -XX:OnOutOfMemoryError="< cmd args >;< cmd args >" | Jakie polecenie ma zostać wykonane w wyniku błędu.           |
| -XX:+UseGCOverheadLimit                            | Określa sposób zachowania się GC, kiedy błąd                 |

Tak wygenerowany plik można analizować różnymi programami np. **MemoryAnalyzer**.

**Wykonanie polecenia po błędzie**

Mamy również parametr `OnOutOfMemoryError` może zostać np. użyta do ponownego uruchomienia serwera w wyniku błędu.

```
-XX:OnOutOfMemoryError="shutdown -r"
```

## Cykle GC
Jednym z podstawowych problemów jakie musi rozwiązać GC, jest określenie czy dany obiekt jest potrzebny. Do określenia przydatności obiektu służą różne algorytmy: 

- zliczanie referencji (reference counting), 
- trasowanie drzewa obiektów (trace GCs).

Algorytm zliczania referencji polega na zliczaniu referencji, od wołań do obiektu. Jeśli nie ma takich referencji to obiekt może zostać usunięty. Niestety algorytm nie porazi sobie gdy mamy cykliczną referencję tzn. obiekt A -> B, B -> A, a oba nie są powiązane z innymi obiektami.

![Unreachable List](../../../.files/unreachable-list-1.png)

Algorytm trasowania drzewa obiektów, polega na tym, że GC od pewnych obiektów zwanych korzeniami przechodzi przez drzewo referencji i jeśli dany obiekt nie jest dostępnym w drzewie to GC uznaje go za niepotrzebne i może go usunąć.  GC trasowanie rozpoczyna od obiektów tgzn. GC Roots. 

![Tracing Collector](../../../.files/tracing.png)
## Implementacje GC
### Serial Garbage Collector
Jest to najprostsza implementacja GC, ponieważ zasadniczo działa z pojedynczym wątkiem. W rezultacie ta implementacja GC zawiesza wszystkie wątki aplikacji podczas działania. Dlatego nie jest dobrym pomysłem używanie go w aplikacjach wielowątkowych, takich jak środowiska serwerowe.

Serial GC jest wybierany dla większości aplikacji, które nie mają krótkich wymagań działają na komputerach klienta. Aby włączyć Serial Garbage Collector, możemy użyć następującego argumentu:

```sh
java -XX:+UseSerialGC -jar Application.java
```
### Parallel Garbage Collector
Jest to domyślny GC dla JVM i czasami nazywany **Throughput Collectors**. W przeciwieństwie do Serial Garbage Collector używa wielu wątków do zarządzania przestrzenią sterty. Ale zamraża również inne wątki aplikacji podczas wykonywania GC.

Jeśli użyjemy tego GC, możemy określić maksymalną liczbę wątków wyrzucania elementów bezużytecznych oraz czas pauzy, przepustowość i ślad (rozmiar sterty).

Liczbę wątków modułu odśmiecania pamięci można kontrolować za pomocą opcji wiersza polecenia:

```
-XX:ParallelGCThreads=<N>
```

Maksymalny docelowy czas pauzy (przerwa [w milisekundach] między dwoma GC) jest określany za pomocą opcji wiersza polecenia:

```
-XX:MaxGCPauseMillis=<N>
```

Czas spędzony na wyrzucaniu elementów bezużytecznych w porównaniu z czasem spędzonym poza wyrzucaniem elementów bezużytecznych jest nazywany docelowym maksymalną przepustowością i można go określić za pomocą opcji wiersza polecenia:

```
-XX:GCTimeRatio=<N>
```

Maksymalny ślad sterty (ilość pamięci sterty, jakiej wymaga program podczas działania) jest określana za pomocą opcji:

```
-Xmx<N>
```

Aby włączyć Parallel Garbage Collector, możemy użyć następującego argumentu:

```
java -XX:+UseParallelGC -jar Application.java
```
### CMS Garbage Collector
Implementacja Concurrent Mark Sweep (CMS) używa wielu wątków do czyszczenia pamięci. Jest przeznaczony dla aplikacji, które preferują krótsze przerwy i które mogą sobie pozwolić na współdzielenie zasobów procesora GC, gdy aplikacja jest uruchomiona.

Mówiąc najprościej, aplikacje korzystające z tego typu GC reagują przeciętnie wolniej, ale nie przestają odpowiadać w trakcie zwalniania pamięci.

Warto zauważyć, że ponieważ ten GC jest współbieżny, wywołanie jawnego zwolnienia pamięci, takiego jak użycie `System.gc()` podczas pracy współbieżnego procesu, spowoduje awarię/przerwanie trybu współbieżnego.

Jeśli GC spędzi więcej niż 98% czasu na zwalnianiu pamięci, a zostanie odzyskane tylko 2% to GC zwróci wyjątek `OutOfMemoryError`. Można to zmienić za pomocą opcji `-XX:-UseGCOverheadLimit`.

Aby włączyć Garbage Collector CMS, możemy użyć następującej flagi:

```
java -XX:+UseParNewGC -jar Application.java
```

Już od Javy9 ten GC został oznaczony jako przestarzały, a w Javie14 całkowicie usunięty.

```
>> java -XX:+UseConcMarkSweepGC --version
Java HotSpot(TM) 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated 
in version 9.0 and will likely be removed in a future release.
java version "9.0.1"

>> java -XX:+UseConcMarkSweepGC --version
OpenJDK 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGC; 
support was removed in 14.0
openjdk 14 2020-03-17
```
### G1 Garbage Collector
G1 (Garbage First) Garbage Collector jest przeznaczony dla aplikacji działających na maszynach wieloprocesorowych z dużą ilością pamięci. Jest dostępny od wersji JDK7 Update 4 oraz w nowszych wersjach.

Kolektor G1 zastąpi kolektor CMS, ponieważ jest bardziej wydajny.

W przeciwieństwie do innych kolektorów kolektor G1 dzieli stertę na zestaw równych regionów sterty, z których każdy stanowi ciągły zakres pamięci wirtualnej. Podczas wykonywania zbierania śmieci, G1 pokazuje jednoczesną fazę globalnego znakowania (tj. fazę 1 znaną jako Marking), aby określić żywotność obiektów w całej stercie.

Po zakończeniu fazy znakowania G1 wie, które regiony są w większości puste. Najpierw zbiera się w tych obszarach, co zwykle daje znaczną ilość wolnej przestrzeni (tj. faza 2 znana jako Sweeping). Dlatego ta metoda zbierania śmieci nazywa się Garbage-First.

Aby włączyć G1 Garbage Collector, możemy użyć następującego argumentu:

```
java -XX:+UseG1GC -jar Application.java
```
### Z Garbage Collector
ZGC (Z Garbage Collector) to skalowalny GC o niskich opóźnieniach, który zadebiutował w Javie 11 jako eksperymentalna opcja dla Linuksa. JDK 14 wprowadził ZGC pod systemy operacyjne Windows i macOS. ZGC uzyskał status produkcyjny od Javy 15 i nowszych.

ZGC wykonuje wszystkie kosztowne prace jednocześnie, bez zatrzymywania wykonywania wątków aplikacji na dłużej niż 10 ms, co czyni go odpowiednim dla aplikacji wymagających małych opóźnień. Wykorzystuje bariery obciążenia z kolorowymi wskaźnikami do wykonywania współbieżnych operacji, gdy wątki są uruchomione i są używane do śledzenia użycia sterty.

Kolorowanie referencyjne (kolorowe wskaźniki) jest podstawową koncepcją ZGC. Oznacza to, że ZGC używa pewnych bitów (bitów metadanych) odniesienia do oznaczenia stanu obiektu. Obsługuje również stosy o wielkości od 8 MB do 16 TB. Co więcej, czasy pauzy nie zwiększają się wraz z rozmiarem sterty, zestawu live-set lub root-set.

Podobnie jak G1, Z Garbage Collector dzieli stertę na partycje, z wyjątkiem tego, że regiony sterty mogą mieć różne rozmiary.

Aby włączyć Z Garbage Collector, możemy użyć następującego argumentu w wersjach JDK niższych niż 15:

```
java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC Application.java
```

Od Javy15

```
java -XX:+UseZGC Application.java
```
# XML
JAXP - Java API for XML Processing, jest to nazwa API Javy do pracy z danymi w formacie XML. 

W ramach API udostępnione sa trzy sposoby (mechanizmy) przetwarzania XML:

- DOM (Document Object Model),
- SAX (Simple API for XML),
- StAX (Streaming API for XML).

Dodatkowo XSLT który zawiera mechanizmy transformacji XML na różne formaty. XSLT jest w paciecie `javax.xml.transform`.
### DOM
Metoda przetwarzania danych polegająca na pracy z danymi XML przetwarzanymi  w strukturze drzewa. Cały dokument jest prasowany i umieszczany w pamięci.

Podstawowe elementy

| Element | Opis |
| ------- | ---- |
| Node    |      |
| Element |      |
#### Utworzenie dokumentu
Dokument jest tworzony za pomocą `javax.xml.parsers.DocumentBuilder`, ten jest tworzony za pomocą `javax.xml.parsers.DocumentBuilderFactory`.

```java
// Zainicjowanie DocumentBuildera
DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
documentBuilderFactory.setNamespaceAware(true);

DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();

// Utworzenie dokumentu
Document document = documentBuilder.newDocument();
```

Na tak utworzonej instancji możemy dodawać nowe elementy.

```java
Element usersElement = document.createElement("users");
usersElement.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:foo", "http://foo.com");

document.appendChild(usersElement);

usersElement.appendChild(createUserElement(document, "Jan", "Kowalski"));
usersElement.appendChild(createUserElement(document, "Krystian", "Wrona"));
usersElement.appendChild(createUserElement(document, "Paweł", "Kubal"));
```

Metota `createUserElement` tworzony element.

```java
Element user = document.createElementNS("http://foo.com", "foo:user");

user.appendChild(createElement(document, "id", UUID.randomUUID().toString()));
user.appendChild(createElement(document, "firstName", firstName));
user.appendChild(createElement(document, "phone", phone));

return user;
```
#### Wczytanie dokumentu z pliku
Istnieje możliwość utworzenia obiektu `org.w3c.dom.Document` na podstawie pliku xml.

Dokument można wczytać za pomocą metody `javax.xml.parsers.DocumentBuilder#parse(java.io.File)`

```java
DocumentBuilder documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

Document document = documentBuilder.parse(new File(file));

return document;
```
### SAX
Generuje XML o wiele szybciej i wydajniej niź DOM, sam proces generowania jest trudniejszy.

```java
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;

import org.xml.sax.helpers.AttributesImpl;

/** @author Mark A. Ziesemer */
public class SAXXmlWriter{

  public static void main(String[] args) throws Exception{
    TransformerFactory tf = TransformerFactory.newInstance();
    if(!tf.getFeature(SAXTransformerFactory.FEATURE)){
      throw new RuntimeException(
        "Did not find a SAX-compatible TransformerFactory.");
    }
    SAXTransformerFactory stf = (SAXTransformerFactory)tf;
    TransformerHandler th = stf.newTransformerHandler();
    th.setResult(new StreamResult(System.out));

    th.startDocument();

    AttributesImpl fieldAttrs = new AttributesImpl();
    fieldAttrs.addAttribute("", "", "Name", "", "Value");

    th.startElement("", "", "Root", fieldAttrs);
    th.startElement("", "", "Child", null);
    th.endElement("", "", "Child");
    th.endElement("", "", "Root");
    th.endDocument();
  }
}
```
### StAX
Jest to metoda którą można zaklasyfikować mniejwięcej pomiędzy `DOM` a `SAX`. Która jest podobna do `SAX`, ale wydajniejsza. `DOM` opiera się na tworzeniu dokumentu w pamięci.

```java
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;

/** @author Mark A. Ziesemer */
public class StAXSample{

  public static void main(String[] args) throws Exception{
    XMLStreamWriter xsw = XMLOutputFactory.newInstance()
      .createXMLStreamWriter(System.out);
    xsw.writeStartDocument();
    xsw.writeStartElement("Root");
    xsw.writeAttribute("Name", "Value");
    xsw.writeEmptyElement("Child");
    xsw.writeEndElement();
    xsw.writeEndDocument();
    xsw.close();
  }
}
```
### Transformacje
Java udostępnia pakiet `javax.xml.transform` zawiera on różnego rodzaju mechanizmu pozwaljące na dokonywanie transformacji na danych w formacie XML.

W transformacji używane są dwa typy: `Source, Result`.

W pakiecie dostepne są implementacje:

| Typ                                       | Opis                                    |
| ----------------------------------------- | --------------------------------------- |
| `javax.xml.transform.dom.DOMResult`       | Do przetwarzania `org.w3c.dom.Document` |
| `javax.xml.transform.dom.DOMSource`       |                                         |
| `javax.xml.transform.sax.SAXResult`       |                                         |
| `javax.xml.transform.sax.SAXSource`       |                                         |
| `javax.xml.transform.stax.StAXResult`     |                                         |
| `javax.xml.transform.stax.StAXSource`     |                                         |
| `javax.xml.transform.stream.StreamResult` |                                         |
| `javax.xml.transform.stream.StreamSource` |                                         |
#### Przykładowe transformacje
Przy transformacji z Documentu na StreamResult.

```java
StringWriter stringWriter = new StringWriter();

Transformer transformer = TransformerFactory.newInstance().newTransformer();

transformer.transform(new DOMSource(document), new StreamResult(stringWriter));

return stringWriter.toString();
```

Poniżej jest przykład transformacji pliku Document wczytanego z pliku.

```java
Transformer transformer = TransformerFactory.newInstance().newTransformer();

DocumentBuilder documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
Document document = documentBuilder.parse(new File("users.xml"));

transformer.setOutputProperty(OutputKeys.INDENT, "yes");
transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "10");

FileOutputStream fileOutputStream = new FileOutputStream("users-i.xml");

transformer.transform(new DOMSource(document), new StreamResult(fileOutputStream));
```
### JAXB
Jest to biblioteka pozwalająca na generowanie XML na postawie obiektów.
#### Generowanie XML
XML jest generowany na podstawie adnotacji. Dzięki adnotacją JAXB wie w jaki sposób zapisać obiekt oraz jak go odczytać.

Poniżej mamy przykład obiektu `Book` oraz `Bookstore`.

```java
package de.vogella.xml.jaxb.model;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;

@XmlRootElement(name = "book")
// If you want you can define the order in which the fields are written
// Optional
@XmlType(propOrder = { "author", "name", "publisher", "isbn" })
public class Book {

    private String name;
    private String author;
    private String publisher;
    private String isbn;

    // If you like the variable name, e.g. "name", you can easily change this
    // name for your XML-Output:
    @XmlElement(name = "title")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getPublisher() {
        return publisher;
    }

    public void setPublisher(String publisher) {
        this.publisher = publisher;
    }

    public String getIsbn() {
        return isbn;
    }

    public void setIsbn(String isbn) {
        this.isbn = isbn;
    }
}
```

oraz klasa `Bookstore`.

```java
package de.vogella.xml.jaxb.model;

import java.util.ArrayList;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlRootElement;

//This statement means that class "Bookstore.java" is the root-element of our example
@XmlRootElement(namespace = "de.vogella.xml.jaxb.model")
public class Bookstore {

    // XmLElementWrapper generates a wrapper element around XML representation
    @XmlElementWrapper(name = "bookList")
    // XmlElement sets the name of the entities
    @XmlElement(name = "book")
    private ArrayList<Book> bookList;
    private String name;
    private String location;

    public void setBookList(ArrayList<Book> bookList) {
        this.bookList = bookList;
    }

    public ArrayList<Book> getBooksList() {
        return bookList;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }
}
```

oraz zapisanie i odczytanie.

```java
JAXBContext context = JAXBContext.newInstance(Bookstore.class);
Marshaller m = context.createMarshaller();
m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);

// Write to System.out
m.marshal(bookstore, System.out);

// Write to File
m.marshal(bookstore, new File(BOOKSTORE_XML));

// get variables from our xml file, created before
System.out.println();
System.out.println("Output from our XML File: ");
Unmarshaller um = context.createUnmarshaller();
Bookstore bookstore2 = (Bookstore) um.unmarshal(new FileReader(
    BOOKSTORE_XML));
ArrayList<Book> list = bookstore2.getBooksList();
for (Book book : list) {
    System.out.println("Book: " + book.getName() + " from "
                       + book.getAuthor());
}
```
#### Adnotacje
| ANNOTATION           | SCOPE            | DESCRIPTION                                                  |
| -------------------- | ---------------- | ------------------------------------------------------------ |
| `@XmlRootElement`    | Class, Enum      | Defines the XML root element. Root Java classes need to be registered with the JAXB context when it is created. |
| `@XmlAccessorType`   | Package, Class   | Defines the fields and properties of your Java classes that the JAXB engine uses for binding. It has four values: `PUBLIC_MEMBER`, `FIELD`, `PROPERTY` and `NONE`. |
| `@XmlAccessorOrder`  | Package, Class   | Defines the sequential order of the children.                |
| `@XmlType`           | Class, Enum      | Maps a Java class to a schema type. It defines the type name and order of its children. |
| `@XmlElement`        | Field            | Maps a field or property to an XML element                   |
| `@XmlAttribute`      | Field            | Maps a field or property to an XML attribute                 |
| `@XmlTransient`      | Field            | Prevents mapping a field or property to the XML Schema       |
| `@XmlValue`          | Field            | Maps a field or property to the text value on an XML tag.    |
| `@XmlList`           | Field, Parameter | Maps a collection to a list of values separated by space.    |
| `@XmlElementWrapper` | Field            | Maps a Java collection to an XML wrapped collection          |

Adnotacja `@XmlTransient` - adnotacja wyklucza element z eksportu. Jest t szczególne przydatne np. gdy polem jest obiekt a by nie chcemy aby ten obiekt został wyeksportowany. Miałem strukturę drzewa, w obiekcie było pole `parent` które wskazywało na rodzica. Przez to, że pole nie zostało wykluczone powstawał cykl między rodzicem a dzieckiem. Pole `parent`musiałem zamienić na `parentId`  na potrzeby eksportu.
### JAX-WS
Jest to biblioteka dostarczająca mechanizm do komunikacji za pomocą Soap.
### Typy danych
#### EncryptedData
Jest to typ przechowujący zaszyfrowane dane.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<xenc:EncryptedData Id="_91246bf054b36490cd02e4933f67111b" Type="http://www.w3.org/2001/04/xmlenc#Element" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
	<xenc:EncryptionMethod Algorithm="http://www.w3.org/2009/xmlenc11#aes256-gcm" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"/>
    <ds:KeyInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
        <xenc:EncryptedKey Id="_74259e8bdbe657b6120379ae0f3f2f19" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
            <xenc:EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
                <ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1" xmlns:ds="http://www.w3.org/2000/09/xmldsig#"/>
            </xenc:EncryptionMethod>
            <ds:KeyInfo>
                <ds:KeyValue>
                    <ds:RSAKeyValue>
                        <ds:Modulus>...</ds:Modulus>
                        <ds:Exponent>...</ds:Exponent>
                    </ds:RSAKeyValue>
                </ds:KeyValue>
            </ds:KeyInfo>
                <xenc:CipherData xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
                    <xenc:CipherValue>...</xenc:CipherValue>
                </xenc:CipherData>
        </xenc:EncryptedKey>
    </ds:KeyInfo>
    <xenc:CipherData xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
        <xenc:CipherValue>...</xenc:CipherValue>
    </xenc:CipherData>
</xenc:EncryptedData>

```

## XML
### Security
#### EncryptedData
Jest to sposób szyfrowania elementów XML.


### SOAP
Java wspiera komunikacje w standardzie SOAP. Główne mechanizmy są umieszczone w pakiecie `javax.xml.soap`. Zawiera on takie klasy jak:

| Klasa        | Opis                                                         |
| ------------ | ------------------------------------------------------------ |
| SOAPMessage  | Obiekt reprezentujący komunikat SOAP.                        |
| SOAPEnvelope | Obiekt reprezentujący "kopertę" komunikatu SOAP              |
| SOAPHeader   | Obiekt reprezentujący nagłówek komunikat SOAP                |
| SOAPBody     | Obiekt reprezentujący ciało komunikat SOAP                   |
| QName        | Jest to "qualified name", czy cała nazwa rezem z informacja o przestrzeni nazwa i prefixie. Na nazwę skłąda się przestrzeń nazwa, localPart, prefix. |
#### Stworzenie komunikatu SOAP
W pierwszym kroku tworzymy `SOAPMessage`. Jest to reprezentacja komunikatu SOAP.

```java
private static final String FOO_NS = "http://foo.com";
private static final String SECURITY_NS = "http://security.com";
private static final String SECURITY_DIGEST_NS = "http://security.digets.com";
private static final String XMLNS_NS = "http://www.w3.org/2000/xmlns/";
private static final String SOAP_NS = "http://schemas.xmlsoap.org/soap/envelope/";

// Tworzymy wiadomość
SOAPMessage soapMessage = MessageFactory.newInstance().createMessage();
```

Natepnie pobieramy referencje do elementów `SOAPBody, SOAPHeader, SOAPEnvelope`.

```java
// Pobieramy referencje do elementów SOAPa
SOAPEnvelope soapEnvelope = soapMessage.getSOAPPart().getEnvelope();
SOAPHeader soapHeader = soapMessage.getSOAPHeader();
SOAPBody soapBody = soapMessage.getSOAPBody();
```

Za pomocą tych referencji możemy tworzyć poszczególne elementy komunikatu SOAP.

Poszczególne przestrzenie możemy ustawić za pomoca metody `setAttributeNS`.

```java
soapEnvelope.setAttributeNS(XMLNS_NS, "xmlns:foo", FOO_NS);
soapEnvelope.setAttributeNS(XMLNS_NS, "xmlns:ds", SECURITY_DIGEST_NS);
soapEnvelope.setAttributeNS(XMLNS_NS, "xmlns:sec", SECURITY_NS);
soapEnvelope.setAttributeNS(XMLNS_NS, "xmlns:soap", SOAP_NS);
```

Definiowanie elementów komunikatu

```java
// Definiowanie nagłówka
SOAPHeaderElement soapHeaderElement = soapHeader.addHeaderElement(new QName(SECURITY_NS, "Security", "sec"));

SOAPElement signature  = soapHeaderElement.addChildElement(new QName(SECURITY_DIGEST_NS, "Signature", "ds"));
signature.setTextContent("fa5e6434-757d-4ddc-b6e8-d2bcbab7d2ca");

// Dodanie body
SOAPBodyElement getUserElement = soapBody.addBodyElement(new QName(FOO_NS, "getUser", "foo"));

// Utworzenie elementu za pomocą QName. W takiej sytuacji podanie przestrzeni jest wymagane.
getUserElement.addChildElement(new QName(FOO_NS, "arg-a", "foo")).setTextContent("1");

// Utworzenie elementu za pomocą metody addChildElement, podaje nazwę i prefix.
getUserElement.addChildElement("arg-b", "foo").setTextContent("2");

// Utworzenie elementu za pomocą metody addChildElement, podaje nazwę i prefix i przestrzeń
getUserElement.addChildElement("arg-b", "foo-t", FOO_NS).setTextContent("3");
```

Element dodajemy ogólną metodą `addChildElement`, można ją wywołać na kilka sposobów:

- za pomocą obiektu `QName`, wtedy możemy podać przestrzeń, localPart, prefix
- bezpośrednio przez przekazanie parametrów.

Należy zwrócić uwage na defniowanie przestrzeni i prefiksów. Jeśli prefix został już zdefniowany to nie zostanie utworzona defnicja na elemencie. Jeśli dla danego prefiksu nie została zdefniowana przestrzeń to definicja zostanie dodana na elemencie, tak jak w przypadku elementu `foo-t:arg-b`.

```xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<SOAP-ENV:Envelope
	xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
	xmlns:ds="http://security.digets.com"
	xmlns:foo="http://foo.com"
	xmlns:sec="http://security.com"
	xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
	<SOAP-ENV:Header>
		<sec:Security>
			<ds:Signature>fa5e6434-757d-4ddc-b6e8-d2bcbab7d2ca</ds:Signature>
		</sec:Security>
	</SOAP-ENV:Header>
	<SOAP-ENV:Body>
		<foo:getUser>
			<foo:arg-a>1</foo:arg-a>
			<foo:arg-b>2</foo:arg-b>
			<foo-t:arg-b
				xmlns:foo-t="http://foo.com">3
			</foo-t:arg-b>
		</foo:getUser>
	</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
```
#### Wczytanie komunikat SOAP z pliku
Komunikat SOAP można wczytać za pośrednictwem implementaji Document do operacji na plikach XML.

```java
// Tworzymy wiadomość
SOAPMessage soapMessage = MessageFactory.newInstance().createMessage();// 1

Document soapMessageDocument = loadDocument("/get-document.soap.xml");// 2

soapMessage.getSOAPPart().setContent(new DOMSource(soapMessageDocument));// 3
```

W pierwszym kroku tworzony jest SOAPMessage, astępnie wczytuje dokument, w ostatnim korku ustawiam treść za pomocą `DOMSource`.

Poniżej sposób w jaki wczytuje dokument (zostalo to opisane w rozdziale poświęconym obłudze XML w Javie).

```java
private Document loadDocument(String resource) throws ParserConfigurationException, IOException, SAXException {
    DocumentBuilder documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

    return documentBuilder.parse(this.getClass().getResourceAsStream(resource));
}

```
### WSS - WSSJ4
http://ws.apache.org/wss4j/user_guide.html
#### Krypto konfiguracja
Biblioteka do działania potrzebuje konfiguracji kryptograficznej. Konfiguracja może zostać zainicjowana za pomocą pliku właściwości `.properties` lub przez klasę `Properties`.

```java
Properties cryptoProperties = new Properties();

cryptoProperties.put("org.apache.ws.security.crypto.provider", "org.apache.ws.security.components.crypto.Merlin");
cryptoProperties.put("org.apache.ws.security.crypto.merlin.file", "src/main/resources/client.jks");
cryptoProperties.put("org.apache.ws.security.crypto.merlin.keystore.alias", "1");
cryptoProperties.put("org.apache.ws.security.crypto.merlin.keystore.password", "testte");
cryptoProperties.put("org.apache.ws.security.crypto.merlin.keystore.private.password", "test");

return CryptoFactory.getInstance(cryptoProperties);
```

Klucze konfiguracyjne:

```
General properties WSS4J specific provider used to create Crypto instances.
Defaults to "org.apache.wss4j.common.crypto.Merlin".
${PREFIX}.provider

The location of an (X509) CRL file to use.
${PREFIX}.merlin.x509crl.file

Merlin Keystore Properties
The provider used to load keystores. Defaults to installed provider.
${PREFIX}.merlin.keystore.provider

The provider used to load certificates. Defaults to keystore provider.
${PREFIX}.merlin.cert.provider

The location of the keystore
${PREFIX}.merlin.keystore.file

The password used to load the keystore. Default value is "security".
${PREFIX}.merlin.keystore.password

Type of keystore. Defaults to: java.security.KeyStore.getDefaultType())
${PREFIX}.merlin.keystore.type

The default keystore alias to use, if none is specified.
${PREFIX}.merlin.keystore.alias 

The default password used to load the private key.
${PREFIX}.merlin.keystore.private.password

Merlin TrustStore properties Whether or not to load the CA certs in
${java.home}/lib/security/cacerts (default is false)
${PREFIX}.merlin.load.cacerts

The location of the truststore
${PREFIX}.merlin.truststore.file

The truststore password. Defaults to "changeit".
${PREFIX}.merlin.truststore.password

The truststore type. Defaults to: java.security.KeyStore.getDefaultType().
${PREFIX}.merlin.truststore.type

WSS4J 2.1.5 The provider used to load truststores. By default it’s the same as
the keystore provider. Set to an empty value to force use of the JRE’s default
provider.
${PREFIX}.merlin.truststore.provider
```
#### Podpisanie komunikatu
Implementacja podpisu dostarczona jest w bibliotece WSS4J. Poniżej przykładowa implementacja.

```java
SOAPMessage soapMessage = Util.loadSoapMessageFromFile("/get-document.soap.xml");
// Document soapMessageDocument = Util.resolveSoapMessageToDocument(soapMessage);

Document soapMessageDocument = soapMessage.getSOAPPart().getEnvelope().getOwnerDocument();

System.out.println(Util.convertDocumentToString(soapMessageDocument));

Crypto crypto = loadCryptoConfiguration();

WSSecHeader secHeader = new WSSecHeader(soapMessageDocument);

secHeader.insertSecurityHeader();

WSSecSignature sign = new WSSecSignature(secHeader);

sign.setUserInfo("1", "test");

// Sposób przekazywania klucza
// sign.setKeyIdentifierType(WSConstants.X509_KEY_IDENTIFIER);
sign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
// sign.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
// sign.setKeyIdentifierType(WSConstants.SKI_KEY_IDENTIFIER);
// sign.setKeyIdentifierType(WSConstants.THUMBPRINT_IDENTIFIER);
// sign.setKeyIdentifierType(WSConstants.ENCRYPTED_KEY_SHA1_IDENTIFIER);
// sign.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);

// sign.setUseSingleCertificate(true);
sign.setDigestAlgo(DigestMethod.SHA256);

// Timestamp
WSSecTimestamp timestamp = new WSSecTimestamp(secHeader);
timestamp.setTimeToLive(60);

timestamp.build();

sign.build(crypto);
```
#### Werfikacja komunikatu
```java
WSSecurityEngine securityEngine = new WSSecurityEngine();

securityEngine.processSecurityHeader(soapMessageDocument, null, null, crypto);
```
#### Szyfrowanie komunikatu
```java
SOAPMessage soapMessage = Util.loadSoapMessageFromFile("/get-document.soap.xml");

Document soapMessageDocument = soapMessage.getSOAPPart().getEnvelope().getOwnerDocument();

System.out.println(Util.convertDocumentToString(soapMessageDocument));

Crypto crypto = loadCryptoConfiguration();

WSSecHeader secHeader = new WSSecHeader(soapMessageDocument);
secHeader.insertSecurityHeader();

WSSecEncrypt builder = new WSSecEncrypt(secHeader);

builder.setUserInfo("1", "test");
builder.setKeyIdentifierType(WSConstants.X509_KEY_IDENTIFIER);

// builder.setSymmetricEncAlgorithm(WSConstants.TRIPLE_DES);
builder.setSymmetricEncAlgorithm(WSConstants.AES_256_GCM);

// KeyGenerator keyGen = KeyUtils.getKeyGenerator(WSConstants.TRIPLE_DES);

// Klucz można wygenerować recznie, inaczej zostanie automatycznie wygenerowany
// KeyGenerator keyGen = KeyUtils.getKeyGenerator(WSConstants.AES_256_GCM);
// builder.setEphemeralKey(keyGen.generateKey().getEncoded());

Document encryptedDoc = builder.build(crypto);

System.out.println(Util.convertDocumentToString(soapMessageDocument));
```

# Testy
W rozdziale opisuje przypadki implementacji testów/testowania w środowisku Javy. Duża cześć testów jest napisana z wykorzystaniem Springa. Biblioteki i narzędzia wykorzystywane przy testach.


## Frameworki
### JUnit 4
![image-20210831085909408](../../../.files/image-20210831085909408.png)

#### Adnotacje
##### `@Rule`
JUnit w wersji 4 dostarcza mechanizm za pomocą którego możemy wykonać określoną regułę w trakcie wykonywania testów. Jest to w pewnym sensie AOP dla testów jednostkowych. Działa to w taki sposób, że w teście jednostkowym tworzymy pole publiczne i oznaczamy je adnotacją `@Rule`. implementacja tej reguły musi implementować interfejs `TestRule`. Składa się on z metody `org.junit.rules.TestRule#apply`.

```java
public interface TestRule {
    Statement apply(Statement base, Description description);
}
```

Do reguły w trakcie wykonywania testu przekazywany jest `Statement` który reprezentuje uruchomiony test. Dobrym przykładem jest zarządzanie zasobami. Często potrzebujemy w trakcie działania testu utworzyć np. plik a następnie go usunąć.

Dobrym przykładem implementacji jest `org.junit.rules.ExternalResource` który jest bazową implementacją dla rozszerzenia reguł do zarządzania zasobami. Poniżej przykład prostej implementacji reguły do sprawdzania czy został wyrzucony określony wyjątek.

```java
public class ExceptionRule implements TestRule {
    private Class expected;

    @Override
    public Statement apply(final Statement base, Description description) {
        return new Statement() {
            Throwable error = null;

            @Override
            public void evaluate() throws Throwable {
                try {
                    base.evaluate();
                } catch (Throwable throwable) {
                    error = throwable;
                }

                if (expected != null && (error == null || !error.getClass().equals(expected))) {
                    throw new Exception("No exception assertion");
                } else if (expected == null && error != null) {
                    throw new Exception("No exception assertion");
                }
            }
        };
    }

    public void setExpected(Class expected) {
        this.expected = expected;
    }
}
```

W powyższej implementacji metoda `apply` zwraca `Statement`, który obejmuje wywołanie. Innym przykładem jest `org.junit.rules.ExpectedException` który służy do przechwytywania wyjątków i sprawdzania czy wyjątek został zwrócony.
### JUnit 5
![Znalezione obrazy dla zapytania junit logo](../../../.files/Junit_Logo.png)

Jest to jeden z podstawowych frameworków do testów w Javie. Wywodzi się z tgz. XUnit.
#### Różnice między JUnit4 i JUnit5
| FEATURE                                              | JUNIT 4        | JUNIT 5        |
| ---------------------------------------------------- | -------------- | -------------- |
| Declare a test method                                | `@Test`        | `@Test`        |
| Execute before all test methods in the current class | `@BeforeClass` | `@BeforeAll`   |
| Execute after all test methods in the current class  | `@AfterClass`  | `@AfterAll`    |
| Execute before each test method                      | `@Before`      | `@BeforeEach`  |
| Execute after each test method                       | `@After`       | `@AfterEach`   |
| Disable a test method / class                        | `@Ignore`      | `@Disabled`    |
| Test factory for dynamic tests                       | NA             | `@TestFactory` |
| Nested tests                                         | NA             | `@Nested`      |
| Tagging and filtering                                | `@Category`    | `@Tag`         |
| Register custom extensions                           | NA             | `@ExtendWith`  |

Wersja czwarta składała się z jednego komponentu, natomiast wersja 5 została podzielona na trzy komponenty:

- JUnit Platform,
- JUnit Jupiter,
- JUnit Vintage.

Inną zasadniczą różnicą jest obsługa wyjątków, w JUnit4 były one definiowane w adnotacji `@Test(expected=IllegalArgumentException.class)`, natomiast w JUnit5 są odpowiednie nowe asercje.
#### Adnotacje
##### `@Ignore`
Dezaktywuje test jednostkowy.
#### Przypadki testowe
##### Sprawdzenie czy wyrzucono wyjątek
W JUnit5 jest funkcja assertThrows. 

```java
@Test
public void whenExceptionThrown_thenAssertionSucceeds() {
    Exception exception = assertThrows(NumberFormatException.class, () -> {
        Integer.parseInt("1a");
    });
 
    String expectedMessage = "For input string";
    String actualMessage = exception.getMessage();
 
    assertTrue(actualMessage.contains(expectedMessage));
}
```

W JUnit4 są dwa sposoby weryfikacji. Przez adnotację @Test i przekazanie oczekiwanego wyjątku

```java
@Test(expected = NullPointerException.class)
public void whenExceptionThrown_thenExpectationSatisfied() {
    String test = null;
    test.length();
}
```

Lub przez adnotację `@Rule`.

```java
import org.junit.Rule
import org.junit.Test
import org.junit.rules.ExpectedException
import org.mockito.Mockito

import static org.hamcrest.Matchers.*

@Rule
public ExpectedException expectedException = ExpectedException.none()

@Test
void "test missing required 'data' field"() {
    def templateServiceMock = Mockito.mock(FreemarkerTemplateService)
        def validator = new NoticeDataValidatorImpl(templateServiceMock)

        Mockito.when(templateServiceMock.isTemplateExists(NOTICE_TYPE)).thenReturn(true)

        def notice = new NoticeData()
        notice.type = NOTICE_TYPE

        expectedException.expect(allOf(
            instanceOf(ValidationException.class),
            hasProperty("errorCode", equalTo(ErrorCodes.MISSING_DATA.code))
        ))

        validator.validate(notice)
}

```

W JUnit3 i pozostałe zawsze możemy użyć funkcji `fail`.

```java
@Test
void "test missing required 'data' field"() {
    // ...

    try {
        validator.validate(notice)

        fail("Wyjątki nie zostały przechwycone")
    } catch (Exception e) {
        assertThat e isInstanceOf ValidationException
            assertThat e.errorCode isEqualTo ErrorCodes.MISSING_DATA.code
    }
}
```
### TestNG
![image-20210816155029381](../../../.files/image-20210816155029381.png)

TestNG jest biblioteką programistyczną służącą do pisania testów dla języka programowania Java. Jej autorem jest Cédric Beust. TestNG został napisany, aby stworzyć alternatywę dla narzędzia JUnit 3.x.


### Spring
Aby uruchomić testy dodajemy zależność. 

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
</dependency>
```

Jest to rozszerzenie pozwalające na integrację testów w środowisku Springa.
##### Adnotacje
| Adnotacja                          | Opis                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| `@RunWith(SpringRunner.class)`     | Uruchamia testy w kontekście Spring Application.             |
| `@SpringBootTest`                  |                                                              |
| `@TestConfiguraiton`               |                                                              |
| `@MockBean`                        |                                                              |
| `@SpyBean`                         |                                                              |
| `@JsonTest`                        |                                                              |
| `@WebMvcTest`                      | Inicjuje testy w kontekście HTTP, ale nie inicjuje serwera.  |
| `@DataJpaTest`                     | Inicjuje testy w kontekście bazy danych.                     |
| `@JdbcTest`                        |                                                              |
| `@DataMongoTest`                   |                                                              |
| `@DataMongoTest`                   |                                                              |
| `@AutoConfigureRestDocks`          |                                                              |
| `@BootStrapWith`                   |                                                              |
| `@ContextConfiguration`            |                                                              |
| `@ContextHierarchy`                |                                                              |
| `@ActiveProfiles`                  |                                                              |
| `@TestPropertySource`              |                                                              |
| `@DirtiesContext`                  |                                                              |
| `@WebAppConfiguration`             |                                                              |
| `@TestExecutionListeners`          |                                                              |
| `@Transactional`                   |                                                              |
| `@BeforeTranasaction`              |                                                              |
| `@AfterTransaction`                |                                                              |
| `@Sql                              | Specify 			SQL scripts to run before                |
| `@SqlConfig`                       | Define 			meta data for SQL scripts                 |
| `@SqlGroup`                        | Group 			of @Sql annotations                        |
| `@Repeat`                          | Repeat 			test x number of times                    |
| `@Timed`                           | Similar 			to JUnit’s timeout, but will wait for test to complete, unlike 			JUnit. |
| `@lfProfileValue`                  | Indicates 			test is enabled for a specific testing environment |
| `@ProfileValueSourceConfiguration` | Specify 			a profile value source                   |
##### Test kontrolera
W przykładzie testuje zachowanie się kontrolera. Kontroler wygląda nastepująco:

```java
@Controller
public class IndexController {
    private final UserService userService;

    public IndexController(UserService userService) {
        this.userService = userService;
    }

    @RequestMapping({"", "/"})
    public String index(Model model) {
        model.addAttribute("users", userService.find());

        return "index";
    }
}
```

W teście sprawdzam czy zostały wywołane poprawne metody oraz czy zwrócone wartości są oczekiwane.

```java
class IndexControllerTest {
    @Mock
    private UserService userService;

    @Mock
    private Model model;

    private IndexController indexController;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);

        indexController = new IndexController(userService);
    }

    @Test
    void index() {
        Set<User> users = new HashSet<>();

        users.add(new User("1", "Paweł", "Kowalski"));
        users.add(new User("2", "Justyna", "Iksińska"));
        users.add(new User("3", "Kasia", "Jankowiak"));

        when(userService.find()).thenReturn(users);

        String result = indexController.index(model);

        verify(userService, times(1)).find();
        verify(model, times(1)).addAttribute("users", users);

        assertEquals("index", result);
    }
}
```
###### Mechanizm MockMVC
Za pomocą MockMVC można bardziej realistycznie przetestować działanie kontrolera. W poprzednim przykładzie testowaliśmy kontroler bezpośrednio przez zainicjowanie obiektu. Test sprawdzał tylko obiekt kontrolera, nie sprawdzał jaka zostanie zwrócona odpowiedź, czy link zostanie dobrze odczytany itp.

Za pomocą MockMVC możliwe jest przetestowanie kontrolera przez symulacje żądania HTTP. Nie jest to test jednostkowy tylko integracyjny ponieważ łączy dwa komponenty: kontroler oraz żądania http.

Poniżej przykład takiego testu

```java
public class IndexControllerMVCTest {
    IndexController indexController;
    UserService userService;
    UserRepository userRepository;
    MockMvc mockMvc;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);

        UserRepository userRepository = new UserRepositoryImpl();
        userService = new UserServiceImpl(userRepository);
        indexController = new IndexController(userService);
    }

    @Test
    public void routeUsersUser() throws Exception {
        mockMvc = MockMvcBuilders.standaloneSetup(indexController).build();

        MvcResult mvcResult = mockMvc.perform(get("/api/users/967a0a57-ba3e-4276-b2fe-1e340582bca2").accept("application/json"))
            .andExpect(status().isOk())
            .andExpect(content().contentType("application/json"))
            .andExpect(jsonPath("$.id", new IsEqual<>("967a0a57-ba3e-4276-b2fe-1e340582bca2")))
            .andReturn();

        System.out.println(mvcResult.getResponse().getContentAsString());
    }
}
```

`MockMvcBuilders.standaloneSetup` tworzy MockMVC. Następnie na nim wywołujemy metodę `perform()` przekazując jako pierwszy parametr `RequestBuilder`.

`RequestBuilder` jest interfejsem, ma kilka implementacji. Ta która mnie w tym przypadku interesuje to `MockHttpServletRequestBuilder`. Zawiera ona szereg metod statycznych za pomoca którego można utworzyć żądanie.

Po wykonaniu żądania metoda `perform()` zwraca `ResultActions`. Interfejs definiuje takie metody jak:

```java
ResultActions andExpect(ResultMatcher var1) throws Exception;
ResultActions andDo(ResultHandler var1) throws Exception;
MvcResult andReturn();
```

Za pomoca tych metod tworzy łańcuch wywołań sprawdzających czy wynik jest zgodny z oczekiwaniami. Do sprawdzenia zgodności wykorzystujemy `ResultMatcher`.

```java
public interface ResultMatcher {
    void match(MvcResult var1) throws Exception;

    static ResultMatcher matchAll(ResultMatcher... matchers) {
        return (result) -> {
            ResultMatcher[] var2 = matchers;
            int var3 = matchers.length;

            for(int var4 = 0; var4 < var3; ++var4) {
                ResultMatcher matcher = var2[var4];
                matcher.match(result);
            }

        };
    }
}
```

Dla przykładu mamy `Content -> ContentResultMatchers -> contentType -> ResultMatcher`. Implementacja `contentType`. Poniżej implementacja dopasowana `Content-Type`.

```java
public ResultMatcher contentType(MediaType contentType) {
    return (result) -> {
        String actual = result.getResponse().getContentType();
        AssertionErrors.assertNotNull("Content type not set", actual);
        AssertionErrors.assertEquals("Content type", contentType, MediaType.parseMediaType(actual));
    };
}
```

Należy zwrócić uwagę na to, że wszystkie dopasowania korzystają z `MvcResult`. `andReturn` zwraca `MvcResutl`.
#### Integracyjne
SpringBoot Test umożliwia uruchomienie testów razem z kontekstem aplikacji. To w jaki sposób zostanie uruchomiony kontekst zostały zdefiniowane przez odpowiednie adnotacje.

Kontekst Springa możemy uruchomić przez dodanie adnotacji `@SpringBootTest`.

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

@SpringBootTest
public class TestsApplicationTest {
    @Autowired
    EmailRepository emailRepository;

    @Autowired
    CounterService counterService;

    @BeforeEach
    public void setUp() throws Exception {
        // ...
    }

    @Test
    public void checkTest() {
        System.out.println(counterService);
        System.out.println(emailRepository);
    }
}
```

W powyższym przypadku jest uruchamiamy cały kontekst razem z repozytoriami i usługami. Powyższy przykład działa jeśli uruchomimy go za pomocą junit5.

W przypadku junit4 (**nabrałem się na to**) testy są uruchamiane trochę inaczej.

```java
package com.ttmdear.repository.tests.services.impl;

import com.ttmdear.repository.tests.repositories.EmailRepository;
import com.ttmdear.repository.tests.services.CounterService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.AutoConfigureDataJpa;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureDataJpa
public class UserServiceImplJunit4IT {

    @Autowired
    CounterService counterService;

    @Autowired
    EmailRepository emailRepository;

    @Before
    public void setUp() {
        System.out.println("before");
    }

    @Test
    public void findById() {
        System.out.println(counterService);
        System.out.println(emailRepository);
    }
}
```

Pierwszy elementem jest `@RunWith(SpringRunner.class)` wskazuje on dla Junita jaka klasa ma uruchomić testy. `@SpringBootTest` konfiguruje kontekst aplikacji, dzięki czemu dostępną są takie komponenty. `@AutoConfigureDataJpa` konfiguruje komponenty powiązane z JPA czyli repozytoria danych itp.

## Makietowanie
### Mockito

[//]: # "mockito"

![Znalezione obrazy dla zapytania mockito logo](./files/707d279c0c78cfa174e012a0300c08de.jpg)

Jest to biblioteka do tworzenia makiet dla testów. Typowe metody stosowane w testach obejmują:

```
doXXX(???)   : Stubber
when(T)      : OngoingStubbing
then(T)      : OngoingStubbing
verify(???)  : T
given(T)     : BDDOngoingStubbing
willXXX(???) : BDDStubber
```

Gramatykę można opisać w taki sposób:

```
Kiedy wtedy: kiedy (yourMethod()).thenReturn(5);
Biorąc pod uwagę / Czy: podane (yourMethod()).WillThrow(OutOfMemoryException.class);
Zrobić kiedy: doReturn(7).when(yourMock.fizzBuzz());
Will/Given/Do: willReturn(any()).given(yourMethod()).doNothing();
Zweryfikuj/wykonaj: verify(yourMethod()).doThrow(SomeException.class);
```
#### Funkcja `when`
[//]: # "when"

Funkcja `when` pozwala zdefiniować co ma się wydarzyć gdy zostanie wywołana metoda na makietowanym obiekcie. Zachowanie możemy zdefinować przez funkcje: `thenReturn, thenThrow, thenAnwer`

Funkcja działa w ten sposób, że w momencie wywołania `when` rejestrowane jest wywołanie. Następnie metoda `then...` pozwala ustalić jaki będzie wynik wywołania.
##### when.thenReturn
[//]: # "when-then-return"

Funkcja `when` pozwala zdefiniować co ma się wydażyć gdy zostanie wywołana metoda na makietowanym obiekcie.

```java
UserRepository userRepository = Mockito.mock(UserRepository.class);

when(userRepository.findAll()).thenReturn(new HashSet<User>(){{
    add(new User("1", "Paweł", "Kowalski"));
    add(new User("2", "Krystyna", "Iksińska"));
    add(new User("3", "Daniel", "Kotyła"));
}});

Set<User> users = userRepository.findAll();
```

`thenReturn` definiuje co ma zostać zwrócone.
##### when.thenThrow
[//]: # "when-then-throw"

Pozwala na zdefiniowanie wyjątku który ma zostać wyrzucony w momencie wywołania metody.

```java
UserRepository userRepository = Mockito.mock(UserRepository.class);

when(userRepository.findAll()).thenThrow(new RuntimeException("Method not implemented"));

RuntimeException runtimeException = null;

try {
    userRepository.findAll();
} catch (RuntimeException e) {
    runtimeException = e;
}

assertNotNull(runtimeException);
```

Samo wyrzucenie wyjątku można zastąpić przez `doThrow`.

```java
doThrow(new RuntimeException("Method not implemented")).when(userRepository).findAll();
```
##### when.thenAnswer

[//]: # "work-then-answer"

Pozwala na zamodelowanie bardziej złożonej odpowiedzi z uwzględnieniem np. kontekstu.

```java
UserRepository userRepository = Mockito.mock(UserRepository.class);

final Set<User> users = new HashSet<User>(){{
    add(new User("967a0a57-ba3e-4276-b2fe-1e340582bca2", "Paweł", "Kowalski"));
    add(new User("46fb231f-c323-4332-a195-0bc9b93b91b9", "Justyna", "Iksińska"));
    add(new User("1950af9b-9c89-4d9b-8813-00f2ff8ee690", "Kasia", "Wrona"));
}};

when(userRepository.findById(anyString())).thenAnswer(new Answer<User>() {
    @Override
    public User answer(InvocationOnMock invocationOnMock) throws Throwable {
        String id = (String) invocationOnMock.getArguments()[0];

        Optional<User> result = users.stream().filter(u -> u.getId().equals(id)).findFirst();

        if (result.isPresent()) {
            return result.get();
        } else {
            return null;
        }
    }
});

assertNotNull(userRepository.findById("967a0a57-ba3e-4276-b2fe-1e340582bca2"));
assertNotNull(userRepository.findById("46fb231f-c323-4332-a195-0bc9b93b91b9"));
assertNotNull(userRepository.findById("1950af9b-9c89-4d9b-8813-00f2ff8ee690"));
assertNull(userRepository.findById("1950af9b-9c89-4d9b-8813-00f2ff8ee691"));
```

W przykładzie powyżej mam odwołanie się  do zewnętrznej listy `users` aby zwrócić odpowiedź.
#### Funkcja `do`
[//]: # "do"

Jest to inny sposób deklaracji zachowania w makietach. Najpierw definiujemy co ma się wydarzyć następnie deklarujemy interakcję z makietą.

```java
UserGroupService userGroupService = Mockito.mock(UserGroupService.class);
Mockito.doReturn("Jacek").when(userGroupService).getAdminName();
assertEquals("Jacek", userGroupService.getAdminName());
```

Pewnym szczególnym przypadkiem użycia doXXX jest przypadek gdy metoda, którą symulujemy nic nie zwraca.

```java
User user = Mockito.mock(User.class);

// Nie zastosujemy when w przypadku metod, które nic nie zwracają ponieważ when wymaga aby metoda
// coś zwracała
// Mockito.when(user.validatePermissio("A")).thenThrow(new RuntimeException("No permission"));
//              ^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Możemy ro rozwiązać za pomodą doXXX
Mockito.doThrow(new RuntimeException("No permission")).when(user).validatePermissio("A");

assertThrows(RuntimeException.class, new Executable() {
    @Override
    public void execute() throws Throwable {
        user.validatePermissio("A");
    }
});
```
##### do.doThrow

[//]: # "do-throw"

```java
UserGroupService userGroupService = Mockito.mock(UserGroupService.class);

Mockito.doThrow(new IllegalArgumentException()).when(userGroupService).getAdminRole(null);

assertThrows(IllegalArgumentException.class, () -> userGroupService.getAdminRole(null));
```
#### Funkcja `given`

[//]: # "given"

Jest to sposób deklaracji makiety zgodny z metodologią BDD. 

```java
@Test
void givenNonVoidMethod_callingGiven_shouldConfigureBehavior() {
    // given
    given(employee.greet()).willReturn("Hello");
 
    // when
    String greeting = employee.greet();
 
    // then
    assertThat(greeting, is("Hello"));
}
 
@Test
void givenVoidMethod_callingWillThrow_shouldConfigureBehavior() {
    // given
    willThrow(new IAmOnHolidayException()).given(employee).work(DayOfWeek.SUNDAY);
 
    // when
    Executable workCall = () -> employee.work(DayOfWeek.SUNDAY);
 
    // then
    assertThrows(IAmOnHolidayException.class, workCall);
}
```
#### Funkcja `verify`

[//]: # "verify"

Funkcja `verify` pozwala na zdefiniowanie procesu weryfikacji, czy wywołania zostały wykonane oraz czy zostały wykonane w odpowiedni sposób.

Najprostszy przypadek weryfikacji:

```java
UserRepository userRepository = Mockito.mock(UserRepository.class);

userRepository.findAll();

verify(userRepository, times(1)).findAll();
```
#### Przechwytywanie argumentu

[//]: # "argument-captor"

Pozwala na przechwycenie argumentów z którymi wywołano metodę, dzięki czemu możemy sprawdzić czy np. metoda została wywołana z oczekiwanymi parametrami.

```java
UserRepository userRepository = Mockito.mock(UserRepository.class);
UserService userService = new UserServiceImpl(userRepository);

User user = new User("1", "Paweł", "Kowalsk", UserStatus.DEACTIVE);

ArgumentCaptor<User> userArgumentCaptor = ArgumentCaptor.forClass(User.class);

userService.active(user);

verify(userRepository, times(1)).save(userArgumentCaptor.capture());

assertEquals(UserStatus.ACITVE, userArgumentCaptor.getValue().getStatus());
```

W powyższym przykładzie testuje, czy metoda `active` ustawiła status `ACTIVE` na encji `User`. Klasa `userRepository` jest zamakietowana.
#### Dopasowanie argumentów

[//]: # "match-argument"

W przypadku weryfikacji możemy sprawdzić z jakimi parametrami została wywołana metoda. `ArgumentCaptor` pozwalał na przechwycić parametr i sprawdzić za pomocą asercji. `ArgumentMatcher` pozwala sprawdzenie czy argument spełniam założone warunki.

Najprostszym przykładem są predefiniowane matchery:

```java
when(flowerService.analyze(anyString())).thenReturn("Flower");
when(mock.isABigFlower(eq("poppy"), anyInt())).thenReturn(true);
verify(mock).analyze(or(eq("poppy"), endsWith("y")));
verify(mock).analyze(or(eq("poppy"), endsWith("y")));
```

Własna implementacja

```java
public class MessageMatcher implements ArgumentMatcher<Message> {

    private Message left;

    // constructors

    @Override
    public boolean matches(Message right) {
        return left.getFrom().equals(right.getFrom()) &&
          left.getTo().equals(right.getTo()) &&
          left.getText().equals(right.getText()) &&
          right.getDate() != null &&
          right.getId() != null;
    }
}

verify(messageService, times(1)).deliverMessage(argThat(new MessageMatcher(message)));
```
#### Pozostałe

[//]: # "other"

##### Różnica między `@MockBean, @Mock, Mockito.mock()`
Adnotację `@Mock, Mockito.mock()` pochodzą z biblioteki Mockito i w zasadzie robią to samo. Ta pierwsza pozwala na oznaczenie pola adnotację. Do tak oznaczone pola Mikito może wstrzyknąć instancję jeśli np. uruchamiamy testu za pomocą Mokito.

Oznaczenie

```
import org.mockito.Mock;
...
@Mock
MyService myservice;
```

Uruchomienie

```
@RunWith(org.mockito.runners.MockitoJUnitRunner.class)
public MyClassTest{...}
```

Natomiast adnotacja `@MockBean` jest powiązana ze Springiem. Oznaczenie pola tą adnotacją spowoduje, że w przypadku uruchomienia testów z kontekstem Springa to Spring podmieni instancję komponentu na makietę.

```java
import org.springframework.boot.test.mock.mockito.MockBean;
...
@MockBean
MyService myservice;
```

To się przydaje przy testach integracyjnych gdy chcemy zamakietować komponent w kontekście.

## Testy architektury
### ArchUnit
![image-20210827154639341](../.files/image-20210827154639341.png)

Jest to biblioteka wspierająca testowanie architektury aplikacji. Biblioteka pozwala na pisanie reguł sprawdzających czy odpowiednie zasady architektury nie są łamane. Reguły mogą np. opisywać, że określone klasy nie mogą wywoływać metody z określonych pakietów np. klasy z repozytorium nie powinny wykonywać metod z pakietów usług albo warstwa kontrolerów nie powinna bezpośrednio wywoływać metod z pakietu repozytoriów z pominięciem warstwy serwisów.

Przykładowy projekt jest w repozytorium razem z konfiguracją pod JUnit5. Poniżej umieszczam reguły jakie można definiować.

#### Reguły
**Zależności między pakietami**

```java
// Żadna klasa z pakiety ..source.. nie może być zależna od klasy w pakiecie ..foo..
noClasses().that().resideInAPackage("..source..")
    .should().dependOnClassesThat().resideInAPackage("..foo..")
    
classes().that().resideInAPackage("..foo..")
    .should().onlyHaveDependentClassesThat().resideInAnyPackage("..source.one..", "..foo..")
```

 **Zależności klas**

```java
// Klasy które kończą się na Bar mogą być zależne tylko od klas Bar
classes().that().haveNameMatching(".*Bar")
    .should().onlyHaveDependentClassesThat().haveSimpleName("Bar")
```

Dokumentacja opisuje różnego rodzaju sprawdzenia jakie można wykonać. Jeszcze jeden bardziej praktyczny przykład gdzie sprawdzamy czy żadna klasa nie woła bezpośrednio klas z repozytoriów. Tylko serwisy mogą komunikować się z repozytoriami.

```
ArchRule rule = classes().that()
	.resideInAnyPackage("repo.archunit.repositories")
	.should()
	.onlyBeAccessed()
.byAnyPackage("repo.archunit.services");

rule.check(JC);
```

Oraz każda klasa w pakiecie `repository` powinna kończyć się na `Repo`.

```java
ArchRule rule2 = classes().that()
    .resideInAnyPackage("repo.archunit.repositories")
    .should()
    .haveSimpleNameEndingWith("Repo");

rule2.check(JC);

```

#### Warstwy
Biblioteka pozwala też fajny sposób określić jakie mamy warstwy w aplikacji i za pomocą tych nazw definiować reguły.

```java
layeredArchitecture()
    .layer("Controller").definedBy("..controller..")
    .layer("Service").definedBy("..service..")
    .layer("Persistence").definedBy("..persistence..")

    .whereLayer("Controller").mayNotBeAccessedByAnyLayer()
    .whereLayer("Service").mayOnlyBeAccessedByLayers("Controller")
    .whereLayer("Persistence").mayOnlyBeAccessedByLayers("Service")
```

## Testy mutacyjne
Testy mutacyjne są w pewnym sensie testami testów. Polegają one na tym, że testy np. jednostkowe są modyfikowane a następnie sprawdzane jest czy test się powiedzie. Jeśli po modyfikacji test się powiedzie to oznacza, że bazowy test nie jest dokładny. 

Przykładowy kawałek programu:

```java
if ( i >= 0 ) {
    return "foo";
} else {
    return "bar";
}
```

Załóżmy, że mamy test jednostkowy które sprawdza czy jeśli wyślę wartość `i=1` to dostanę `foo`. Test mutacyjny mógłby wyglądać tak:

```java
if ( i > 0 ) {
    return "foo";
} else {
    return "bar";
}
```

W teście został zmieniony operator z `>=` na `>` czyli teraz dla wartości `1` też dostanę `bar` . **Po takiej zmianie test jednostkowy powinien się nie powieść, jeśli się powiedzie to oznacza, że jest niepoprawny.** To jest istota testów mutacyjnych, że testują poprawność testu jednostkowego przez wprowadzanie zmian w kodzie i weryfikowaniu czy test się powiedzie czy nie.

### Pitest
![image-20210831084252570](../../../.files/image-20210831084252570.png)

Jedna z bibliotek dostępna w Javie. 

https://pitest.org



## Biblioteki i narzędzia
| Biblioteka | Opis                                                         |
| ---------- | ------------------------------------------------------------ |
| Hamcrest   | Hamcrest to platforma wspomagająca pisanie testów oprogramowania w języku programowania Java. Obsługuje tworzenie dostosowanych elementów dopasowujących potwierdzenia, umożliwiając deklaratywne definiowanie reguł dopasowania. |
| AssertJ    | Biblioteka do sprawdzania asercji.                           |
| JSONassert | Zbiór narzędzi do testowania JSONA.                          |
| JSONPath   | Biblioteka do obsługi JSON Path.                             |

### Maven surefire
Jest to wtyczka odpowiedzialna za uruchomienie testów w fazie `test` Mavena. Jest to podstawowa wtyczka.
### Maven failsafe
Jest to plugin za pomocą którego możemy uruchomić testy integracyjny. Ogólnie Maven uruchamia wszystkie pliki które kończą się na `Tests`. Maven nie rozróżnia które testy są integracyjne a które są jednostkowe wiec np. testy integracyjny mogą blokować testy jednostkowe, które mógłby by się wykonać szybko.

Rozszerzenie failsafe pozwala na uruchomienie testów integracyjnych np. po testach jednostkowych co może wpłynąć na szybkość pracy.

Poniżej przykładowa konfiguracja dla testów które kończą się na `*IT`.

```xml
<build>
    <plugins>

        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-failsafe-plugin</artifactId>
            <version>3.0.0-M4</version>
            <configuration>
                <includes>
                    <include>**/*IT.java</include>
                </includes>
                <additionalClasspathElements>
                    <additionalClasspathElement>${basedir}/target/classes</additionalClasspathElement>
                </additionalClasspathElements>
            </configuration>
            <executions>
                <execution>
                    <id>integration-test</id>
                    <goals>
                        <goal>integration-test</goal>
                        <goal>verify</goal>
                    </goals>
                    <configuration>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```
### Testcontainers
Testcontainers to biblioteka Java, która obsługuje testy JUnit, zapewniając lekkie, jednorazowe instancje typowych baz danych, przeglądarki internetowe Selenium lub cokolwiek innego, co można uruchomić w kontenerze Docker.

https://www.testcontainers.org
## Przykłady
W rozdziale umieszczam różnego rodzaju testy
### Makietowanie usługi
W poniższym przykładzie tworze test usługi `UserService`. Usługa korzysta z `UserRepository` który w tym przypadku zostało zamakietowana.

```java
public class UserServiceImplTest {

    private UserServiceImpl userService;

    @Mock
    private UserRepository userRepository;

    @BeforeEach
    void setUp() {
        // Inicjujemy makity na postawie adnotacji.
        MockitoAnnotations.initMocks(this);

        userService = new UserServiceImpl(userRepository);
    }

    @Test
    void find() {
        Set<User> users = new HashSet<User>() {{
            add(new User("1", "Paweł", "Kowalski"));
        }};

        when(userRepository.findAll()).thenReturn(users);

        Set<User> result = userService.find();

        assertEquals(1, result.size());

        verify(userRepository, times(1)).findAll();
    }
}
```
### Przykład testowania MVC
```java
package guru.springframework.controllers;

import guru.springframework.commands.IngredientCommand;
import guru.springframework.commands.RecipeCommand;
import guru.springframework.services.IngredientService;
import guru.springframework.services.RecipeService;
import guru.springframework.services.UnitOfMeasureService;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import java.util.HashSet;

import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

public class IngredientControllerTest {

    @Mock
    IngredientService ingredientService;

    @Mock
    UnitOfMeasureService unitOfMeasureService;

    @Mock
    RecipeService recipeService;

    IngredientController controller;

    MockMvc mockMvc;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        controller = new IngredientController(ingredientService, recipeService, unitOfMeasureService);
        mockMvc = MockMvcBuilders.standaloneSetup(controller).build();
    }

    @Test
    public void testListIngredients() throws Exception {
        //given
        RecipeCommand recipeCommand = new RecipeCommand();
        when(recipeService.findCommandById(anyLong())).thenReturn(recipeCommand);

        //when
        mockMvc.perform(get("/recipe/1/ingredients"))
                .andExpect(status().isOk())
                .andExpect(view().name("recipe/ingredient/list"))
                .andExpect(model().attributeExists("recipe"));

        //then
        verify(recipeService, times(1)).findCommandById(anyLong());
    }

    @Test
    public void testShowIngredient() throws Exception {
        //given
        IngredientCommand ingredientCommand = new IngredientCommand();

        //when
        when(ingredientService.findByRecipeIdAndIngredientId(anyLong(), anyLong())).thenReturn(ingredientCommand);

        //then
        mockMvc.perform(get("/recipe/1/ingredient/2/show"))
                .andExpect(status().isOk())
                .andExpect(view().name("recipe/ingredient/show"))
                .andExpect(model().attributeExists("ingredient"));
    }

    @Test
    public void testNewIngredientForm() throws Exception {
        //given
        RecipeCommand recipeCommand = new RecipeCommand();
        recipeCommand.setId(1L);

        //when
        when(recipeService.findCommandById(anyLong())).thenReturn(recipeCommand);
        when(unitOfMeasureService.listAllUoms()).thenReturn(new HashSet<>());

        //then
        mockMvc.perform(get("/recipe/1/ingredient/new"))
                .andExpect(status().isOk())
                .andExpect(view().name("recipe/ingredient/ingredientform"))
                .andExpect(model().attributeExists("ingredient"))
                .andExpect(model().attributeExists("uomList"));

        verify(recipeService, times(1)).findCommandById(anyLong());

    }

    @Test
    public void testUpdateIngredientForm() throws Exception {
        //given
        IngredientCommand ingredientCommand = new IngredientCommand();

        //when
        when(ingredientService.findByRecipeIdAndIngredientId(anyLong(), anyLong())).thenReturn(ingredientCommand);
        when(unitOfMeasureService.listAllUoms()).thenReturn(new HashSet<>());

        //then
        mockMvc.perform(get("/recipe/1/ingredient/2/update"))
                .andExpect(status().isOk())
                .andExpect(view().name("recipe/ingredient/ingredientform"))
                .andExpect(model().attributeExists("ingredient"))
                .andExpect(model().attributeExists("uomList"));
    }

    @Test
    public void testSaveOrUpdate() throws Exception {
        //given
        IngredientCommand command = new IngredientCommand();
        command.setId(3L);
        command.setRecipeId(2L);

        //when
        when(ingredientService.saveIngredientCommand(any())).thenReturn(command);

        //then
        mockMvc.perform(post("/recipe/2/ingredient")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .param("id", "")
                .param("description", "some string")
        )
                .andExpect(status().is3xxRedirection())
                .andExpect(view().name("redirect:/recipe/2/ingredient/3/show"));

    }

    @Test
    public void testDeleteIngredient() throws Exception {

        //then
        mockMvc.perform(get("/recipe/2/ingredient/3/delete")
        )
                .andExpect(status().is3xxRedirection())
                .andExpect(view().name("redirect:/recipe/2/ingredients"));

        verify(ingredientService, times(1)).deleteById(anyLong(), anyLong());

    }
}
```
### Przykład testowania MVC recepty
```java
package guru.springframework.controllers;

import guru.springframework.commands.RecipeCommand;
import guru.springframework.domain.Recipe;
import guru.springframework.services.RecipeService;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * Created by jt on 6/19/17.
 */
public class RecipeControllerTest {

    @Mock
    RecipeService recipeService;

    RecipeController controller;

    MockMvc mockMvc;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        controller = new RecipeController(recipeService);
        mockMvc = MockMvcBuilders.standaloneSetup(controller).build();
    }

    @Test
    public void testGetRecipe() throws Exception {

        Recipe recipe = new Recipe();
        recipe.setId(1L);

        when(recipeService.findById(anyLong())).thenReturn(recipe);

        mockMvc.perform(get("/recipe/1/show"))
                .andExpect(status().isOk())
                .andExpect(view().name("recipe/show"))
                .andExpect(model().attributeExists("recipe"));
    }

    @Test
    public void testGetNewRecipeForm() throws Exception {
        RecipeCommand command = new RecipeCommand();

        mockMvc.perform(get("/recipe/new"))
                .andExpect(status().isOk())
                .andExpect(view().name("recipe/recipeform"))
                .andExpect(model().attributeExists("recipe"));
    }

    @Test
    public void testPostNewRecipeForm() throws Exception {
        RecipeCommand command = new RecipeCommand();
        command.setId(2L);

        when(recipeService.saveRecipeCommand(any())).thenReturn(command);

        mockMvc.perform(post("/recipe")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .param("id", "")
                .param("description", "some string")
        )
                .andExpect(status().is3xxRedirection())
                .andExpect(view().name("redirect:/recipe/2/show"));
    }

    @Test
    public void testGetUpdateView() throws Exception {
        RecipeCommand command = new RecipeCommand();
        command.setId(2L);

        when(recipeService.findCommandById(anyLong())).thenReturn(command);

        mockMvc.perform(get("/recipe/1/update"))
                .andExpect(status().isOk())
                .andExpect(view().name("recipe/recipeform"))
                .andExpect(model().attributeExists("recipe"));
    }

    @Test
    public void testDeleteAction() throws Exception {
        mockMvc.perform(get("/recipe/1/delete"))
                .andExpect(status().is3xxRedirection())
                .andExpect(view().name("redirect:/"));

        verify(recipeService, times(1)).deleteById(anyLong());
    }
}
```
### MVC wgrywanie zdjęć
```java
package guru.springframework.controllers;

import guru.springframework.commands.RecipeCommand;
import guru.springframework.services.ImageService;
import guru.springframework.services.RecipeService;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.multipart;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

public class ImageControllerTest {

    @Mock
    ImageService imageService;

    @Mock
    RecipeService recipeService;

    ImageController controller;

    MockMvc mockMvc;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        controller = new ImageController(imageService, recipeService);
        mockMvc = MockMvcBuilders.standaloneSetup(controller).build();
    }

    @Test
    public void getImageForm() throws Exception {
        //given
        RecipeCommand command = new RecipeCommand();
        command.setId(1L);

        when(recipeService.findCommandById(anyLong())).thenReturn(command);

        //when
        mockMvc.perform(get("/recipe/1/image"))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("recipe"));

        verify(recipeService, times(1)).findCommandById(anyLong());
    }

    @Test
    public void handleImagePost() throws Exception {
        MockMultipartFile multipartFile =
                new MockMultipartFile("imagefile", "testing.txt", "text/plain",
                        "Spring Framework Guru".getBytes());

        mockMvc.perform(multipart("/recipe/1/image").file(multipartFile))
                .andExpect(status().is3xxRedirection())
                .andExpect(header().string("Location", "/recipe/1/show"));

        verify(imageService, times(1)).saveImageFile(anyLong(), any());
    }
}
```

# Hibernate

[//]: "hibernate"

<img src="../.files/Hibernate_logo_a.png" alt="Znalezione obrazy dla zapytania: hibernate logo" style="zoom: 25%;" />

## Architektura

[//]: "architecture"

![Hibernate Architecture](../.files/Hibernate-Architecture.png)

**Komponent Configuration**

Komponent odpowiedzialny za przechowywanie i dostarczanie konfiguracji dla SessionFactory. Konfigurację są przechowywane w plikach właściwości (hibernate.properties), plikach xml hibernate.cfg.xml lub klasach oznaczonych przez adnotację @Configuration.

**Komponent SessionFactory**

Jest odpowiedzialny za dostarczenie obiektu Session.

**Komponent Session**

Reprezentuje konkretne połączenie z bazą danych. Obiekt jest tworzony przez komponent SessionFactory.

**Komponent Query**

Jest odpowiedzialny utworzenie zapytania do bazy danych. Hibernate udostepnia kilka sposób na wykonanie zapytania (QueryApi, NamedQuery).

**Komponent First-level cache**

Jest to pierwszy poziom Cache. 

> It represents the default cache used by Hibernate Session object while interacting with the database. It is also called as session cache and caches objects within the current session. All requests from the Session object to the database must pass through the first-level cache or session cache. One must note that the first-level cache is available with the session object until the Session object is live.

**Komponent Transaction**

Jest odpowiedzialny za mechanizm tranzakcji.

**Komponenty Persistent objects**

Są to obiekty typu POJO które reprezentują wierwsze w tabelach. Tego obiektu mogą być zdefniowane w konfiguracji xml, w pliku właściwosci lub za pomocą adnotacji @Entity.

**Komponent Second-level cache**

Jest odpowiedzialny za przechowywanie obiektów między sesjami. Przykładową implementacja jest EhCache.
### JPA - Java persistence
Jest to standard opisujący sposób komunikacji między aplikacją a bazą danych. **Nie jest implementacja**. Definicja jest zawarta w pakiecie `javax.persistence`.

Jest wiele bibliotek które implementują standard:

- Hibernate (72%),
- EclipseLink (13%),
- OpenJPA (2%).

Standard definiuje:

- sposób komunikacji aplikacji z obiektami bazy danych,
- typy danych oraz ich konwersję,
- operacje usuwania/tworzenia aktualizacji.
- generowanie schematów,
- wykonywanie zapytań do procedur. 
### Cache
Hibernate wyróżnia dwa poziomu pamięci podręcznej.

![XM Hibernate Cache Test](../.files/XM_Hibernate_Cache_Test.png)

Pierwszy poziom pamięci podręcznej jest na poziomie Session. 

Drugi poziom jest na poziomie SessionFactory. Drugi poziom może być implementowany przez zewnętrzne biblioteki:

- EhCache,
- OSCache.
## Stan encji

[//]: "entity-state"

<img src="../.files/2016-07-11_13-38-11-1024x551.png" alt="2016-07-11_13-38-11" style="zoom:80%;" />

Instancja encji może być w kilku stanach:

- transient,
- persistent,
- detached,
- removed.

**Persistent**

Jest to stan w którym encja jest w bazie danych i jednocześnie Hibernate zarządza stanem encji w pamięci

![Persistent objects are maintained by Hibernate](../.files/Persistent-objects-are-maintained-by-Hibernate.jpg)

**Transient**

Instancja istnieje w pamięci, ale Hibernate nim nie zarządza.

![Transient objects are independent of Hibernate](../.files/Transient-objects-are-independent-of-Hibernate.jpg)

**Detached**

Encja w takim stanie ma swoją reprezentacje w bazie danych ale nie jest powiązana z sesją. Taki stan na ogół powstaje w wyniku zamknięcia sesji.

![Detached objects exist in the database but are not maintained by Hibernate](../.files/Detached-objects-exist-in-the-database-but-are-not-maintained-by-Hibernate.jpg)

Aby zapisać encję w takim stanie najpierw trzeba połączyć ją z aktualną sesją (reattach), służą do tego metody: `load, refresh, merge, update, save, saveOrUpdate`. Po wykonaniu tych metod obiekt zostanie powiązany z sesją.
## Inicjacja

[//]: "set-up"

Jednym ze sposobów konfiguracji są pliki xml. Standardowym plikiem jest hibernate.cfg.xml.

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <!-- <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>-->
        <property name="hibernate.connection.driver_class">org.h2.Driver</property>
        <property name="hibernate.connection.url">jdbc:h2:~/tmp/test</property>
        <property name="hibernate.connection.password">lg225295</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.dialect">org.hibernate.dialect.H2Dialect</property>
        <property name="show_sql">true</property>
        <property name="hbm2ddl.auto">update</property>

        <mapping class="com.ttmdear.repository.hibernate.model.UserEntity"></mapping>
    </session-factory>
</hibernate-configuration>
```

Następnie aby zainicjować sesję.

```java
private void initDatabase() {
    StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
        .configure()
        .build();

    SessionFactory sessionFactory = new MetadataSources(registry)
        .buildMetadata()
        .buildSessionFactory();
}
```

Obiekt StandardServiceRegistry jest odpowiedzialny za zainicjowanie środowiska na postawie konfiguracji. Obiekt MetadataSources jest odpowiedzialny za utworzenie modelu danych. Obiekt Metadata jest reprezentacją sprasowanych danych o modelu. Jest on wykorzystywany przez SessionFactory do inicjacji połączenia.

**Konfiguracja za pomocą adnotacji a XML**

------

```java
import javax.persistence.* ;
@Entity
public class Sample {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public Integer id;
    public String name;
}
```

Odpowiednikiem jest plik XML:

```xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE
   hibernate-mapping
   PUBLIC
   "-//Hibernate/Hibernate Mapping DTD//EN"
   "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd
">
<hibernate-mapping default-access="field">
   <class name="Sample">
      <id type="int" column="id">
         <generator class="native"/>
      </id>
      <property name="name" type="string"/>
   </class>
</hibernate-mapping>
```
## Pobieranie danych

[//]: "fetch-data"

Obiekty można pobrać na kilka sposobów:

- za pomocą Criteria Queries,
- za pomoą HQL,
- za pomocą NamedQueries,
- HQL,
- QBE.
### Pobieranie za pomocą zapytania

[//]: "criteria-builder"

https://docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/querycriteria.html 

Jest to mechanizm za pomocą którego w sposób programistyczny można zbudować zapytanie. Mechanizm jest zaprojektowany w taki sposób aby był w pełni typowany (przy wykorzystaniu modelu statycznego).

Do rozpoczęcia tworzenia zapytania potrzebny jest CriteriaBuilder. Jest to obiekt odpowiedzialny za tworzenie różnych elementów zapytania.

Obiekt można utworzyć za pomocą EntityMenagerFactory.

```java
CriteriaBuilder builder = entityManagerFactory.getCriteriaBuilder();
```

Następnie tworzymy CriteriaQuery. Za pomocą tego obiektu będzie tworzone zapytanie. Przy tworzeniu obiektu musimy zdefiniować jakiego typu wartość encja, pole będzie zwracało zapytanie.

```java
// Lista dowolnych obiektów
CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);

// Ciąg znaków
CriteriaQuery<String> cq = cb.createQuery(String.class);

// Dane do encji User
CriteriaQuery<User> cq = cb.createQuery(User.class);
```

Następnie wybieramy co ma zostać zwrócone.

```java
// Dwie kolumny firstName, lastName z encji User
cq.select(cb.array(userRoot.get("firstName"), userRoot.get("lastName")));

// Multiselect
cq.multiselect(
    userRoot.get("id"),
    userRoot.get("firstName")
);

// Jedna kolumna firstName
cq.select(userRoot.<String>get("firstName"));

// Pola do encji User
cqf.select(userRoot);
```

W ostatnim kroku pobieramy dane.

```java
// Dla listy dowolnych wartości i obiektów
List<Object[]> values = entityManager.createQuery(cq).getResultList();

for(Object[] value: values) {
    System.out.println("firstName: " + value[0]);
    System.out.println("lastName: " + value[1]);
}

// Dla pojedyńczego pola
String firstName = entityManager.createQuery(cq).getSingleResult();

// Dla encji User
User user = entityManager.createQuery(cqf).getSingleResult();
```

Poniżej jest kompletny przykład pobrania wartości dla encji User.

```java
EntityManager entityManager = sessionFactory.createEntityManager();
CriteriaBuilder cb = entityManager.getCriteriaBuilder();

// Pobranie encji
CriteriaQuery<User> cqf = cb.createQuery(User.class);

Root<User> userRoot = cqf.from(User.class);

cqf.select(userRoot);

Expression expression = cb.equal(userRoot.get("id"), cb.literal("2fe48679-74cc-4581-b7aa-b6d4a795624d"));

cqf.where(expression);

User user = entityManager.createQuery(cqf).getSingleResult();

entityManager.close();
```
#### Mechanizm TupleQuery
W przypadku gdy wybieramy wiele różnych wartości to wynik na ogół będziemy rzutować na `Object[].class` . Czyli na listę dowolnych obiektów. Następnie przy odczytywaniu jest rzutowanie na konkretne typy.

```java
for(Object[] row: values) {
    System.out.println("id: " + row[0]);
    System.out.println("firstName: " + row[1]);

    break;
}
```

W tym procesie możemy wykorzystać obiekt javax.persistence.Tuple. Działa on podobnie, tylko do dyspozycji mamy czytelniejsze API.

```java
EntityManager entityManager = sessionFactory.createEntityManager();

CriteriaBuilder cb = entityManager.getCriteriaBuilder();

CriteriaQuery<Tuple> cq = cb.createTupleQuery();

Root<User> userRoot = cq.from(User.class);

cq.select(cb.tuple(
    userRoot.get("id"),
    userRoot.get("firstName")
));

List<Tuple> values = entityManager.createQuery(cq).getResultList();

// W tym miejscu zachodzi różnica, iterujemy po obiektach Tuple. 
for(Tuple row: values) {
    System.out.println("id: " + row.get(0, String.class));
    System.out.println("firstName: " + row.get(1, String.class));

    break;
}
```
#### Złączanie tabel
Poniżej przykład. 

```java
CriteriaBuilder cb = session.getCriteriaBuilder();
CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);

Root<User> userRoot = cq.from(User.class);
Join<User, Phone> phonesJoin = userRoot.join("phones");

cq.multiselect(
    userRoot.get("id"),
    userRoot.get("firstName"),
    userRoot.get("lastName"),
    phonesJoin.get("value")
);

List<Object[]> result = session.createQuery(cq).getResultList();

for(Object[] row: result) {
    System.out.println("id: " + row[0]);
    System.out.println("firstName: " + row[1]);
    System.out.println("lastName: " + row[2]);
    System.out.println("phone: " + row[3]);
}
```
#### Grupowanie danych
```java
CriteriaBuilder cb = session.getCriteriaBuilder();
CriteriaQuery<GroupResultDto> cq = cb.createQuery(GroupResultDto.class);

Root<User> user = cq.from(User.class);
Join<User, Phone> phones = user.join("phones");

cq.multiselect(user.get("id"), cb.count(phones.get("value")).alias("numberOfPhones"));
cq.groupBy(user.get("id"));

List<GroupResultDto> result = session.createQuery(cq).getResultList();
```
#### Mapowanie danych na DTO
Wynik dowolnego zapytania możemy zmapować na dowolny typ obiektu DTO (POJO).

Jedyne o co musimy zadbać to odpowiedni konstruktor który będzie zawierał wszystkie wymagane pola.

```java
private void fetchingByCriteriaBuilderGroup(Session session) {
    CriteriaBuilder cb = session.getCriteriaBuilder();
    
    // Definiujemy jakiego typu danych oczekujemy
    CriteriaQuery<GroupResultDto> cq = cb.createQuery(GroupResultDto.class);

    // Ustawiamy skąd dane maja zostać pobrane
    Root<User> user = cq.from(User.class);
    
    // Dokonujemy zlączenia
    Join<User, Phone> phones = user.join("phones");

    cq.multiselect(user.get("id"), cb.count(phones.get("value")).alias("numberOfPhones"));
    cq.groupBy(user.get("id"));

    List<GroupResultDto> result = session.createQuery(cq).getResultList();
}

@Data
private static class GroupResultDto {
    private String id;
    private Long numberOfPhones;

    public GroupResultDto(String id, Long numberOfPhones) {
        this.id = id;
        this.numberOfPhones = numberOfPhones;
    }
}
```
#### Mechanizm Projection
Jest to inny sposób za pomocą którego możemy zbudować dowolne zapytanie tak jak by było tworzone przez SQL.
#### Wywoływanie funkcji
CB umożliwia również umieszczenie wywołania funkcji bazy danych lub własnej. W przypadku własnej funkcji należy pamiętać aby ją zarejestrować w ramach dialektu.
#### Przykładowe konstrukcje
**WHERE IN(...)**

------

```java
CriteriaBuilder cb = entityManager.getCriteriaBuilder();

CriteriaQuery<Deklinacja> cq = cb.createQuery(Deklinacja.class);
Root<Deklinacja> deklinacjaRoot = cq.from(Deklinacja.class);

cq.where(deklinacjaRoot.get(Deklinacja_.mianownik).in(mianowniki));

return entityManager.createQuery(cq).getResultList();
```

Z podzapytaniem

```java
Subquery<Department> subquery = criteriaQuery.subquery(Department.class);
Root<Department> dept = subquery.from(Department.class);
subquery.select(dept)
  .distinct(true)
  .where(criteriaBuilder.like(dept.get("name"), "%" + searchKey + "%"));
 
criteriaQuery.select(emp)
  .where(criteriaBuilder.in(emp.get("department")).value(subquery));
```

```java
List<User> users = entityManager.createQuery("FROM User ", User.class).getResultList();
```
#### Mechanizm NamedQueries
Jest to mechanizm pozwalający za zapisanie zapytań w formie adnotacji i wykonanie ich w razie potrzeby. 

Możliwe jest zapisanie zapytań w języku natywnym (NamedNativeQuery) lub w HQL (NamedQuery).

Zapytania możemy zapisać w encji.

```java
@NamedNativeQuery(name = "USER_ALL", query = "SELECT * FROM CORE_USER", resultClass = User.class)
@NamedQueries({
        @NamedQuery(name = "CORE_USER.ACTIVE_USERS", query = "FROM User WHERE status = 'ACTIVE'")
})
public class User extends Entity {
	// ...
}
```

Do tak zapisanych zapytań można się odwołać:

```java
// Odwołanie się do zapytania 
Query query = entityManager.createNamedQuery("USER_ALL");

List<User> users = query.getResultList();

// 
Query query = entityManager.createNamedQuery("CORE_USER.ACTIVE_USERS");
```
#### Budowanie warunków
##### Konstrukcja IN
```java
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery<KonfigPowiadomienia> cq = cb.createQuery(KonfigPowiadomienia.class);

Root<KonfigPowiadomienia> root = cq.from(KonfigPowiadomienia.class);

cq.where(root.get(KonfigPowiadomienia_.typ).in(typy));

return entityManager.createQuery(cq).getResultList();
```
### HQL

[//]: "hql"

Przykłady zapytań

https://howtodoinjava.com/hibernate/complete-hibernate-query-language-hql-tutorial

```sql
select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate < sysdate
    and catalog.effectiveDate >= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate < sysdate
    )
group by order
having sum(price.amount) > :minAmount
order by sum(price.amount) desc
```
### QBE

[//]: "qbe"

Jest to mechanizm za pomocą którego można wykonać zapytanie na postawie obiektu tzn.. zapytanie zostanie automatycznie.

```java
Criteria crit = session.createCriteria(Supplier.class);
Supplier supplier = new Supplier();
supplier.setName("MegaInc");
crit.add(Example.create(supplier));
List results = crit.list();
```
### Graf encji

[//]: "entity-graph"

https://www.baeldung.com/jpa-entity-graph

Za pomocą grafu możemy zdefiniować które dane chcemy pobrać. Są dwie standardowe strategie pobierania danych `Lazy, Eager`. Strategia leniwa pobiera dane wtedy gdy jest to potrzebne. Dotyczy to głównie relacji do innych encji. Strategia zachłanna powoduje, że wszystkie dane i relacje są pobierane od razu. Oba podejścia mają swoje plusy i minusy. Niewątpliwie plusem strategii leniwej jest mniejsze zużycie danych, ale większa liczba zapytać. Strategii zachłannej odwrotnie. 

Graf encji jest czymś po środku. Pozwala na zdefiniowanie jakie dane mają zostać pobrane od razu. Jeśli wiemy co chcemy przetwarzać to takie podejście pozwala na optymalizacje.

Graf pobierania definiujemy za pomocą adnotacji `NamedEntityGraph` tak ja niżej.

```java
@NamedEntityGraph(
  name = "post-entity-graph-with-comment-users",
  attributeNodes = {
    @NamedAttributeNode("subject"),
    @NamedAttributeNode("user"),
    @NamedAttributeNode(value = "comments", subgraph = "comments-subgraph"),
  },
  subgraphs = {
    @NamedSubgraph(
      name = "comments-subgraph",
      attributeNodes = {
        @NamedAttributeNode("user")
      }
    )
  }
)
@Entity
public class Post {

    @OneToMany(mappedBy = "post")
    private List<Comment> comments = new ArrayList<>();
    //...
}
```

To samo możemy zdefiniować za pomocą XML

```xml
<entity-mappings>
  <entity class="com.baeldung.jpa.entitygraph.Post" name="Post">
    ...
    <named-entity-graph name="post-entity-graph">
            <named-attribute-node name="comments" />
    </named-entity-graph>
  </entity>
  ...
</entity-mappings>
```

 lub programistycznie.

```java
EntityGraph<Post> entityGraph = entityManager.createEntityGraph(Post.class);
entityGraph.addAttributeNodes("subject");
entityGraph.addAttributeNodes("user");
entityGraph.addSubgraph("comments")
  .addAttributeNodes("user");
```

Następnie ten definicji możemy użyć na kilka sposobów.

```java
// 1
EntityGraph entityGraph = entityManager.getEntityGraph("post-entity-graph");
Map<String, Object> properties = new HashMap<>();
properties.put("javax.persistence.fetchgraph", entityGraph);
Post post = entityManager.find(Post.class, id, properties);

// 2
EntityGraph entityGraph = entityManager.getEntityGraph("post-entity-graph-with-comment-users");
Post post = entityManager.createQuery("select p from Post p where p.id = :id", Post.class)
  .setParameter("id", id)
  .setHint("javax.persistence.fetchgraph", entityGraph)
  .getSingleResult();

// 3
EntityGraph entityGraph = entityManager.getEntityGraph("post-entity-graph-with-comment-users");
CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
CriteriaQuery<Post> criteriaQuery = criteriaBuilder.createQuery(Post.class);
Root<Post> root = criteriaQuery.from(Post.class);
criteriaQuery.where(criteriaBuilder.equal(root.<Long>get("id"), id));
TypedQuery<Post> typedQuery = entityManager.createQuery(criteriaQuery);
typedQuery.setHint("javax.persistence.loadgraph", entityGraph);
Post post = typedQuery.getSingleResult();
```

## Operacje na encjach

[//]: "entity-actions"

### Pobieranie określonej encji
Hibernate udostępnia dwie metody do pobrania encji: `load`, `get`. Metody można wywołać w kilku wariantach.

```java
public Object load(Class theClass, Serializable id) throws HibernateException
public Object load(String entityName, Serializable id) throws HibernateException

// Wcztanie danych do obiektu
public void load(Object object, Serializable id) throws HibernateException

public Object get(Class clazz, Serializable id) throws HibernateException
public Object get(String entityName, Serializable id) throws HibernateException
```

Poniżej przykłady:

```java
// Pobranie przez Class<T>
User userA = session.load(User.class, userId);

// Pobranie przez ścieżke do encji
User userB = (User) session.load("com.ttmdear.repository.hibernate.core.domain.User", userId);

// Przekazanie obiektu do wypełnienia
User userC = new User();

session.load(userC, userIdLoad);

// Użycie metody Session.get
User userD = session.get(User.class, userId);
User userE = (User) session.get("com.ttmdear.repository.hibernate.core.domain.User", userId);

// Brak encji
User userF = session.get(User.class, "123");
User userG = session.load(User.class, "123");

try {
    System.out.println("userG: " + userG);
} catch (ObjectNotFoundException e) {
    System.out.println("userG: null");
}
```

W przypadku przekazania obiektu do wypełnienia (wariant trzeci) należy uważać aby dla aktywnej sesji nie istniał obiekt z przekazanym identyfikatorem.

W przypadku duplikatu obiektu zostanie wygenerowany wyjątek:

```
A different object with the same identifier value was already associated with the session
```

W zasadzie nie ma różnicy między metodą `load` i `get`. Jedyna różnica jest taka, że dla metody `get` jeśli obiekt nie zostanie znaleziony to zostanie zwrócony `NULL`, a w przypadku metody `load` zostanie wyrzucony wyjątek - w momencie odwołania się do obiektu.

W sposobie wywołania obu metod w zasadzie nie ma różnic, z tym wyjątkiem, że dla wariantu wczytanie do pustego obiektu nie ma odpowiednia dla metody `get`.

Dla metody `load` zostanie wyrzucony wyjątek `ObjectNotFoundException` jeśli obiekt nie zostanie znaleziony. Wyjątek zostanie wyrzucony w momencie odwołania się do danych.

Obie metody zwracają obiekt typu proxy który może zostać zrzutowany na encję. Wczytanie danych następuje w momencie gdy są one potrzebne.
### Referencja do encji
Poza dwiema metodami `load,get` Hibernate udostępnia metodę `byId` za pomocą której możliwe jest pobranie encji. Różnica między tymi metodami jest taka, że w przypadku dwóch pierwszych od razu pobierane są dane, w przypadku metody `byId`  dane są pobierane dopiero w momencie gdy są potrzebne.

```java
Session session = sessionFactory.openSession();
session.beginTransaction();

User user = createUser();

session.persist(user);
session.getTransaction().commit();
session.close();

// Get user refernce
session = sessionFactory.openSession();

// Pobierana jest tylko referencja, dane zostaną pobrane w momencie gdy bedą potrzebne
User userReference = (User) session.byId(User.class).getReference(user.getId());

session.close();
```

W przypadku mechanizmu trzeba uważać aby dane zostały pobrane zanim sesja zostanie zamknięta. Odwołanie się do danych po zamknięciu danych spowoduje błąd braku sesji.

```java
session.close();

System.out.println("userReference: " + userReference);
```
### Przeładowanie encji
Jest to mechanizm który pozwala na aktualizacje danych do tych w źródle danych.

Dostępna jest metoda `refresh`.

```java
public void refresh(Object object) throws HibernateException
public void refresh(Object object, LockMode lockMode) throws HibernateException
```

Przykład wywołania:

```java
Session session = sessionFactory.openSession();
session.beginTransaction();

User user = createUser();
user.setFirstName("Michał");

session.persist(user);

session.getTransaction().commit();
session.close();

// W ramach drugiej sesji inicj
session = sessionFactory.openSession();

user.setFirstName("Natalia");

System.out.println("user: " + user);

// Aktualizuje dane
session.refresh(user);

session.close();
```
### Zapisywanie i tworzenie encji
Encję można zapisać za pomocą metod `save, saveOrUpdate`. Poniżej przykład:

```java
Session session = sessionFactory.openSession();
session.beginTransaction();

User user = createUser();
user.setFirstName("Dariusz");

session.save(user);

session.getTransaction().commit();
session.close();
```

W przypadku zapisywania nowej encji należy uważać na to, że tak utworzona i zapisana encja będzie widoczna jako nowo utworzona w obrembie sesji. Jeśli otworzymy nową sesję i spróbujemy zapisuwać jeszcze raz obiekt to Hibernate spróbuje go raz jeszcze utworzyć co spowoduje błąd. Poniżej przykład kodu który generuje taki błąd:

```java
// Sesja 1
Session session = sessionFactory.openSession(); session.beginTransaction();

User user = createUser();
user.setFirstName("Dariusz");

session.save(user);

session.getTransaction().commit(); session.close();

// Sesja 2
session = sessionFactory.openSession(); session.beginTransaction();

user.setFirstName("Jolanta");

session.save(user);

session.getTransaction().commit(); session.close();
```

Dzieje się tak dlatego, że sesja druga widzi ten obiekt jako nowy, a w bazie danych istnieje obiekt o takim ID.

Ten problem można rozwiązać przez wczytanie obiektu encji do nowej sesji za pomoca metody `load`.

```java
session.load(user, user.getId());

session.save(user);
```

Można również pobrać nową instancję encji dla nowej sesji za pomocą metody `get`.

Lub użycie metody `saveOrUpdate`.

```java
session.saveOrUpdate(user)
```
### Łączenie danych
Hibernate umożliwia wykonanie operacji merge aktualnych danych z tymi w bazie danych. Jest to przeciwieństwo metody `refresh` w przypadku której wszystkie dane z encji zostają nadpisane.

W przypadku gdy w aktualnej sesji nie ma obiektu o tym samym identyfikatorze to obiekt zostanie pobrany z bazy danych i dane zostaną złączone. 

**Metoda zawsze zwraca instancję obiektu z sesji. Po wykonaniu złączenia dane są od razu zapisywane w bazie danych.**

Metoda `merge` dostępna jest w dwóch wariantach.

```java
Object merge(Object object)
Object merge(String entityName, Object object)
```

Poniżej przykład.

```java
System.out.println("testMerge");

// Sesja 1
Session session = sessionFactory.openSession();

User user = createUser();
session.beginTransaction();

user.setFirstName("Agnieszka");
user.setLastName("Iksińska");

session.persist(user);

session.getTransaction().commit(); session.close();

// Sesja 2
session = sessionFactory.openSession();
session.beginTransaction();

user.setLastName("Wrona");

// Jeśli w sesji w danej sesji isnieie obiekt to zostanie wykorzystany i zwrócony,
// jeśli nie istnieje, to zostanie pobrany i zwrócony.
// Dane są od razu zapisane w bazie.
User userMerged = (User) session.merge(user);

session.getTransaction().commit(); session.close();
```
### Usunięcie instancji encji z sesji
Instancje encji można usunąć za pomocą metod: `eivict, clear`.

```java
// Usuwa jeden obiekt
session.evict(department);

// Czyści całą sesję
session.clear(); 
```
### Porównywanie instancji encji
Porównując dwie encje trzeba pamiętać o dwóch rzeczach:

1. Encja o określonym identyfikatorze w obrębie jednej sesji zawsze będzie taka sama,
2. Encja o określonym identyfikatorze w obrębie kilku sesji, dla każdej z nich będzie inna pomimo, że reprezentują ten sam rekord w bazie danych.

Poniżej przykład porównania instancji encji w ramach tej samej sesji i dwóch różnych:

```java
// Sesja 1
Session session = sessionFactory.openSession(); session.beginTransaction();

User user = createUser();
user.setFirstName("Dariusz");

session.save(user); session.getTransaction().commit();

// Pobieram użytkownika z sesji
User userA = session.load(User.class, user.getId());

System.out.println("user == userA: " + (user == userA));

// Sesja 2
Session session2 = sessionFactory.openSession();

User userB = session2.load(User.class, user.getId());

System.out.println("user == userB: " + (user == userB));

session.close();
session2.close();
```

Wynik:

```
user == userA: true
user == userB: false
```

Oznacza to, że **Dla dwóch różnych sesji będziemy mieli dwie różne instancje tego samego rekordu.**

Można to zmienić np. przez wczytanie określonej instancji obiektu do sesji za pomocą metody `load`

```java
Session session2 = sessionFactory.openSession();

// Wczytujemy obiekt do sesji.
session2.load(user, user.getId());

User userB = session2.load(User.class, user.getId());

System.out.println("user == userB: " + (user == userB));
```

```
user == userA: true
user == userB: true
```

**Metody equal i hashCode**

Jeśli chcemy porównać dwie encje w poprawny sposób za pomocą metody `equals` i to powinniśmy zaimplementować metody `equals` i `hashCode`.
### Walidacja encji
Hibernate udostępnia mechanizmy do walidacji encji.

https://howtodoinjava.com/hibernate/hibernate-validator-java-bean-validation

Definiujemy encję:

```java
package com.howtodoinjava.example.model;
 
import javax.validation.constraints.Email;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
 
public class User {
 
    @NotNull(message = "Please enter id")
    private Long id;
 
    @Size(max = 20, min = 3, message = "{user.name.invalid}")
    @NotEmpty(message = "Please enter name")
    private String name;
 
    @Email(message = "{user.email.invalid}")
    @NotEmpty(message = "Please enter email")
    private String email;
 
    public User(Long id, String name, String email) {
        super();
        this.id = id;
        this.name = name;
        this.email = email;
    }
 
    //Getters and Setters
 
    @Override
    public String toString() {
        return "User [id=" + id + ", name=" + name + ", email=" + email + "]";
    }
}
```

Następnie taka encja może zostać z walidowana:

```java
package com.howtodoinjava.example;
 
import java.util.Set;
 
import javax.inject.Inject;
import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
 
import org.hibernate.validator.cdi.HibernateValidator;
 
import com.howtodoinjava.example.model.User;
 
public class TestHibernateValidator 
{
    @Inject
    @HibernateValidator
    private static ValidatorFactory validatorFactory;
 
    @Inject
    @HibernateValidator
    private static Validator validator;
     
    public static void main(String[] args) 
    {
        //Create ValidatorFactory which returns validator
        validatorFactory = Validation.buildDefaultValidatorFactory();
         
        //It validates bean instances
        validator = validatorFactory.getValidator();
 
        User user = new User(null, "1", "abcgmail.com");
 
        //Validate bean
        Set<ConstraintViolation<User>> constraintViolations = validator.validate(user);
 
        //Show errors
        if (constraintViolations.size() > 0) {
            for (ConstraintViolation<User> violation : constraintViolations) {
                System.out.println(violation.getMessage());
            }
        } else {
            System.out.println("Valid Object");
        }
    }
}
```
## Encja

[//]: "entity"

Reprezentacja wyobrażonego lub rzeczywistego obiektu (grupy obiektów) stosowana przy modelowaniu danych podczas analizy informatycznej. W DDD encja może definiować obiekt domenowy. JPA definiuje sposób deklaracji encji. Poniżej została przedstawiona deklaracja encji `User`.

```java
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String firstName;
    private String lastName;

    @OneToOne
    @JoinTable(
        name = "userEmail",
        joinColumns = {@JoinColumn(name = "userId", referencedColumnName = "id")},
        inverseJoinColumns = {@JoinColumn(name = "emailId", referencedColumnName = "id")}
    )
    private Email email;

    @OneToMany()
    @JoinColumn(name = "USER_ID_FOO")
    private Set<Phone> phones = new HashSet<>();

    @ManyToMany
    @JoinTable(
            name = "USER_TAG",
            joinColumns = {@JoinColumn(name = "USER_ID")},
            inverseJoinColumns = {@JoinColumn(name = "TAG_ID")}
    )
    private Set<Tag> tags = new HashSet<>();
    
}
```
### Klucz podstawowy
...
#### Klucz wielokolumnowy
Klucz podstawowy składający się z kilku kolumn można zdefniować na dwa sposoby:

- za pomocą adnotacji `@EmbeddedId`,
- za pomocą adnotacji `@IdClass`.

**Wykorzystanie adnotacji `@EmbeddedId`**

```java
@Entity
@Data
@NoArgsConstructor
public class UserRole {
    @EmbeddedId
    private UserRoleId userRoleId;

    private boolean active;
    private Date activeFrom;

    @Embeddable
    @Data
    @NoArgsConstructor
    public static class UserRoleId implements Serializable {
        @Enumerated(value = EnumType.STRING)
        private Role role;

        @OneToOne
        private User user;

        @Override
        public String toString() {
            return "UserRoleId{" +
                    "role=" + role +
                    ", user=" + user.getFirstName() +
                    '}';
        }
    }
}
```

Musimy utworzyć klasę typu typu `@Embeddable` która będzie przechowywała wartości pola klucza podstawowego. Klasa musi implementować interfejs `Serializable`.

Następnie w encji bazowej tworzymy pole oraz oznaczamy je jako `@EmbeddedId`.

```java
@EmbeddedId
private UserRoleId userRoleId;
```

**Wykorzystanie `@IdClass`**

```java
@Entity
@IdClass(UserGroupId.class)
@Setter
@Getter
public class UserGroup {
    @Id
    @Column(name = "USER_ID")
    private String userId ;

    @Id
    @Enumerated
    @Column(name = "GR")
    private Group group;

    private Date activeFrom;

    public static class UserGroupId implements Serializable {
        private String userId ;
        private Group group;

        public UserGroupId() { }

        public UserGroupId(String userId, Group group) {
            this.userId = userId;
            this.group = group;
        }
    }
}
```

Tylko nie udało mi się tak jak jest to w `@Embedded` zdefniowania klucza obcego jako obiekt User. W tym przypadku jest to poprostu ciąg znaków.
### Klucz jako sekwencja
```java
@Entity
@Table(name = "M_ZDARZENIA")
public class Zdarzenie extends VersionedModel {
    @Id
    @Column(name = "ID", nullable = false)
    @SequenceGenerator(name = "M_ZDARZENIA_SEQ", sequenceName = "M_ZDARZENIA_SEQ", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "M_ZDARZENIA_SEQ")
    private Long id;

	// ...
}
```
### Relacje
JPA definiuje typy relacji:

- jeden do jednego,
- jeden do wielu,
- wiele do wielu.

W podstawowej konfiguracji każda relacja jest realizowana przez tabelkę złączeniową. 

![Unidirectional one-to-many JPA relationship](../.files/one-to-many.png)

To zachowanie możemy zmienić za pomocą `@JoinColumn`. Istnieje również adnotacja `@JoinTable` która pozwala zdefiniować sposób łączenia przez tabelę złączeniową· Istnieje również parametr `mappedBy` który pozwala na zdefiniowanie relacji dwukierunkowej. W relacji ważne jest również definiowanie encji nadrzędnej oraz podrzędnej.
#### Relacja OneToOne
W tej relacji encja `User` posiada relacje do jednej encji `Email`. Relacja jest zdefiniowana tylko po stronie `User` co oznacza, że jest ona **jednokierunkowa** - tylko `User` może pobrać email.

<table>
    <tr>
        <td>
        	<pre>@Entity
public class User {
	// ...
    @OneToOne
    private Email email;
    // ...
}</pre>
        </td>
        <td>
			<pre>@Entity
public class Email {
    // ...
    private String value;
    // ...
}</pre>
        </td>
    </tr>
</table>

Dla takie relacji zostaną wygenerowane takie tabelki:

**EMAIL**

| ID   | VALUE                    |
| :--- | :----------------------- |
| 1    | pawel.kowalski@gmail.com |

**USER**

| ID   | FIRST_NAME | LAST_NAME | EMAIL_ID |
| :--- | :--------- | :-------- | :------- |
| 1    | Paweł      | Kowalski  | 1        |

Jeśli do encji `Email` dodamy `User` i zdefiniujemy to jako relacje:

```java
@Entity
public class Email {
    // ...
    @OneToOne
    private User user;
}
```

To do tabeli `EMAIL` zostanie dodana kolumna USER_ID. 

**EMAIL**

| ID   | VALUE                    | USER_ID |
| :--- | :----------------------- | :------ |
| 1    | pawel.kowalski@gmail.com | *null*  |

Nie jest to dobre rozwiązanie, ponieważ klucz obcy jest umieszczony po stronie encji `User` wiec nie jest potrzebna kolumna `USER_ID`. W tabeli `EMAIL`. Wygląda to ta, jak by były dwie niezależne od siebie relacje, tak jak tabela `USER` posiada swoją kolumnę `EMAIL_ID`, tak samo `EMAIL` posiada kolumnę `USER_ID`.

Parametr `mappedBy` pozwala na połączenie dwóch encji. Jeśli chcemy użyć parametru `mappedBy` należy zdefiniować stronę właściciela relacji. W naszym przypadku będzie to `User`. Wiec to encji `Email` dodajemy:

```java
@Entity
public class Email {
    // ...
    @OneToOne(mappedBy = "email")
    private User user;
}
```

W takim przypadku kolumna `USER_ID` zostanie usunięta z tabeli `EMAIL` i email zostanie zmapowany na pole `email` w encji `User`. Kolumny złączeniowe można zdefiniować za pomocą `@JoinColumn`.

Inny przypadek takiej relacji One-To-One.

```java
public class ProviderGroup {
    @OneToOne(mappedBy = "providerGroup", fetch = FetchType.LAZY, cascade = ALL)
    private ProviderGroupLogo logo2;
}

public class ProviderGroupLogo {
    @OneToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "PRGRLO_PRGR_ID")
    private ProviderGroup providerGroup;
}
```
#### Relacja OneToMany
Czyli relacja jeden-do-wielu. W takiej relacji jedna encja posiada listę pozostałych encji.

Taka relację możemy zamodelować w taki sposób:

```java
@OneToMany
private Set<Phone> phones = new HashSet<>();
```

Spowoduje to, że powstanie tabela `USER_PHONES`. W tabela będzie przetrzymywała ID telefonu oraz ID użytkownika. Jest to relacja jednokierunkowa. Encja `Phone` nie ma połączenia z encją `User`.

`SELECT * FROM USER_PHONES`

| USER_ID | PHONES_ID |
| :------ | :-------- |
| 1       | 1         |

Jest to podstawowe zachowanie, jeśli chcielibyśmy teraz zdefniować aby przy tej relacji nie była tworzona tabelka złączeniowa `USER_PHONE` to musimy zdefiniować kolumne złączeniową `@JoinColumn`.

Definiuje kolumnę złączeniową.

```java
@OneToMany()
@JoinColumn(name = "USER_ID_FOO")
private Set<Phone> phones = new HashSet<>();
```

W takiej relacji możliwe jest zamodelowanie jej na dwóch tabelkach `USER`, oraz `PHONE` gdzie w `PHONE.USER_ID_FOO`.

`SELECT * FROM PHONE`

| ID   | VALUE     | USER_ID_FOO |
| :--- | :-------- | :---------- |
| 1    | 722397244 | 1           |
#### Relacja @ManyToMany
W zasadzie relacja ManyToMany jest bardzo podobna do relacji OneToMany.

```java
@ManyToMany
@JoinTable(
    name = "USER_TAG",
    joinColumns = {@JoinColumn(name = "USER_ID")},
    inv	erseJoinColumns = {@JoinColumn(name = "TAG_ID")}
)
private Set<Tag> tags = new HashSet<>();
```
#### Adnotacja @JoinColumn
Adnotacja pozwala na zdefiniowanie kolumny złączeniowej.

```java
public class User {
	// ...
    @OneToMany()
    @JoinColumn(name = "USER_ID_FOO")
    private Set<Phone> phones = new HashSet<>();
    	// ...
}

@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)
@Fetch(value = FetchMode.SUBSELECT)
@JoinColumns({
    @JoinColumn(name = "mccpaId", referencedColumnName = "mccpaId", insertable = false, updatable = false),
    @JoinColumn(name = "cpaVersionId", referencedColumnName = "mccpaVersionId", insertable = false, updatable = false),
})
List<MccpaCpaRelEntity> relatedCpas;
```

W powyższym przykładzie do złączenia zostanie wykorzystana kolumna `PHONE.USER_ID_FOO`. Bez zdefiniowania kolumny relacja zostanie zrealizowana przez tabelę złączeniową: `USER -> USER_PHONE -> PHONE`. Co nie zawsze jest oczekiwane.
#### Adnotacja @JoinTable
Adnotacja pozwala na zdefiniowanie tabeli złączeniowej. Jest wykorzystywana w relacjach `OneToOne, OneToMany, Many-To-Many`. Poniże każda z tych relacji może mieć swoją realizację przez tabelę złączeniową.

Ogólnie się przyjęło, że tylko relacja ManyToMany potrzebuje tabeli złączeniowej, ale taka tabelę złączeniową mogą mieć również pozostałe relację.

Poniżej została zamodelowana relacja One-To-One z wykorzystaniem tabeli złączeniowej.

```java
@OneToOne
@JoinTable(
    name = "userEmail",
    joinColumns = {@JoinColumn(name = "userId")},
    inverseJoinColumns = {@JoinColumn(name = "emailId")}
)
private Email email;
```

`joinColumns` - są to kolumny złączeniowe od strony tabeli nadrzędnej.

`inverseJoinColumns` - są to kolumny od strony podrzędnej.

Warunek możemy zapisać również:

```
joinColumns = {@JoinColumn(name = "userId", referencedColumnName = "id")},
inverseJoinColumns = {@JoinColumn(name = "emailId", referencedColumnName = "id")}
```

`referencedColumnName` to kolumna złączeniowa w tabeli nadrzędnej/podrzednej.
#### Adnotacja @JoinColumn/@JoinColumns
Adnotacja pozwala na zdefiniowanie jakie kolumny zostaną użyte do stworzenia relacji.

```java
@Entity
public class User {
	// ...
    @OneToOne
    private Email email;
    // ...
}
```

Spowoduje, że w tabeli `USER` zostanie utworzona kolumna `EMAIL_ID` w której będzie przechowywany identyfikator maila. Jest to równoznaczne z napisanie: `@JoinColumn(name = "email_id", referencedColumnName = "id")`.

Adnotację `@JoinColumn, @JoinColumns` pozwalają na zdefiniowanie kolumn po których zostanie zrealizowane złączenie.

Jeśli chcemy zdefiniować inny warunek złączenia np. `email_id_foo = email_id_foo` to robimy to w następujący sposób:

```java
@OneToOne
@JoinColumn(name = "email_id_foo", referencedColumnName = "email_user_id")
private Email email;
```

**EMAIL**

| ID   | EMAIL_USER_ID | VALUE                    |
| :--- | :------------ | :----------------------- |
| 1    | foot-123      | pawel.kowalski@gmail.com |

**USER**

| ID   | FIRST_NAME | LAST_NAME | EMAIL_ID_FOO |
| :--- | :--------- | :-------- | :----------- |
| 1    | Paweł      | Kowalski  | foot-123     |

Trzeba sprawdzić wariant `@JoinColumns`, nie chciało mi działać.

#### Relacja `Embedded`
Jest to relacja w której  encja jest traktowana jako cześć encji nadrzędnej.

Poniżej mamy definicje encji `Audit`, jest ona oznaczona jako `Embeddable` oznacza to, że może być ona traktowana jako cześć innej encji.

```java
@Embeddable
public class Audit {
    @Column(name = "created_on")
    private LocalDateTime createdOn;
 
    @Column(name = "created_by")
    private String createdBy;
     
    @Column(name = "updated_on")
    private LocalDateTime updatedOn;
 
    @Column(name = "updated_by")
    private String updatedBy;
 
    @PrePersist
    public void prePersist() {
        createdOn = LocalDateTime.now();
        createdBy = LoggedUser.get();
    }
 
    @PreUpdate
    public void preUpdate() {
        updatedOn = LocalDateTime.now();
        updatedBy = LoggedUser.get();
    }
 
    //Getters and setters omitted for brevity
}

// Definicja encji
@Entity(name = "Post")
@Table(name = "post")
public class Post {
 
    @Id
    private Long id;
 
    private String title;
     
    @Embedded
    private Audit audit = new Audit();
 
    @ManyToMany
    @JoinTable(
        name = "post_tag",
        joinColumns = @JoinColumn(name = "post_id"),
        inverseJoinColumns = @JoinColumn(name = "tag_id")
    )
    private List<Tag> tags = new ArrayList<>();
 
    //Getters and setters omitted for brevity
}
 
@Entity(name = "Tag")
@Table(name = "tag")
public class Tag {
 
    @Id
    private String name;
 
    @Embedded
    private Audit audit = new Audit();
 
    //Getters and setters omitted for brevity
}
```

Tak zdefiniowana relacja spowoduje, że zostanie utworzona tabelka `name, created_on, created_by, updated_on, updated_by`.

### Dziedziczenie
```java
@Entity
@Inheritance(strategy = SINGLE_TABLE)
@DiscriminatorColumn(
    name="DISCRIMINATOR",
    discriminatorType=INTEGER
)
@DiscriminatorValue("1")
public class Book {
...
}
 
//A Derived Entity in the Inheritance Hierarchy
@Entity
@DiscriminatorValue("2")
public class ComputerBook extends Book {
...
}
```
JPA definiuje kilka sposób mapowania dziedziczenia na relacje.

#### @MappedSuperclass
Klasa nadrzędna definiuje strukturę ale nie może być encją. Klasy rozszerzające mają swoje tabele i dodatkowe pola.

```java
@MappedSuperclass
public class Person {
    @Id
    private long personId;
    private String name;

    // constructor, getters, setters
}

@Entity
public class MyEmployee extends Person {
    private String company;
    // constructor, getters, setters 
}
```

#### Single Table
Tworzona jest jedna tabela dla wszystkich klas w hierarchii. Jest to standardowe zachowanie. Jeśli np. mamy encję **Animal, Cat extends Animal, Dog extends Animal** wtedy mamy jedną tabelę **Animal** ze wszystkimi rekordami.

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class MyProduct {
    @Id
    private long productId;
    private String name;

    // constructor, getters, setters
}

@Entity
public class Book extends MyProduct {
    private String author;
}

@Entity
public class Pen extends MyProduct {
    private String color;
}
```

Dodatkowo przy takim mapowaniu trzeba ustawić adnotację  `@DiscriminatorColumn` aby było możliwe rozróżnienie rekordów.

```java
@Entity(name="products")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name="product_type", 
  discriminatorType = DiscriminatorType.INTEGER)
public class MyProduct {
    // ...
}

@Entity
@DiscriminatorValue("1")
public class Book extends MyProduct {
    // ...
}
@Entity
@DiscriminatorValue("2")
public class Pen extends MyProduct {
    // ...
}

// @DiscriminatorValue(“null”)
// @DiscriminatorValue(“not null”) 
```

#### Joined Table
Tabela podrzędna jest łączona z nadrzędną. Do złączenia użyty jest klucz podstawowy.

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Animal {
    @Id
    private long animalId;
    private String species;

    // constructor, getters, setters 
}

@Entity
public class Pet extends Animal {
    private String name;

    // constructor, getters, setters
}
```

Kolumnę złączeniową możemy ustawić w taki sposób.

```java
@PrimaryKeyJoinColumn(name = "petId")
```

#### Table per Class
W takiej relacji dla każdej encji jest osobna tabela.

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class Vehicle {
    @Id
    private long vehicleId;

    private String manufacturer;

    // standard constructor, getters, setters
}
```

#### Problem z dziedziczeniem

Miałem dwie klasy `UserEntity` oraz `UserTEntity`. Klasa `UserEntity` rozszerzała klasę `UserTEntity` w taki sposób, że obie miały zdefiniowane swoje tabele, czyli jest to sposób `TABLE_PER_CLASS`. W kodzie miałem taka implementację, że tworzyłem `UserTEntity` przez repozytorium `A` i następnie pobierałem encję `UserEntity` z repozytorium `B`.  Z jakiego powodu repozytorium `B` nie zwracało nowo utworzonej encji pomimo, że rekord był już w bazie danych. 

Wydaje się, że problem jest spowodowany tym, że `UserEntity` jest pod typem `UserTEntity`. Dodam jeszcze, że `UserEntity` nie definiowało żadnych pól itp. to była klasa która tylko rozszerzała.

Rozwiązaniem problemu była zmiana sposoby dziedziczenia na `MappedSuperclass` i dodanie trzeciej encji która tylko definiowała strukturę. Dopiero wtedy mieliśmy dostęp do nowo utworzonej encji. 

### Typy enumerowane

JPA pozwala na mapowanie obiektów typu ENUM. Definiujemy typ:

```java
public enum Difficulty {
    EASY,
    MODERATE,
    KIND_OF_HARD,
    HARD
}

```

Definiujemy encję z tego typu atrybutem.

```java
@Entity
public class Recipe {
	// ...

    @Enumerated(value = EnumType.STRING)
    private Difficulty difficulty;
	// ...
}
```

Atrybut typu ENUM jest oznaczony adnotacją `@Enumerated`. Dodatkowo jako parametr przekazujemy w jaki sposób ma zostać zapisana wartość w bazie danych. Mamy tutaj dwie możłiwości:

- EnumType.String,
- EnumType.ORDINAL.

W przypadku `EnumType.String` dane zapisywane są tak samo jak nazwa wartości, czyli dla `HARD` będzie wpisane `HARD`. 

W przypadku `EnumType.ORDINAL` do bazy danych zostanie zapisana wartość liczbowa pozycji na którym została zdefniowana wartość np. dla `HARD` będzie to `4`. **Taki zapis jest ryzykowany ponieważ dodanie nowej wartości ENUMA w środku listy spowoduje przesunięcie całej listy i dezaktualizację z bazą.**

Dlatego dobrym rozwiązaniem jest stosowanie typu EnumType.STRING.

Możliwe jest zastosowanie konwerterów jeśli np. nie checemy przechowywać całej wartości.

Przykładowy konwerter może wyglądać następująco:

```java
public class UserTypeConverter implements AttributeConverter<UserType, String> {

    @Override
    public String convertToDatabaseColumn(UserType userType) {
        if (userType.equals(UserType.ADMIN)) {
            return "a";
			//...
        }

        return null;
    }

    @Override
    public UserType convertToEntityAttribute(String s) {
        if (s.equals("a")) {
            return UserType.ADMIN;
			//...
        }

        return null;
    }
}
```

Następnie przy polu musimy zadeklarowac aby został użyty.

```java
@Column
@Convert(converter = UserTypeConverter.class)
private UserType type;
```

Konwertery można wykorzystać w innych przypadkach konwersji bardziej złożonych typów.
## Adnotacje

[//]: "adnotations"

| Adnotacja           | Opis                                                         |
| ------------------- | ------------------------------------------------------------ |
| @Entity             |                                                              |
| @SelectBeforeUpdate |                                                              |
| @DynamicInsert      |                                                              |
| @DynamicUpdate      |                                                              |
| @Polymorphism       | `@Polymorphism (type = PolymorphismType.EXPLICIT)`           |
| @OptimisticLocking  |                                                              |
| @Id                 | Wskazuje na klucz podstawowy encji                           |
| @GeneratedValue     | Definiuje w jaki sposób jest generowana wartość klucza.      |
| @TableGenerator     | Pozwala na zdefniowanie tabeli na postawie której jest generowana wartość klucza `@GeneratedValue (strategy=GenerationType.TABLE , generator="employee_generator")` |
| @SequenceGenerator  | Służy do przekazania informacji, że klucz jest generowany przez określona sekwencję. |
| @Embeddable         | Pozwala oznaczyć, że dane pole skłąda się z kilu innych. Inne pola są określone w innej klasie. |
| @EmbeddableId       | Określna, że pole osadzone jest kluczem podstawowym          |
| @IdClass            | Określa, że klasa jest kluczem podstawowym                   |
| @Table              | Podstawowa tabela z danymi                                   |
| @SecondaryTable     | W przypadku gdy dane są w kilku tabelach możliwe jest podanie tych tabel za pomocą tej adnotacji. |
### Adnotacja @Table, @SecondaryTable
  W przypadku gdy dane są w kilku tabelach możliwe jest podanie tych tabel za pomocą tej adnotacji.

```java
@Entity
@Table(name = "EMPLOYEE")
@SecondaryTable(name = "EMPLOYEE_DETAILS", pkJoinColumns = @PrimaryKeyJoinColumn(name = "EMPLOYEE_ID"))
```
### Adnotacja @Basic
```java
@Basic (fetch = FetchType.LAZY, optional = false)
private String  firstName;
```

Jest to podstawowa adnotacja dla pola (nie musi być podana) za pomocą której można zmienić konfigurację dla zwykłych pól.
### Adnotacja @Transient
Za pomocą tej adnotacji oznaczamy pola które maja zostać pominięte przy aktualizacji z baza danych bo np. są wyliczeniowe.

```java
@Transient
private Integer age;
```
### Adnotacja @Column
Służy do ustawienia danych o klumnie która jest mapowana na pole.

```java
@Column(name="FNAME",length=100,nullable=false)
private String  firstName;
```
### Adnotacja @Temporal
Adnotacja pozwala na skonfigurowanie sposobu przechowywania czasu w bazie danych. W standardowej konfiguracji pola typu Date,Time, i Timestamp zostaną przekonwertowane na Timestamp po stronie bazy danych. Nie zwsze jest to oczekiwane.

Adnotacja @Temportal pozwala na zdefniowanie innego zachowania niż standardowe.

```java
@Temporal
private Date joinedDate;// W bazie zostanie zapisany Timestamp

@Temporal(TemporalType.DATE)
private Date joinedDate;// W bazie zostanie zapisana data 08-07-17

@Temporal(TemporalType.TIME)
java.util.Date startingTime;
```
### Adnotacja @ElementCollection i @CollectionTable
![Hibernate Spring Boot JPA @ElementCollection example table structure](../../../.files/hibernate-spring-boot-jpa-element-collection-table-structure.jpg)

Jeśli mamy relacje taką jak wyżej i w ramach atrybuty chcemy otrzymac listę wszystkich z innej tabeli.

Możemy to zdefniować w następujący sposób:

```java
@ElementCollection
@CollectionTable(name = "user_phone_numbers", joinColumns = @JoinColumn(name = "user_id"))
@Column(name = "phone_number")
private Set<String> phoneNumbers = new HashSet<>();

@ElementCollection(fetch = FetchType.LAZY)
@CollectionTable(name = "user_addresses", joinColumns = @JoinColumn(name = "user_id"))
@AttributeOverrides({
    @AttributeOverride(name = "addressLine1", column = @Column(name = "house_number")),
    @AttributeOverride(name = "addressLine2", column = @Column(name = "street"))
})
private Set<Address> addresses = new HashSet<>();
```
### Adnotacja @Lob
Definiuje, że kolumna powinna byc mapowana w tgz. Large Object. W połączeniu z adnotacją `@Column` można zdefniować w jakim typie danych mają być przechowywane dane.

```java
@Lob
@Column(name = "photo", columnDefinition="BLOB")
private byte[] photo;
```
### Adnotacja `@MappedSuperclass`
Adnotacja pozwala na zdefiniowanie klasy (encji) którą mogą rozszerzać inne encje, takiej bazowe. Jednocześnie nie będzie ona traktowana jako encja którą trzeba zmapować.

```java
package com.ttmdear.repository.jpa.domain;

import javax.persistence.*;
import java.time.LocalDateTime;

@MappedSuperclass
public class BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDateTime createdOn;
    private String createdBy;
    private LocalDateTime updatedOn;
    private String updatedBy;

    // ...
    
    @PrePersist
    public void prePersist() {
        createdOn = LocalDateTime.now();
        createdBy = "Jan Kowalski";
    }

    @PreUpdate
    public void preUpdate() {
        updatedOn = LocalDateTime.now();
        updatedBy = "Jan Kowalski";
    }
}
```

Do takiej encji możemy np. wrzucić wszystkie kolumny podstawowe które np. są w każdej encji.
### Adnotacja `@DynamicUpdate`
Adnotacja powoduje, że Hibernate przy operacji UPDATE do polecenia SQL (i innych) doda tylko te kolumny które uległy zmianie.

Np. jeśli mamy taką encję:

```java
@Entity
public class Account {
 
    @Id
    private int id;
 
    @Column
    private String name;
 
    @Column
    private String type;
 
    @Column
    private boolean active;
 
    // Getters and Setters
}
```

To bez opcji DynamicUpdate zawsze jest generowane zapytanie:

```sql
update Account set active=?, name=?, type=? where id=?
```

Natomiast z opcja, generowane jest zapytanie tylko z kolumnami które się zmieniły.

```sql
update Account set name=? where id=?
```
### Adnotacja @OrderColumn
Pozwala na zdefniowanie sposobu sortowania dla listy w ramach relacji.

```java
@OneToMany
@OrderColumn(
   name="employeeNumber"
)
List<Employee> employees;
```
### Adnotacja @NamedQuery i @NamedQueries
Służą do defniowania nazwanych zapytań w języki HQL.

```java
@Entity
@NamedQuery(
        name="findAuthorsByName",
        query="from Author where name = :author"
)
public class Author {
...
}
```
### Adnotacja @NamedNativeQuery i @NamedNativeQueries
Służą do defniowania zapytań w języku natywnym.

```java
@NamedQueries({
   @NamedQuery(name="get-emp-by-name",query="FROM EmployeeBean WHERE fName=:fName")
})
 
// Equivalent NamedNativeQuery
@NamedNativeQueries(
    {
        @NamedNativeQuery(
            name="get-emp-by-name-native",
            query="SELECT * FROM Employees WHERE firstName=:fName",
            resultClass=EmployeeEntity.class)
    }
)
```
### Adnotacja @Immutable
Pozwala na oznaczenie encji jako niezmiennej. Dzięki temu Hibernate może optymalizować dostęp do encji w taki sposób, że encja zostanie pobrana a nastepnie może być pobierana wyłącznie z pamięci podręcznej.

```java
import org.hibernate.annotations.Immutable;
 
@Immutable
@Entity
@Table(name = "Employee")
public class EmployeeEntity implements Serializable
{
    private static final long serialVersionUID = -1798070786993154676L;
     
    @Id
    @Column(name = "ID", unique = true, nullable = false)
    private Integer           employeeId;
    @Column(name = "FIRST_NAME", unique = false, nullable = false, length = 100)
    private String            firstName;
    @Column(name = "LAST_NAME", unique = false, nullable = false, length = 100)
    private String            lastName;
 
    //Setters and Getters
}
```
### Adnotacja @NaturalId
Pozwala na oznaczenie danego pola jako klucz naturalny dla encji.

```java
@Entity
@Table(name = "Employee")
public class EmployeeEntity implements Serializable
{
   private static final long serialVersionUID = -1798070786993154676L;
   @Id
   @Column(name = "ID", unique = true, nullable = false)
   private Integer           employeeId;
   @Column(name = "FIRST_NAME", unique = false, nullable = false, length = 100)
   private String            firstName;
   @Column(name = "LAST_NAME", unique = false, nullable = false, length = 100)
   private String            lastName;
    
   //Natural id can be SSN as well
   @NaturalId
   Integer SSN;
    
   //Setters and Getters
}
```

Taką encje możemy następnie pobrać w taki sposób.

```java
EmployeeEntity employee2 = (EmployeeEntity) sessionOne.bySimpleNaturalId(EmployeeEntity.class).load(12345);
```

### Adnotacja `@EntityListeners`

Adnotacja pozwala na podpięcie mechanizmu do nadsłuchiwania zdarzeń na encji.

```java
public class AuditTrailListener {
    private static Log log = LogFactory.getLog(AuditTrailListener.class);
    
    @PrePersist
    @PreUpdate
    @PreRemove
    private void beforeAnyUpdate(User user) {
        if (user.getId() == 0) {
            log.info("[USER AUDIT] About to add a user");
        } else {
            log.info("[USER AUDIT] About to update/delete user: " + user.getId());
        }
    }
    
    @PostPersist
    @PostUpdate
    @PostRemove
    private void afterAnyUpdate(User user) {
        log.info("[USER AUDIT] add/update/delete complete for user: " + user.getId());
    }
    
    @PostLoad
    private void afterLoad(User user) {
        log.info("[USER AUDIT] user loaded from database: " + user.getId());
    }
}
```

Podpięcie pod encję.

```java
@EntityListeners(AuditTrailListener.class)
@Entity
public class User {
    //...
}
```

Możemy również zdefiniować metody w encji.

```java
@Entity
public class User {
    private static Log log = LogFactory.getLog(User.class);

    @Id
    @GeneratedValue
    private int id;
    
    // Standard fields/getters/setters
    
    @PrePersist
    public void logNewUserAttempt() {
        log.info("Attempting to add new user with username: " + userName);
    }

    @PostPersist
    public void logNewUserAdded() {}
    @PreRemove
    public void logUserRemovalAttempt() {}
    @PostRemove
    public void logUserRemoval() {}
    @PreUpdate
    public void logUserUpdateAttempt() {}
    @PostUpdate
    public void logUserUpdate() {}
    @PostLoad
    public void logUserLoad() {}
}
```

## Pozostałe

[//]: "other"

### Merge i Update

[//]: "merge-update"

Jeśli w ramach sesji mamy obiekt o określonym identyfikatorze i następnie spróbujemy w ramach innej sesji wykonać aktualizację i jeśli obiekt o takim samym identyfikatorze istnieje to zostanie wyrzucony wyjątek `NonUniqueObjectException`.

```java
Session session = factory.getCurrentSession();
Customer customer = (Customer) session.get(Customer.class, 1L);
session.getTransaction().commit();
customer.setFirstName("John");
beginTransaction();
session = factory.getCurrentSession();
session.get(Customer.class, 1L);
// Fail here
session.update(customer);
```

Ten problem można rozwiązać przez użycie operacji `merge` powoduje ona, że po pierwsze nie zostanie wyrzucony wyjątek a po drugie dane zostaną połączone z dwóch instancji encji.

```java
Session session = factory.getCurrentSession();
Customer customer = (Customer) session.get(Customer.class, 1L);
session.getTransaction().commit();
customer.setFirstName("John");
beginTransaction();
session = factory.getCurrentSession();
session.get(Customer.class, 1L);
// Succeeds!
session.merge(customer);
```

### Logiczny DELETE

[//]: "logic-delete"

Logiczny DELETE polega na tym, że rekord nie jest usuwany z tabeli fizycznie tylko oznaczamy go jako usunięty. Możemy to realizować na kilka sposób. Za pomocą Hibernate możemy zrobić to w taki sposób, że definiujemy podstawowy filtr które powoduje, że już usunięte rekordy zostaną pominięte.

```java
@Entity
@FilterDef(name = "activeProducts")
@Filter(name = "activeProducts", condition = "DELETION_DATE IS NULL")
public class Product {
  @Id
  @Column(nullable = false)
  @GeneratedValue(strategy = AUTO)
  private Integer id;
...
}
```

Aktywacja np. w taki sposób.

```java
session.enableFilter("activeProducts");
```

Natomiast operację usuwania definiujemy następująco.

```java
@SQLDelete(sql = "UPDATE PRODUCT SET DELETION_DATE=CURRENT_DATE WHERE ID=?")
```

Lub nadpisać metodę w repozytorium. 

### Różnica `get`  i `load`

[//]: "get-load"

Mamy dostępne dwie metody do pobrania encji. W przypadku metody `get` zwraca jest instancja encji. Metoda `get ` zwraca `null` jeśli obiekt nie zostanie odnaleziony.

```java
Session session = factory.getCurrentSession();
Owner owner = (Owner) session.get(Owner.class, 1);
// Test the class of the object
assertSame(owner.getClass(), Owner.class);
```

Metoda `load` natomiast zwraca obiekt proxy. Obiekt proxy powoduje, że dane nie są od razu pobierane. Dopiero w chwili odwołania się do danych czyli np. użycie geterów rekor zostaje pobrany.

```
Session session = factory.getCurrentSession();
Owner owner = (Owner) session.load(Owner.class, 1);
// Test the class of the object
assertNotSame(owner.getClass(), Owner.class);
```

### Filtrowanie

[//]: "filter"

```java
@Entity
@FilterDef(name="userRecipient", 
parameters=@ParamDef(name="userParam", type="PAKAGE.User" ))
@Table(name = "message_table", catalog = "your_db")
public class Message{

...
@OneToMany(fetch = FetchType.LAZY, mappedBy = "stock")
@Filter(name = "userRecipient",condition="user = :userParam")
public List<MessageUser> msgUserList;
    
// Użycie
Filter filter = session.enableFilter("userRecipient");
filter.setParameter("userParam", myUser);
    
    
// Inny przykład
@Entity
@Table(name = "TESTCASE_NEW")
@FilterDefs({
        @FilterDef(name = "TESTCASE_NAME_FILTER", defaultCondition = "TESTCASENAME like :TESTCASENAME", parameters = { @ParamDef(name = "TESTCASENAME", type = "string") }),
        @FilterDef(name = "TEST_RUN_ID_FILTER", defaultCondition = "TESTRUNID in (:IDS)", parameters = { @ParamDef(name = "IDS", type = "int") })
})
public class TestCase implements Serializable
{
    private static final long serialVersionUID = 1L;

    @Id
    @Column(name = "TESTCASEID")
    private int ID;

    @Column(name = "TESTCASENAME")
    private String name;
}

@Entity
public class Category implements Serializable
{
    private static final long serialVersionUID = 1L;

    @Id
    @Column(name = "CATEGORYID")
    private int ID;

    @Column(name = "CATEGORYNAME")
    private String name;

    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "CATEGORYID")
    @OrderBy("TESTCASEID desc")
    @Filters({
            @Filter(name = "TEST_RUN_ID_FILTER"),
            @Filter(name = "TESTCASE_NAME_FILTER") })
    private Collection<TestCase> testCases;
}
```

### Łączenie z filtrowaniem

[//]: "join-with-filter"

```java
@Entity
public class A implements Serializable{
    @Id
    @Column(name = "REF")
    private int ref;

    @OneToMany
    @JoinColumn(name = "A_REF", referencedColumnName = "REF")   
    @Filter(name="test")
    private Set<B> bs;
}

@Entity
@FilterDef(name="test", defaultCondition="other = 123")
public class B implements Serializable{
    @Id
    @Column(name = "A_REF")
    private int aRef;

    @Id
    @Column(name = "OTHER")
    private int other;
}

Session session = entityManager.unwrap(Session.class);
session.enableFilter("test");
A a = entityManager.find(A.class, new Integer(0))
a.getb().size() //Only contains b that are equals to 123
```

### Łączenie z formułą

[//]: "join-with-formula"

Mechanizm pozwala na zdefiniowanie formuły do wykonania złączenia. Służą do 

```java
@ManyToOne
@JoinColumnOrFormula(column = @JoinColumn(name = "language", referencedColumnName = "primaryLanguage", insertable = false, updatable = false))
@JoinColumnOrFormula(formula = @JoinFormula(value = "true", referencedColumnName = "is_default"))
private Country country;

// Inny przykład
@JoinFormula("REGEXP_REPLACE(phoneNumber, '\\+(\\d+)-.*', '\\1')::int")
```

### Łączenie z warunkiem

[//]: "join-with-condition"

Jednym ze sposób dodanie dodatkowego warunku w ramach złączenia możemy użyć adnotacji `@Where`.

```java
@Entity
public class System {
  @Id
  @Column(name = "ID")
  private Integer id;

  @OneToMany(mappedBy = "system")
  @Where(clause = "active = true")
  private Set<Systemproperty> systempropertys;
}

@Entity
public class Systemproperty {
  @Id
  @Column(name = "ID")
  private Integer id;

  @Id
  @Column(name = "ACTIVE")
  private Integer active;
}

// Inny przykład
@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)
@Fetch(value = FetchMode.SUBSELECT)
@JoinColumn(name = "opportunityId", referencedColumnName = "opptyId", insertable = false, updatable = false)
@Where(clause = "PARENT_OFFER_ID = 0")
private List<OfferListEntity> offers;
```

### Biblioteka c3p0

[//]: "c3p0"

Biblioteka do optymalizacji i zarządzania połączeniami JDBC.
### Błąd `could not initialize proxy - no Session`

[//]: "could-not-initialize-proxy"

Ten typ błędu pojawia się w momencie gdy chcemy zainicjować obiekt (encję) w momencie gdy sesja z którą encja została powiązana została zamknięta. 

Błąd najczęściej występuje w przypadku encji które mają zdefiniowane pola typu `FetchType.LAZY`.

Poniżej mam przykład encji `User` ze zdefiniowanym polem `phones` które są doczytywane w razie potrzeby.

```java
public class User extends Entity {

    @Column(name = "FIRST_NAME")
    private String firstName;
	// ...

    @OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumns(value = @JoinColumn(name = "OWNER_ID"), foreignKey = @ForeignKey(name = "none"))
    private Set<Phone> phones = new HashSet<>();
}
```

Poniżej został umieszczony przykład w którym pobieramy encje w ramach sesji, następnie sesje zamykamy i próbujemy odwołać się do obiektu (metoda `toString` odwołuje się do pola `phones`).

```java
session = sessionFactory.openSession();

User userH = session.get(User.class, userIdAfter);

session.close();

System.out.println("userH: " + userH);
```

Powyższy przykład wygeneruje błąd:

```
could not initialize proxy - no Session
```

Wynika to stąd, że sesja powiązana z encja została już zamknięta, dlatego nie można wczytać listy telefonów.

Problem można rozwiązać przez zainicjowanie pół przed typu `LAZY` przed zamknięciem sesji. Pola możemy zainicjować przez proste odwołanie się do kolekcji obiektów np. za pomoca metody `size` lub użycie statycznej metody `Hibernate.initialize()`.

```java
User userH = session.get(User.class, userIdAfter);

// Odwołanie się do sesji
userH.getPhones().size();

// Wykorzystanie metody do inicjalizacji
Hibernate.initialize(userH.getPhones());

session.close();

System.out.println("userH: " + userH);
```

Możliwy jest również tgz. reattach. Czyli przepięcie do innej sesji encji.

```java
session.close();

// Otwieramy nową sesję
session = sessionFactory.openSession();

// Przepinamy encje do nowej sesji.
session.update(userH);

System.out.println("userH: " + userH);
```
### Adnotacje `PrePersist, PreUpdate`

[//]: "pre-persist-update"

Pozwalają na oznaczenie metod które mają sie wykonać przed zapisaniem encji i przed aktualizacją.

Można je wykrzystac np. do uzupełniania informacji w kolumnach:

```java
// ...
public class Audit {
 
    @Column(name = "created_on")
    private LocalDateTime createdOn;
 
	// ...
 
    @PrePersist
    public void prePersist() {
        createdOn = LocalDateTime.now();
        createdBy = LoggedUser.get();
    }
 
    @PreUpdate
    public void preUpdate() {
        updatedOn = LocalDateTime.now();
        updatedBy = LoggedUser.get();
    }

}
```
### Adnotacje `CreationTimestamp, UpdateTimestamp`

[//]: "creation-update-timestamp"

Pozwalają na oznaczenie pól które będą wypełniane czasem przy tworzeniu i aktualizcji w Hibernate.

```java
@Column(name = "CreatedDate", updatable=false)
@CreationTimestamp
private Timestamp createdDate;

@Column(name = "ModifiedDate")
@UpdateTimestamp
private Timestamp modifiedDate;
```
### Adnotacja `@NamedQuery`

[//]: "named-query"

Adnotacja pozwala na zapisanie zapytania pod określoną nazwą.

Zapytania definiuje się przy encji.

```java
@Entity
@NamedQueries({
    @NamedQuery(name="Country.findAll",
                query="SELECT c FROM Country c"),
    @NamedQuery(name="Country.findByName",
                query="SELECT c FROM Country c WHERE c.name = :name"),
}) 
public class Country {
  ...
}
```

Zapytanie można wywołać w taki sposób:

```java
TypedQuery<Country> query =
      em.createNamedQuery("Country.findAll", Country.class);
  List<Country> results = query.getResultList();

// Lub bezpośrednio
Query query = em.createNamedQuery("Country.findAll");
  List results = query.getResultList();
```
### Statyczny model

[//]: "static-model"

 https://docs.jboss.org/hibernate/stable/jpamodelgen/reference/en-US/html_single/#introduction 

Jest to mechanizm do generowania metamodelu. Wygenerowane metamodele mogą zostać wykorzystane do budowania zapytań. Korzystając z meta modelu uwzględniamy mocne typowanie.

```java
@Entity
public class Order {
    @Id 
    @GeneratedValue
    Integer id;
    
    @ManyToOne 
    Customer customer;
    
    @OneToMany 
    Set<Item> items;
    BigDecimal totalCost;
    
    // standard setter/getter methods
    ...
}

@Entity  
public class Item {
    @Id
    @GeneratedValue
    Integer id;

    int quantity;

    @ManyToOne
    Order order;

    // standard setter/getter methods
    ...
}
```

Metamodel dla encji `Order`:

```java
@StaticMetamodel(Order.class)
public class Order_ {
    public static volatile SingularAttribute<Order, Integer> id;
    public static volatile SingularAttribute<Order, Customer> customer;
    public static volatile SetAttribute<Order, Item> items;
    public static volatile SingularAttribute<Order, BigDecimal> totalCost;
}
```

Tak wygenerowany metamodel można wykorzystać przy budowaniu zapytania:

```java
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery<Order> cq = cb.createQuery(Order.class);
SetJoin<Order, Item> itemNode = cq.from(Order.class).join(Order_.items);
cq.where( cb.equal(itemNode.get(Item_.id), 5 ) ).distinct(true);
```

**Generowanie**

Metamodel jest generowany automatycznie, trzeba wprowadzić tylko odpowiednią konfigurację.

> The Metamodel Generator also takes into consideration xml configuration specified in orm.xml or mapping files specified in persistence.xml. However, if all configuration is in XML you need to add in at least on of the mapping file the following persistence unit metadata:
>
> ```xml
> <persistence-unit-metadata>
> <xml-mapping-metadata-complete/>
> </persistence-unit-metadata>
> ```

Definiujemy zależność:

```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-jpamodelgen</artifactId>
    <version>${hibernate.version}</version>
    <scope>compile</scope>
</dependency>
```

Następnie w ustawieniach dla kompilatora dodajemy odpowiednie parametry. Jeśli jest kilka procesorów adnotacji. 

```xml
<build>
    <plugins>
        <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>${compiler-plugin.version}</version>
            <configuration>
                <source>${jdk.version}</source>
                <target>${jdk.version}</target>
                <annotationProcessors>
                    <annotationProcessor>org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor</annotationProcessor>
                </annotationProcessors>
                <annotationProcessorPaths>
                    <annotationProcessorPath>
                        <groupId>org.hibernate</groupId>
                        <artifactId>hibernate-jpamodelgen</artifactId>
                        <version>${hibernate.version}</version>
                    </annotationProcessorPath>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>
```
### Opóźnione wczytanie - Lazy loading

[//]: "lazy-loading"

Mechanizm polega na tym, że nie wszystkie atrybuty encji są wczytywane od razu. Wczytywane są dopiero wtedy gdy jest to wymagane.

Dla przykładu mamy encję OrzeczenieLekarskie i ona jest w relacji wiele-do-jednego z encją ProgramOsoby (program osoby ma wiele orzeczeń).

Taką relację możemy zdefiniować następująco:

```java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "PRGOS_ID", nullable = false)
private ProgramOsoby programOsoby;
```

Pobierając encję OrzeczenieLekarskie nie musimy od razu pobierać encji ProgramOsoby, może zostać ona pobrana dopiero wtedy gdy będzie potrzebna. Nazywa się to LazyLoading.

W przypadku tego mechanizmu należy uważać na to aby pobrać elementy zanim wygaśnie sesja.

Obiekty można pobrać/zainicjować poprostu je pobierając `entity.getProgramOsoby()` spowoduje, że obiekt zostanie zainicjowany lub zainicjować je poleceniem.



### Generowanie modeli encji

[//]: "generate-model-classes"

Dodajemy zależność:

```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-jpamodelgen</artifactId>
    <version>${hibernate.version}</version>
    <scope>compile</scope>
</dependency>
```
### Zachowanie nazw tabel

[//]: "naming-strategy"

Zdarzyło mi się tak, że pomimo, że podałem nazwy tabel i kolumn z dużej litery to i tak generowane tabele i kolumny w bazie danych były z małej. Musiałem dodać opcję.

```properties
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```

Opcja ustawia strategię tworzenia nazwa zgodnie z tymi co są podane w adnotacjach.

### Konwertowanie wartości atrybutu

[//]: "field-converter"

Konwerter

```java
package com.dhl.mango.ratecard.converter;

import com.dhl.mango.ratecard.domain.HarmonizedViewType;

import javax.persistence.AttributeConverter;

public class HarmonizedViewTypeConverter implements AttributeConverter<HarmonizedViewType, String> {

    @Override
    public String convertToDatabaseColumn(HarmonizedViewType harmonizedViewType) {
        return harmonizedViewType.getCode();
    }

    @Override
    public HarmonizedViewType convertToEntityAttribute(String code) {
        return HarmonizedViewType.of(code);
    }
}
```

Podłączenie do pola

```java
@Entity
@Getter
@Setter
@NoArgsConstructor
@Table(name = "T_MASS_RT_CARD_GEN")
public class MassRtCardGenEntity {
	...
    @Convert(converter = HarmonizedViewTypeConverter.class)
    private HarmonizedViewType aHarmonizedVw;
	...
}
```


# JBoss-EAP
## Optymalizacja uruchamiania
https://stackoverflow.com/questions/1927071/improving-jboss-5-slow-startup

Aby ułatwić diagnozowanie warto ustawić poziom logów na `DEBUG`:

```
-Djboss.server.log.threshold=DEBUG
```
## Wskazówki
### Błąd typu "nie znaleziono klasy"
Miałem problem z uruchomieniem jednej z paczek `xidp.war`. W trakcie uruchamiania wyświetlał się błąd, że kalsa X nie została odnaleziona. Klasa zawierała się w pakiecie `org.apache.cxf.ws.security.wss4j`, ten pakiet nie był kompilowany razem z modułem, był oznaczony jako `provided` co oznacza, że zostanie dostarczony innym sposobem. W tym przypadku był on załączony jako moduł JBossa.

Moduły JBossa są umieszczone w katalogu `modules\system\layers\base` tam Jboss szuka np. plików JAR, ale nie przeszukuje on wszystkich paczek w poszukiwaniu zależności. Zagląda (najprawdopodobniej) on do pliku `WEB-INF/jboss-deployment-structure.xml` i załącza te zależności które zostały tam zdefiniowane.

W moim przypadku zabrakło tej deklaracji:

```xml
<?xml version="1.0"?>
<jboss-deployment-structure xmlns="urn:jboss:deployment-structure:1.2">
    <deployment>
        <dependencies>
            <module name="org.apache.cxf"/>
            <module name="org.apache.cxf.impl"/>
        </dependencies>
    </deployment>
</jboss-deployment-structure>
```

Bez tej deklaracji JBoss nie mógł wczytać zależności przez co nie mógł uruchomić aplikacji. **Szukanie przyczyny zajęło mi około 5H**
### Podpięcie debuggera.
W konfiguracji w pliku `standalone.cong`  od komentować konfigurację:

```
# Sample JPDA settings for remote socket debugging
JAVA_OPTS="$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n"
```

Umożliwia ona na zdalne debugowanie przez IDEA. W IDEA konfigurujemy ustawienia `Remote`. Adres portu musi być taki jak w konfiguracji.
### Logi
JBOSS zrzuca logi do pliku `standalone/log/server.log`.
### Problem z uruchomieniem
Miałem taki problem, że nie mogłem uruchomić instancji. W konsoli Bash nie wyświetlał się żaden komunikat. W konsoli CMD wyświetliła się informacja, że `war` który chce uruchomić różni się od tego zdefiniowanego  w konfiguracji (skróty się różniły).

Było to spowodowane tym, że dzień wcześniej za pomocą CLI deployowałem paczki, te widocznie zapisały się w pliku konfiguracyjnym:

```
C:\Projekty\workspace\kir-jboss-eap\standalone\configuration\standalone.xml
```

W sekcji `deployments`.

```xml
<deployments>
    <deployment name="wb-adminpanel-1.7.3-SNAPSHOT.war" runtime-name="wb-adminpanel-1.7.3-SNAPSHOT.war">
        <content sha1="9660165680a3fd1ae874eb1dd614d2cb563e6830"/>
    </deployment>
</deployments>
```

Trzeba było usunąć wpis aby ponownie uruchomić maszynę.
### Opcja `--admin-only`
Za pomocą tej opcji możemy uruchomić JBOSS tylko dla obsługi administratorskiej np. aby połączyć się przez CLI.

# Tomcat

[//]: "tomcat"

Apache Tomcat is an open-source implementation of the Java Servlet, JavaServer Pages, Java Expression Language and WebSocket technologies. Tomcat provides a "pure Java" HTTP web server environment in which Java code can run.
## Components

[//]: "components"

Tomcat 4.x was released with Catalina (a servlet container), Coyote (an HTTP connector) and Jasper (a JSP engine).

**Catalina**
Catalina is Tomcat's servlet container. Catalina implements Sun Microsystems' specifications for servlet and JavaServer Pages (JSP).

**Coyote**
Coyote is a Connector component for Tomcat that supports the HTTP 1.1 protocol as a web server.

**Jasper**
Jasper is Tomcat's JSP Engine. Jasper parses JSP files to compile them into Java code as servlets (that can be handled by Catalina). At runtime, Jasper detects changes to JSP files and recompiles them.
## Zmienne środowiskowe

[//]: "env-variables"

Environment variables

| Zmienna        | Opis                                                         |
| -------------- | ------------------------------------------------------------ |
| $CATALINA_HOME | Zmienna wskazuje miejsce w którym zainstalowany jest serwer. |
| $CATALINA_BASE | Ta zmienna wskazuje katalog określonej instancji Tomcat, może być zainstalowanych wiele instancji. Jeśli ta zmienna nie zostanie ustawiona jawnie, zostanie jej przypisana ta sama wartość co $CATALINA_HOME. |
## Ogólne pojęcia

[//]: "main-concepts"

| Pojęcie       | Opis                                                         |
| ------------- | ------------------------------------------------------------ |
| Document Root | Jest to podstawowy katalog w którym zawarte są różnego rodzaju zasoby JSP, HTML itp. |
| Context Path  | Odnosi się do lokalizacji, która jest względna do adresu serwera i reprezentuje nazwę aplikacji internetowej. Jeśli np. aplikacji jest w ścieżce `$CATALINA_HOME\webapps\myapp`  aplikacja jest dostępna pod adresem *http://localhost/myapp*. |
| WAR           | Jest to archiwum typu ZIP w skład którego wchodzą elementy strony WWW (Web Archive). |
## Uruchomienie serwera

[//]: "run-serveer"

Serwer można uruchomić za pomocą skryptu ` $CATALINA_HOME\bin\startup `.
## Lokalizacje i pliki

[//]: "paths"

| Lokalizacja/Plik                     | Opis                                                    |
| ------------------------------------ | ------------------------------------------------------- |
| `/usr/share/tomcat8                  | Katalog z instalacją                                    |
| `/usr/share/tomcat8/bin/catalina.sh` | Skrypt konfigurujący środowisko po uruchomieniu serwera |
## Konfiguracja

[//]: "configuration"

Konfiguracja serwera jest umieszczona w katalogu: ` TOMCAT-HOME/conf/`. Umieszczone są tam konfiguracje:

- server.xml,
- web.xml.
## Pozostałe

[//]: "other"

### Konfiguracja kodowania linku

[//]: "configure-url-encode"

Miałem przypadek w którym był link do pobrania pliku. Nazwa pliku zawierała chińskie znaki. Link do pobrania pliku zadakowałem przez `encodeURI` . Po kliknięciu następowało przekierowania na akcje gdzie link był źle odkodowany.

```java
public ResponseEntity<Resource> serveFile(@PathVariable(value = "shipmentId") String shipmentId,
                                          @PathVariable(value = "reportId") Long reportId,
                                          @PathVariable String fileName) {
    return shipmentService.getResourceResponseEntity(shipmentId, reportId, fileName);
}
```

Zmienna `fileName` zawierała niepoprawnie zakodowaną nazwę pliku. Rozwiązaniem tego problemu było ustawienie w konfiguracj Tomcata parametru `URIEncoding`. 

```xml
<!-- ... -->
<Connector port="8280" protocol="HTTP/1.1"
           connectionTimeout="20000"
           URIEncoding="UTF-8"
           redirectPort="8443" />
<!-- ... -->
```
### Konfiguracja Remote Debug

[//]: "configure-remote-debug"

W pliku `/usr/share/tomcat8/bin/catalina.sh` należy dodać poniższe opcje.

```
export CATALINA_OPTS='-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n'
```
### Konfiguracja `setenv.sh`

[//]: "configure-set-env-sh"

Plik `setenv.sh` pozwala na wprowadzenie ustawień środowiska. 

Plik na ogół trzeba utworzyć w katalog gdzie znajduje się plik `catalina.sh`. Następnie do pliku można wprowadzić konfiguracje środowiska.

```shell
export CATALINA_OPTS='-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n'
export CATALINA_OPTS="$CATALINA_OPTS -Xms512m"
export CATALINA_OPTS="$CATALINA_OPTS -Xmx8192m"
export CATALINA_OPTS="$CATALINA_OPTS -XX:MaxPermSize=256m"
```

### Moduł logowania

[//]: "login-module"

Tomcat udostępnia mechanizm logowania użytkownika. Pewne wprowadzenie jest w artykule [Custom LoginModule in Tomcat](..\Artykuły\Java\11.Custom LoginModule in Tomcat.md)

### Valve

[//]: "valve"

Jest to mechanizm pozwalający przetwarzanie żądań przez odpowiednio powiązane klasy. Jest to mechanizm który nie zadziała na innych kontenerach. Analogicznym mechanizmem jest bardziej standardowych filtrów.

# WSS4J

https://ws.apache.org/wss4j/user_guide.html#what_is_apache_wss4j

Jest to biblioteka Javy dostarczająca implementację WSS dla Javy.

Biblioteka dostarcza trzy tryby działa:

- oparty na akcji (Action base),
- oparty na WS-SecurityPolicy (w oparciu o reguły w politykach),
- bezpośredni (bezpośrednie wywołanie API).

## Działanie na akcji

WSHandler jest to podstawowa klasa przystosowana do przetwarzania żądania w oparciu o konfiguracje dostarczona przez klasy potomne. Przykładem takich klas potomnych jest  WSS4JOutInterceptor w bibliotece Apache CXF. Opcje konfiguracyjne są zdefniowane w WSHandlerConstants.

Na żądaniu defniowane są akcje które maja zostać wykonane. Typowymi akcjami są: `UsernameToken, Signature, Encrypt, Timestamp, SAMLTokenSigned`. W zależności od akcji zdefniowane są różne konfiugracje pod różnymi kluczami.

Dla akcji UsernameToken wymagane będzie skonfigurowanie

- **Key** - **Value**
- action - UsernameToken
- user - Alice
- passwordCallbackClass - [org.apache.cxf.systest.ws.common.UTPasswordCallback](https://github.com/apache/cxf/blob/master/systests/ws-security/src/test/java/org/apache/cxf/systest/ws/common/UTPasswordCallback.java)

Dla akcji Signature/Timestamp:

- **Key** - **Value**
- action - Signature Timestamp
- signatureUser - alice
- passwordCallbackClass - [org.apache.cxf.systest.ws.common.KeystorePasswordCallback](https://github.com/apache/cxf/blob/master/systests/ws-security/src/test/java/org/apache/cxf/systest/ws/common/KeystorePasswordCallback.java)
- signaturePropFile - [alice.properties](https://github.com/apache/cxf/blob/master/systests/ws-security/src/test/resources/alice.properties)
- signatureKeyIdentifier - DirectReference
- signatureParts - {}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;{}{http://schemas.xmlsoap.org/soap/envelope/}Body;

## Konfiguracja dla Apache CXF

# Swing
Swing in Java is a Graphical User Interface (GUI) toolkit that includes a rich set of widgets. It is a part of Java Foundation Classes(JFC), which is an API for Java programs that provide GUI. Swing includes packages that let you make a sophisticated set of GUI components for your Java applications and it is platform-independent.

The Swing library is built on top of the Java Abstract Widget Toolkit (AWT), an older, platform dependent GUI toolkit. You can use the Java GUI components like button, textbox, etc. from the library and do not have to create the components from scratch.

![Creating GUI Components using Java Swing Tutorial](../../../.files/java-swing-class-hierarchy.jpg)
## Simple example
So let's create simple window with button. 

```java
import javax.swing.*;
class gui{
    public static void main(String args[]){
       JFrame frame = new JFrame("My First GUI");
       frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
       frame.setSize(300,300);
       JButton button = new JButton("Press");
       frame.getContentPane().add(button); // Adds Button to content pane of frame
       frame.setVisible(true);
    }
}
```

Take a notice that JFrame has method getContentPane which returns component JPane.
## Container
Container classes are classes that can have other components on it. So for creating a GUI, we need at least one container object. There are 3 types of containers.

1. **Panel**: It is a pure container and is not a window in itself. The sole purpose of a Panel is to organize the components on to a window.
2. **Frame**: It is a fully functioning window with its title and icons.
3. **Dialog**: It can be thought of like a pop-up window that pops out when a message has to be displayed. It is not a fully functioning window like the Frame.
## Układ
The Layout manager is used to layout (or arrange) the GUI java components inside a container.There are many layout managers, but the most frequently used are: 
### BorderLayout
![Creating GUI Components using Java Swing Tutorial](../../../.files/java-border-layout-manager.jpg)

A `BorderLayout` places components in up to five areas: top, bottom, left, right, and center. It is the default layout manager for every java JFrame
### FlowLayout
![Creating GUI Components using Java Swing Tutorial](../../../.files/java-flow-layout-manager.jpg)

`FlowLayout` is the default layout manager for every `JPanel`. It simply lays out components in a single row one after the other.
### GridBagLayout
![Creating GUI Components using Java Swing Tutorial](../../../.files/java-grid-bag-layout.jpg)

It is the more sophisticated of all layouts. It aligns components by placing them within a grid of cells, allowing components to span more than one cell.

### BoxLayout

![A snapshot of BoxLayoutDemo](../../../.files/BoxLayoutDemo.png)

### MigLayout

Układ jest dostarczony w ramach zewnętrznej biblioteki. Ukłąd jest konfigurowany konfigurowany w sposób tesktowych. Trochę tak jak się to robi za pomocą CSSa.

#### Wielkość kolumn i wierszy

Standardowo wielkość jest ustalana na postawie najwiekszego komponentu w wierszu i kolumnie, ale można to ustawić ręcznie.

```java
MigLayout layout = new MigLayout(
 "", // Layout Constraints
 "[10][20:30:40][40!][::40]", // Column constraints
 "[min!][10::20][40mm!]");    // Row constraints
```

Lub np. w taki sposób jeśli np. chcemy ustawić układ dla JPanelu.

```java
setLayout(new MigLayout("gap 0", "[100%::, fill]", "[30::][][grow][]"));
```

Czyli jest to jedna kolumna o szerokości 100%, oraz 4 wierszach z szczego pierwszy będzie miał 30px, drugi automatycznie, trzeci będzie się rozrastał, czwarty automatycznie.

# Wydajność

## Zagadnienia
### Ustawienie górnego limitu pamięci
Za pomocą parametrów do zarządzania pamięcią ustawić odpowiednie parametry i ewentualnie je zwiększać w razie potrzeby.

Możemy użyć parametru `-XX:+HeapDumpOnOutOfMemoryError` aby zrzucić log w razie wyjątku OutOfMemoryError.
### Unikanie iteratorów
```java
for(String value: stirngs) {
    // ...
}
```

Iterowanie za pomocą iteratorów wiąże się z inicjowanie takiego iterator. Nie zawsze jest to konieczne, możemy np. iterować po liście za pomocą indeksu.

```java
int size = strings.size();
for(int i=0; i <= size; i++) {
    // ...
}
```

Lub bezpośrednio na tablicy tych elementów z listy.
### Używanie StringBuilder
Tam gdzie tworzony większe ciągu znaków warto jest użyć StringBuildera zamiast np. łączyć za pomocą operatora  `+`.

## Testy
### Test sposobu iteracji
W ramach testu sprawdziłem kilka sposobów iteracji po tablicy liczb całkowitych. W ramach testu dokonałem 3 pomiarów. Testy zostały wykonane na Javie w wersji 11.

![image-20210914105711660](../../../.files/image-20210914105711660.png)

Mierzona była ilość operacji na sekundę dla każdego testu. Sam test jest w repozytorium tutaj umieszczam tylko wyniki. Z wyniku testu wynik, że najszybszym sposobem iteracji jest iteracja po natywnej tablicy po indeksie **ArrayByIndex**. Jestem zaskoczony wynikiem **For** czyli zwykłego for-eacha z iteratorem, że wypada on niewiele gorzej oraz **ByStreamForEach** który jest zbliżony. Pozostałe poza ByIndex oscylują w okolicach 40 czyli o 30% mniej niż **ArrayByIndex**. Zastanawiający jest ByEach i ByIndex ponieważ ByEach jest moją implementacją która w środku korzysta z ByIndex a wypada o wiele lepiej.

Pierwszy wniosek jaki się nasuwa to, że **ArrayByIndex** jest najszybszym sposobem iteracji w każdym przypadku. Z drugiej strony widać, że te wyniki są zróżnicowane i różne dla każdego testu.

Warto wspomnieć, że test polegał na iteracji po 10 mln rekordów z operacją dodawania. Czyli jest to np. 60 iteracji po 10mln na sekundę rekordów.

### Zapisywanie wielkości listy do zmiennej
W teście chcę sprawdzić czy to, że zapiszę zmienną `size` do zmiennej wpłynie jakoś na szybkość iteracji po liście. Alternatywnym rozwiązaniem jest wykonywanie metody `size` za każdym razem co wydaje się bezsensowne ponieważ przy każdej iteracji mamy wykonanie metody. W przypadku JVM nie koniecznie musi być to złe ponieważ może zastosować on optymalizację.

![image-20210914143113123](../../../.files/image-20210914143113123.png)

Wykonałem trzy testy. **withArray** polegał na tym, że iterowaliśmy po prostej liście, **withCallSizeEachTime** mierzył wariant gdy metoda `size()` jest wołana za każdym razem przy iteracji, **withWrittenSize** gdy wynik metody `size` zapisujemy do zmiennej.

Wynik testu pokazuje, że testy zapisanie do zmiennej wypada nieznacznie lepiej co by oznaczało, że warto taką tą wartość zapisywać do zmienne ale różnica jest nie duża bo mniej niż 10 dodatkowych iteracji na sekundę przy 10 mln rekordów. Wiec jedno wywołanie `size` więcej aby sprawdzić czy mamy dane nie powinno być problemem.

**Wniosek jest taki**, że aby sprawdzić czy lista jest pusta mogę raz wywołać `size` bez zapisywania wyniku do zmiennej i alokowania na stosie **ale potem w trakcie iteracji warto tą zmienną zapisać** aby nie wykonywać wielokrotnie `size` a w rezultacie polecenia `invokeinterface` na JVM. 

![image-20210914140506092](../../../.files/image-20210914140506092.png)

Porównałem bytecode obu wersji. Chciałem sprawdzić czy przypadkiem nie ma żadnej optymalizacji przez kompilator, ale nie ma. Pomimo, że mamy wiele wywołań `invokeinterface List.size()` w drugim przypadku to w sumie JVM jakoś nie przeszkadza pewnie dlatego, że metoda `size()` zwraca od razu wartość i w tym konkretnym przypadku nie ma to wpływy.

### Korzystanie z metod dostępowych
W teście sprawdzam jak narzut ma wykonanie metody dostępowej tylko po to aby pobrać wartość parametru. Czy jest jakaś różnica między wykonaniem metody dostępowej a bezpośrednim odwołaniu się do pola.

![image-20210914161401667](../../../.files/image-20210914161401667.png)

Z testów wynika, są pewne różnie przy 1000 rekordów jest różnica około 500000 iteracji. Dziwne jest, że dla 10000 i 100000 jest różnica ujemna. Następnie przy 1 000 000 u 10 000 000 znowu różnica jest znacząca, ale sa to takie wartości które w normalnej skali nie występują.

Wniosek jest taki, że do 1000 rekordów jest różnica ale ogólnie wartości są bardzo duże i pewnie nawet z tymi wywoływaniem metod też było by ok.  

# Zarządzanie zasobami
Java udostępnia wbudowane API do zarządzania zasobami. W zasobach mogą być przechowywane różnego rodzaju dane: tekst,  wartości binarne itp.
## Pakiet zasobów
Zasoby reprezentowany jest przez klasę `java.util.ResourceBundle`. Jest to podstawowa implementacja i jest rozszerzana przez wiele różnych klas.  Klasa wymaga implementacji metod: 

```java
Object handleGetObject(String key);
Enumeration<String> getKeys();
```

Jedną z podstawowych implementacji jest `java.util.PropertyResourceBundle` jest to klasa która odczytuje wartość z pliku.

**PropertyResourceBundle** 

------

Mamy plik:

```properties
# src/main/resources/application.properties
database.host=192.168.1.1
database.user=foo
database.password=xyz
```

Następnie aby go odczytać:

```java
PropertyResourceBundle propertyResourceBundle = new PropertyResourceBundle(getClass().getResourceAsStream("/application.properties"));

System.out.println(propertyResourceBundle.getString("database.host"));
System.out.println(propertyResourceBundle.getString("database.user"));
System.out.println(propertyResourceBundle.getString("database.password"));
```

Drugą podstawową implementacją jest `java.util.ListResourceBundle`. Implementacja pozwala na zainicjowanie zasobów na postawie listy wartości.

**ListResourceBundle**

------

```java
public class UserResources extends ListResourceBundle {
    @Override
    protected Object[][] getContents() {
        return new Object[][]{
            {"database.user", "foo"},
            {"database.password", "xyz"},
            {"database.host", "localhost"}
        };
    }
}
```

Odczytanie danych jest analogiczne:

```java
ListResourceBundle listResourceBundle = new UserResources();

System.out.println(listResourceBundle.getString("database.host"));
System.out.println(listResourceBundle.getString("database.user"));
System.out.println(listResourceBundle.getString("database.password"));
```

Możliwe jest również własna implementacja oparta np. na `HashMapie`.

```java
private static class SymbolResourceBundle extends ResourceBundle {
    private Map<String, String> properties = new HashMap<String, String>() {{
        put("symbols.en.mrs", "Mrs");
        put("symbols.en.mr", "Mr");
        put("symbols.pl.mrs", "Pani");
        put("symbols.pl.mr", "Pan");

        put("symbols.en.today", "today");
        put("symbols.en.day", "day");
        put("symbols.en.days", "days");
        put("symbols.pl.today", "dzisiaj");
        put("symbols.pl.day", "dzień");
        put("symbols.pl.days", "dni");
    }};

    @Override
    public Enumeration<String> getKeys() {
        return new ResourceBundleEnumeration(properties.keySet(), null);
    }

    @Override
    protected Object handleGetObject(String key) {
        return properties.get(key);
    }
}
```
## Pakiety zasobów zależne od języka i platformy
Możliwe jest wczytywanie zasobów w zależności od wybranego języka i platformy. Tworzymy wtedy np. dwie klasy:

```java
public class Msg_en extends ListResourceBundle {
    @Override
    protected Object[][] getContents() {
        return new Object[][]{
            {"day", "day"},
            {"days", "days"},
        };
    }
}

public class Msg_pl extends ListResourceBundle {
    @Override
    protected Object[][] getContents() {
        return new Object[][]{
            {"day", "dzień"},
            {"days", "dni"},
        };
    }
}
```

Następnie możemy skorzystać z metody tworzącej `getBundle`, która na podstawie podanego lub systemowego języka i platformy wczyta odpowiednie zasoby.

```java
ResourceBundle resourceBundle = ResourceBundle.getBundle("repo.java.resourcebundles.Msg", new Locale("en"));
System.out.println(resourceBundle.getString("day"));

resourceBundle = ResourceBundle.getBundle("repo.java.resourcebundles.Msg", new Locale("pl"));
System.out.println(resourceBundle.getString("day"));

// Wczytany zostanie również plik .properties jeśli taki istnieje
ResourceBundle messages = PropertyResourceBundle.getBundle("messages", new Locale("pl"));
System.out.println(messages.getString("hello"));
```

W trakcie wczytywania zasoby są łączone i nadpisywane, jeśli np. mamy pliki `messages.properties` oraz `messages_pl.properties` to w pierwszej kolejności zostanie wczytany ``messages.properties`, a następnie `messages_pl.properties`, który wartości z tego pierwszego.
## Kodowanie
Należy pamiętać, że `PropertyResourceBundle` wczytuje plik w kodowaniu *ISO 8859-1* co np. powoduje, że polskie znaki się źle kodują. Pewnym rozwiązaniem jest zapisywanie znaków UTF w formacie ASCII. 

```
#Before
polishHello=cześć

#After
polishHello=cze\u015b\u0107
```

Wtedy te znaki zostaną poprawnie odkodowanie.

Klasa `ListResourceBundles `  w pewnym sensie rozwiązuje ten problem dlatego, że wartości są podawane bezpośrednio w kodzie. Od wersji JDK9 możliwe jest podawanie wszystkich znaków z zakresu UTF-16 dlatego taka konwersja nie jest potrzebna.

```java
public class Msg_pl extends ListResourceBundle {
    @Override
    protected Object[][] getContents() {
        return new Object[][]{
            {"day", "dzień"},
            {"days", "dni"},
        };
    }
}
```

Konwersję z UTF-8 na ASCII można wykonac narzędziem `native2ascii`.

```shell
native2ascii -encoding UTF-8 utf8.properties nonUtf8.properties
```

Można tworzyć dwa pliki właściwości: `message_pl.properties`, oraz ``message_pl.utf8.properties` i dokonywać konwersji przy wprowadzaniu zmian.
## Mechanizm zasobów
<https://docs.oracle.com/javase/8/docs/technotes/guides/lang/resources.html>

<https://javarevisited.blogspot.com/2014/07/how-to-load-resources-from-classpath-in-java-example.html>

Zasoby to dane różnego typu (obrazki, ikony, muzyka, dokumenty, style itp.).

Zasoby sa niez

...

Zasób to dane (obrazy, dźwięk, tekst itd.), Do których program musi uzyskać dostęp w sposób niezależny od lokalizacji kodu programu. Programy Java mogą korzystać z dwóch mechanizmów dostępu do zasobów.

- `Applet.getCodeBase()` wykorzystywany przez aplety,
- mechanizm do wczytywania zasobów przez aplikacje jak `System.getProperty("user.home")`, `System.getProperty("java.home")`

Ważne jest aby ścieżki do zasobów zostały zdefiniowane w `CLASSPATH`.

Metody w klasie `Class` i `ClassLoader` dostarczają mechanizm wczytywania zasobów niezależnie od lokalizacji.

- zasoby ładowe przez HTTP,
- zasoby wczytywane z plików JAR,
- zasoby wczytywane ze ścieżek `CLASSPATH`,
- ...

Zasoby można wczytywać zapomoca klasy `Class` lub `ClassLoader`.

Za pomoca `ClassLoader` wczytujemy zasoby systemowe` getSystemResource|getSystemResourceAsStream`.

`Class` również pozwala na wczytywanie zasobów.

```java
// Z pobraniem klasy za pomoc metody Class.forName
Class c = null;

try {
    c = Class.forName("com.httpio.app.App");
} catch (ClassNotFoundException e) {
    e.printStackTrace();
}

System.out.println(c.getResource("/style.css"));

// Z wykorzystaniem .class
System.out.println(App.class.getResource("/style.css"));

// Klasę mozemy również pobrać metoda getClass()
System.out.println(getClass().getResource("/style.css"));
```
# Proxy
Proxy można osiągną na różne sposoby. Możemy użyć standardowego mechanizmu dostarczanego przez JDK. Alternatywnie można wykorzystać bibliotekę CGLIB do generowania byte kodu.

CGLIB umożliwia również generowanie innych rzeczy takich jak komponenty czy miksowanie obiektów.
## JDK Proxy
Jest to standardowy sposób implementacji proxy w Javie. Implementujemy InvocationHandler.

```java
public class DynamicInvocationHandler implements InvocationHandler {

    private static Logger LOGGER = LoggerFactory.getLogger(
      DynamicInvocationHandler.class);

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) 
      throws Throwable {
        LOGGER.info("Invoked method: {}", method.getName());

        return 42;
    }
}
```

Instancję proxy tworzymy w następujący sposób:

```java
Map proxyInstance = (Map) Proxy.newProxyInstance(
  DynamicProxyTest.class.getClassLoader(), 
  new Class[] { Map.class }, 
  new DynamicInvocationHandler());
```

Nie musimy implementować interfejsu. Możemy również przekazać wyrażenie funkcję.

```java
Map proxyInstance = (Map) Proxy.newProxyInstance(
  DynamicProxyTest.class.getClassLoader(), 
  new Class[] { Map.class }, 
  (proxy, method, methodArgs) -> {
    if (method.getName().equals("get")) {
        return 42;
    } else {
        throw new UnsupportedOperationException(
          "Unsupported method: " + method.getName());
    }
});
```
## CGLIB
Jest to biblioteka do generowania kodu byte kodu Javy. Jest to skrót od nazwy Code Generation Library. Biblioteka jest używana między innymi do tworzenia obiektów proxy. Używana jest do tworzenia proxy między innymi w Springu lub Hibernate.

Załóżmy, że mamy usługę:

```java
public class PersonService {
    public String sayHello(String name) {
        return "Hello " + name;
    }

    public Integer lengthOfName(String name) {
        return name.length();
    }
}
```

Tworzenie prostego proxy w którym zawsze będzie zwraca stała wartość. 

```java
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(PersonService.class);
enhancer.setCallback((FixedValue) () -> "Hello Tom!");
PersonService proxy = (PersonService) enhancer.create();

String res = proxy.sayHello(null);

assertEquals("Hello Tom!", res);
```

W powyższym przypadku dla każdej metody będzie zwracana wartość "Hello Tom!".

Aby zdefiniować interceptor dla metody:

```java
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(PersonService.class);
enhancer.setCallback((MethodInterceptor) (obj, method, args, proxy) -> {
    if (method.getDeclaringClass() != Object.class && method.getReturnType() == String.class) {
        return "Hello Tom!";
    } else {
        return proxy.invokeSuper(obj, args);
    }
});

PersonService proxy = (PersonService) enhancer.create();

assertEquals("Hello Tom!", proxy.sayHello(null));
int lengthOfName = proxy.lengthOfName("Mary");
 
assertEquals(4, lengthOfName);
```

Możliwe jest również generowanie komponentów oraz **miksowania**. Przykłady w repozytorium. 
# Serializacja
Object serialization is the process of saving an object's state to a sequence of bytes, as well as the process of rebuilding those bytes into a live object at some future time. The Java Serialization API provides a standard mechanism for developers to handle object serialization. The API is small and easy to use, provided the classes and methods are understood.

To persist an object in Java, we must have a persistent object. An object is marked serializable by implementing the `java.io.Serializable` interface, which signifies to the underlying API that the object can be flattened into bytes and subsequently inflated in the future.

Let's look at a persistent class we'll use to demonstrate the serialization mechanism:

```java
package com.repo.serialization;

import java.io.Serializable;
import java.util.Calendar;
import java.util.Date;

public class PersistentTime implements Serializable {
    private Date time;

    public PersistentTime() {
        time = Calendar.getInstance().getTime();
    }

    public Date getTime() {
        return time;
    }
}
```

As you can see, the only thing we had to do differently from creating a normal class is implement the `java.io.Serializable` interface on line 40. The completely empty `Serializable` is only a *marker* interface -- it simply allows the serialization mechanism to verify that the class is able to be persisted.

**The object to be persisted must implement the** `Serializable` **interface or inherit that implementation from its object hierarchy.**

The next step is to actually persist the object. That is done with the `java.io.ObjectOutputStream` class. That class is a *filter stream*--it is wrapped around a lower-level byte stream (called a *node stream*) to handle the serialization protocol for us. Node streams can be used to write to file systems or even across sockets. That means we could easily transfer a flattened object across a network wire and have it be rebuilt on the other side!

Take a look at the code used to save the `PersistentTime` object:

```java
public class App {
    public static void main(String[] args) {
        new App().run();
    }

    public void run() {
        persis(new PersistentTime());
    }

    private void persis(Object object) {
        FileOutputStream fileOutputStream;
        ObjectOutputStream objectOutputStream;

        try {
            fileOutputStream = new FileOutputStream("persistentTime.ser");
            objectOutputStream = new ObjectOutputStream(fileOutputStream);

            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

To read saved object we need use `ObjectInputStream` class.

```java
private PersistentTime unpersist() {
    PersistentTime time = null;

    try {
        FileInputStream fileInputStream = new FileInputStream("persistentTime.ser");
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);

        time = (PersistentTime) objectInputStream.readObject();

        objectInputStream.close();
    } catch (IOException | ClassNotFoundException e) {
        e.printStackTrace();
    }

    return time;
}
```

The basic mechanism of Java serialization is simple to use, but there are some more things to know. As mentioned before, only objects marked `Serializable` can be persisted. The `java.lang.Object` class does not implement that interface. Therefore, not all the objects in Java can be persisted automatically. The good news is that most of them -- like AWT and Swing GUI components, strings, and arrays -- are serializable.

On the other hand, certain system-level classes such as `Thread`, `OutputStream` and its subclasses, and `Socket` are not serializable. Indeed, it would not make any sense if they were. For example, thread running in my JVM would be using my system's memory. Persisting it and trying to run it in your JVM would make no sense at all. Another important point about `java.lang.Object` not implementing the `Serializable` interface is that any class you create that extends only `Object` (and no other serializable classes) is not serializable unless you implement the interface yourself (as done with the previous example).

That situation presents a problem: what if we have a class that contains an instance of `Thread`? In that case, can we ever persist objects of that type? The answer is yes, as long as we tell the serialization mechanism our intentions by marking our class's `Thread` object as `transient`.
## Keyword `transient`
Let's assume we want to create a class that performs an animation. I will not actually provide the animation code here, but here is the class we'll use.

```java
package com.repo.serialization;

import java.io.Serializable;

public class PersistentAnimation implements Serializable, Runnable {
    private int animationSpeed;
    transient private Thread animator;

    public PersistentAnimation(int animationSpeed) {
        this.animationSpeed = animationSpeed;

        animator = new Thread(this);
        animator.start();
    }

    public void run() {
        while (true) {
            // do animation here
        }
    }
}
```

When we create an instance of the `PersistentAnimation` class, the thread `animator` will be created and started as we expect. We've marked the thread on line 40 `transient` to tell the serialization mechanism that the field should not be saved along with the rest of that object's state (in that case, the field `speed`). The bottom line: you must mark `transient` any field that either cannot be serialized or any field you do not want serialized. Serialization does not care about access modifiers such as `private` -- all nontransient fields are considered part of an object's persistent state and are eligible for persistence.

Let's move on to the second way to perform serialization: customize the default protocol. Though the animation code above demonstrates how a thread could be included as part of an object while still making that object be serializable, there is a major problem with it if we recall how Java creates objects. To wit, when we create an object with the `new` keyword, the object's constructor is called only when a new instance of a class is created. Keeping that basic fact in mind, let's revisit our animation code. First, we instantiate an object of type `PersistentAnimation`, which begins the animation thread sequence. Next, we serialize the object with that code:

```java
PersistentAnimation animation = new PersistentAnimation(10);
FileOutputStream fos = ...
ObjectOutputStream out = new ObjectOutputStream(fos);
out.writeObject(animation);
```

All seems fine until we read the object back in with a call to the `readObject()` method. Remember, a constructor is called only when a new instance is created. We are not creating a new instance here, we are restoring a persisted object. The end result is the animation object will work only once, when it is first instantiated.

Well, there is good news. We can make our object work the way we want it to; we can make the animation restart upon restoration of the object. To accomplish that, we could, for example, create a `startAnimation()` helper method that does what the constructor currently does. We could then call that method from the constructor, after which we read the object back in. Not bad, but it introduces more complexity. Now, anyone who wants to use that animation object will have to know that method has to be called following the normal deserialization process. That does not make for a seamless mechanism, something the Java Serialization API promises developers.

There is, however, a strange yet crafty solution. By using a built-in feature of the serialization mechanism, developers can enhance the normal process by providing two methods inside their class files. Those methods are:

```java
private void writeObject(ObjectOutputStream out) throws IOException;
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException;
```

Notice that both methods are (and must be) declared `private`, proving that neither method is inherited and overridden or overloaded. The trick here is that the virtual machine will automatically check to see if either method is declared during the corresponding method call. The virtual machine can call private methods of your class whenever it wants but no other objects can. Thus, the integrity of the class is maintained and the serialization protocol can continue to work as normal. The serialization protocol is always used the same way, by calling either `ObjectOutputStream.writeObject()` or `ObjectInputStream.readObject()`. So, even though those specialized private methods are provided, the object serialization works the same way as far as any calling object is concerned.

So we implement methods:

```java
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    // our "pseudo-constructor"
    in.defaultReadObject();
    // now we are a "live" object again, so let's run rebuild and start

    animator = new Thread(this);
    animator.start();
}

private void writeObject(ObjectOutputStream out) throws IOException {
    out.defaultWriteObject();
}
```

Notice the first line of each of the new private methods. Those calls do what they sound like -- they perform the default writing and reading of the flattened object, which is important because we are not replacing the normal process, we are only adding to it. Those methods work because the call to `ObjectOutputStream.writeObject()` kicks off the serialization protocol. First, the object is checked to ensure it implements `Serializable` and then it is checked to see whether either of those private methods are provided. If they are provided, the stream class is passed as the parameter, giving the code control over its usage.

Those private methods can be used for any customization you need to make to the serialization process. Encryption could be added to the output and decryption to the input (note that the bytes are written and read in cleartext with no obfuscation at all). They could be used to add extra data to the stream, perhaps a company versioning code. The possibilities are truly limitless.
## Stop serialization
OK, we have seen quite a bit about the serialization process, now let's see some more. What if you create a class whose superclass is serializable but you do not want that new class to be serializable? You cannot unimplement an interface, so if your superclass does implement `Serializable`, your new class implements it, too (assuming both rules listed above are met). To stop the automatic serialization, you can once again use the private methods to just throw the `NotSerializableException`. Here is how that would be done:

```java
private void writeObject(ObjectOutputStream out) throws IOException {
    throw new NotSerializableException("Not today!");
}

private void readObject(ObjectInputStream in) throws IOException {
    throw new NotSerializableException("Not today!");
}
```
## Own protocol
Our discussion would be incomplete not to mention the third option for serialization: create your own protocol with the `Externalizable` interface. Instead of implementing the `Serializable` interface, you can implement `Externalizable`, which contains two methods:

- `public void writeExternal(ObjectOutput out) throws IOException;`
- `public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;`

Just override those methods to provide your own protocol. Unlike the previous two serialization variations, nothing is provided for free here, though. That is, the protocol is entirely in your hands. Although it's the more difficult scenario, it's also the most controllable. An example situation for that alternate type of serialization: read and write PDF files with a Java application. If you know how to write and read PDF (the sequence of bytes required), you could provide the PDF-specific protocol in the `writeExternal` and `readExternal` methods.

Just as before, though, there is no difference in how a class that implements `Externalizable` is used. Just call `writeObject()` or `readObject` and, voila, those externalizable methods will be called automatically.
## Caching objects
irst, consider the situation in which an object is written to a stream and then written again later. By default, an `ObjectOutputStream` will maintain a reference to an object written to it. That means that if the state of the written object is written and then written again, the new state will not be saved! Here is a code snippet that shows that problem in action:

```java
ObjectOutputStream out = new ObjectOutputStream(...);
MyObject obj = new MyObject(); // must be Serializable
obj.setState(100);
out.writeObject(obj); // saves object with state = 100
obj.setState(200);
out.writeObject(obj); // does not save new object state
```

There are two ways to control that situation. First, you could make sure to always close the stream after a write call, ensuring the new object is written out each time. Second, you could call the `ObjectOutputStream.reset()` method, which would tell the stream to release the cache of references it is holding so all new write calls will actually be written. Be careful, though -- the `reset` flushes the entire object cache, so all objects that have been written could be rewritten.
## Version control
With our second gotcha, imagine you create a class, instantiate it, and write it out to an object stream. That flattened object sits in the file system for some time. Meanwhile, you update the class file, perhaps adding a new field. What happens when you try to read in the flattened object?

Well, the bad news is that an exception will be thrown -- specifically, the `java.io.InvalidClassException` -- because all persistent-capable classes are automatically given a unique identifier. If the identifier of the class does not equal the identifier of the flattened object, the exception will be thrown. However, if you really think about it, why should it be thrown just because I added a field? Couldn't the field just be set to its default value and then written out next time?

Yes, but it takes a little code manipulation. The identifier that is part of all classes is maintained in a field called `serialVersionUID`. If you wish to control versioning, you simply have to provide the `serialVersionUID` field manually and ensure it is always the same, no matter what changes you make to the classfile. You can use a utility that comes with the JDK distribution called `serialver` to see what that code would be by default (it is just the hash code of the object by default).

Here is an example of using `serialver` with a class called `Baz`:

```
> serialver Baz
> Baz: static final long serialVersionUID = 10275539472837495L;
```

Simply copy the returned line with the version ID and paste it into your code. (On a Windows box, you can run that utility with the `- show` option to simplify the copy and paste procedure.) Now, if you make any changes to the `Baz` class file, just ensure that same version ID is specified and all will be well.

The version control works great as long as the changes are compatible. Compatible changes include adding or removing a method or a field. Incompatible changes include changing an object's hierarchy or removing the implementation of the `Serializable` interface. A complete list of compatible and incompatible changes is given in the Java Serialization Specification.
## Performance
Our third gotcha: the default mechanism, although simple to use, is not the best performer. I wrote out a `Date` object to a file 1,000 times, repeating that procedure 100 times. The average time to write out the `Date` object was 115 milliseconds. I then manually wrote out the `Date` object, using standard I/O the same number of iterations; the average time was 52 milliseconds. Almost half the time! There is often a trade-off between convenience and performance, and serialization proves no different. If speed is the primary consideration for your application, you may want to consider building a custom protocol.

Another consideration concerns the aforementioned fact that object references are cached in the output stream. Due to that, the system may not garbage collect the objects written to a stream if the stream is not closed. The best move, as always with I/O, is to close the streams as soon as possible, following the write operations.
# Daty i czas
Od Javy8 zostało wprowadzone nowe API do operacji na czasie. Poprzednie mechanizmy jak java.util.Date, java.util.Calendar nie wspierały między innymi wielowątkowości, miały nieczytelne API oraz nie wspierały stref czasowych przez co programiści sami musieli implementować ich obsługę.

Od Java8 zostały wprowadzone nowe mechanizmy do operacji z czasem:

- LocalDate,
- LocalTime,
- LocalDateTime.
- ZonedDateTime,
- OffsetDateTime.
- Period,
- Duration.
## Java8 API
**LocalDate**

Klasa LocalDate reprezentuje datę w formacie ISO `yyyy-MM-d` bez czasu. Przykłady użycia:

```java
LocalDate localDate = LocalDate.now();
LocalDate.of(2015, 02, 20);
LocalDate.parse("2015-02-20");

// Operacje
LocalDate tomorrow = LocalDate.now().plusDays(1);
LocalDate previousMonthSameDay = LocalDate.now().minus(1, ChronoUnit.MONTHS);

DayOfWeek sunday = LocalDate.parse("2016-06-12").getDayOfWeek();
int twelve = LocalDate.parse("2016-06-12").getDayOfMonth();

boolean leapYear = LocalDate.now().isLeapYear();

boolean notBefore = LocalDate.parse("2016-06-12")
  .isBefore(LocalDate.parse("2016-06-11"));
 
boolean isAfter = LocalDate.parse("2016-06-12")
  .isAfter(LocalDate.parse("2016-06-11"));

LocalDateTime beginningOfDay = LocalDate.parse("2016-06-12").atStartOfDay();
LocalDate firstDayOfMonth = LocalDate.parse("2016-06-12")
  .with(TemporalAdjusters.firstDayOfMonth());
```
**LocalTime**

Przechowuje tylko czas.

```java
LocalTime now = LocalTime.now();
LocalTime sixThirty = LocalTime.parse("06:30");
LocalTime sixThirty = LocalTime.of(6, 30);
LocalTime sevenThirty = LocalTime.parse("06:30").plus(1, ChronoUnit.HOURS);
int six = LocalTime.parse("06:30").getHour();
boolean isbefore = LocalTime.parse("06:30").isBefore(LocalTime.parse("07:30"));
LocalTime maxTime = LocalTime.MAX
```
**LocalDateTime**

Przechowuje datę i czas.

```java
LocalDateTime.now();
LocalDateTime.of(2015, Month.FEBRUARY, 20, 06, 30);
LocalDateTime.parse("2015-02-20T06:30:00");
localDateTime.plusDays(1);
localDateTime.minusHours(2);
localDateTime.getMonth();
```
**ZonedDateTime**

Służy do operowania na czasie z uwzględnieniem strefy czasowej.

```java
// Strefa czasowa
ZoneId zoneId = ZoneId.of("Europe/Paris");

// Dostępne strefy
Set<String> allZoneIds = ZoneId.getAvailableZoneIds();

ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, zoneId);
ZonedDateTime.parse("2015-05-03T10:15:30+01:00[Europe/Paris]");
```
**OffsetDateTime**

Podobnie jak ZonedDateTime służy do przechowywania czas wraz z przesunięciem (strefą czasową).

```java
LocalDateTime localDateTime = LocalDateTime.of(2015, Month.FEBRUARY, 20, 06, 30);
ZoneOffset offset = ZoneOffset.of("+02:00");
 
OffsetDateTime offSetByTwo = OffsetDateTime
  .of(localDateTime, offset);
```

Formatowanie 

**Period**

Reprezentuje jakąś jednostkę czasu w skali lat, miesięcy, czy dni. 

```java
LocalDate initialDate = LocalDate.parse("2007-05-10");
LocalDate finalDate = initialDate.plus(Period.ofDays(5));
int five = Period.between(initialDate, finalDate).getDays();
long five = ChronoUnit.DAYS.between(initialDate, finalDate);
```
**Duration**

Reprezentuje jakąś jednostkę czasu w skali sekund i nano sekund.

```java
LocalTime initialTime = LocalTime.of(6, 30, 0);
 
LocalTime finalTime = initialTime.plus(Duration.ofSeconds(30));
long thirty = Duration.between(initialTime, finalTime).getSeconds();
long thirty = ChronoUnit.SECONDS.between(initialTime, finalTime);
```
## Konwertowanie z Date na LocalDateTime
Java8 zostały udostępnione różne metody za pomocą, których można dokonać konwersji.

```java
LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
LocalDateTime.ofInstant(calendar.toInstant(), ZoneId.systemDefault());
LocalDateTime.ofEpochSecond(1465817690, 0, ZoneOffset.UTC);
```
## Przesuwanie strefy czasowej
Do przesunięcia strefy czasowej możemy skorzystać z klasy `OffsetDateTime`. Dostarcza ona różne metody.

```java
// Potrzebujemy LocalDateTime aby przekazać go do OffsetDateTime
LocalDateTime localDateTime = LocalDateTime.now();

// 2020-11-10T14:54:00.660867600
System.out.println(localDateTime);

// Tworzę datę i czas z przesunięciem +1
// 2020-11-10T14:54:00.660867600+01:00
OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, ZoneOffset.of("+1"));

System.out.println("offsetDateTime: " + offsetDateTime);

// Zmieniam tylko przesunięcie, czas pozostaje bez zmian.
// 2020-11-10T14:54:00.660867600+03:00
System.out.println("withOffsetSameLocal: " + offsetDateTime.withOffsetSameLocal(ZoneOffset.of("+3")));

// Zmiam przesunięcie oraz cza
// 2020-11-10T16:54:00.660867600+03:00
// Zauważ, że bazowym czasem jest 13:54 (+0), dlatego +3 mamy 16:00.
// Z tej metody można korzystać gdy chcemy przekonwertować czas na inne przesunięcie czasowe.
System.out.println("withOffsetSameInstant: " + offsetDateTime.withOffsetSameInstant(ZoneOffset.of("+3")));

// Dwie podobne metody działające na strefach. ZoneOffset rozszerza ZoneId
System.out.println("atZoneSimilarLocal: " + offsetDateTime.atZoneSimilarLocal(ZoneOffset.of("+3")));
System.out.println("atZoneSameInstant: " + offsetDateTime.atZoneSameInstant(ZoneOffset.of("+3")));
```
## Formatowanie czasu
```java
// Java 8 provides APIs for the easy formatting of Date and Time:
LocalDateTime localDateTime = LocalDateTime.of(2015, Month.JANUARY, 25, 6, 30);

// The below code passes an ISO date format to format the local date. The result would be 2015-01-25 :

String localDateString = localDateTime.format(DateTimeFormatter.ISO_DATE);

// The DateTimeFormatter provides various standard formatting options. Custom patterns can be provided to format method as well, like below, which would return a LocalDate as 2015/01/25:

localDateTime.format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));

// We can pass in formatting style either as SHORT, LONG or MEDIUM as part of the formatting option. The below code sample would give an output representing LocalDateTime in 25-Jan-2015, 06:30:00:

localDateTime
  .format(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM))
  .withLocale(Locale.UK);
​```# Refleksja
Jest to mechanizm pozwalający na analizę struktury różnych obiektów z poziomu programu. Np. możemy sprawdzić jakiego typu metody posiada klasa.

Do pobrania różnych informacji na temat klasy służy klasa `Class<T>`. Instancję ten klasy można pobrać z poziomu samej definicji klasy lub obiektu.

​```java
// Pobranie z obiektu za pomocą getClass()
Class<Person> cl1 = (new Person()).getClass());

// Pobranie z klasy
Class<Person> cl2 = Person.class;
```

# Typowanie
<img src="../../../.files/image-20210409105311167.png" alt="image-20210409105311167" style="zoom:80%" />

 https://www.bdabek.pl/2020/02/15/pytania-rekrutacyjne-mid-01

 https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html

Są to typy podstawowe: **boolean, byte, char, short, int, long, float, double.  void**.

Dla każdego typu primitywnego istnieje klasa która go może owrappować. 

```java
Boolean oboolean = new Boolean();// bolean
Character ocharacter = new Character('a'); // char
Byte obyte = new Byte(); // byte
Short oshort = new Short(); // short
Integer ointeger = new Integer(1); // int
Long olong = new Long(1); // long
Float ofloat = new Float(1.0); // float
Double odouble = new Double(1.0); // double

// Nie możemy utworzy obiektu typu Void
// Void ovoid = new Void();
```

Typy prymitywne oraz ich odpowiedniki obiektowe można używać na przemian np. możemy zwiększyć wartość "int" za pomocą obiektu typu Integer, w trakcie wykonywania operacji kompilator dokona odpowiednie przekształcenia - taki proces nazywa się autoboxingiem.
## Autoboxing
 https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html 

Jest to mechanizm w którym typy proste takie jak: int, char ... są konwertowane przez Javę na obiekty i odwrotnie odpowiednie typy: Integer, Character... są zamieniane na typy proste w zależności od sytuacji.

Dzięki temu mechanizmowi możliwe jest np. przyrównywanie typów prostych do odpowiednich typów złożonych.

```java
Character characterObject = 'a';// 1

char character = characterObject;// 2
```

Po dekompilacji:

Pierwsza linia jest zapisana w bytecode:

```
2: invokestatic  #21 // Method java/lang/Character.valueOf:(C)Ljava/lang/Character;
```

Przyrównanie `Character characterObject = 'a'` jest wewnętrznie konwertowane na wywołąnie `Character.valueOf(...)`.

Natomiast wywołanie `char character = characterObject` wewnętrznie obiekt jest konwertowany na wartość.

```
27: invokestatic  #21 // Method java/lang/Character.valsueOf:(C)Ljava/lang/Character
```

Poniżej wszystkie konwersję z typu złożonego na typ prosty.

```java
byte byteValueInit = 10;
byte byteValue = new Byte(byteValueInit);// Method java/lang/Byte.byteValue:()

char charValue = new Character('a');// Method java/lang/Character.charValue:()
float floatValue = new Float(10.1);// // Method java/lang/Float.floatValue:()
int intValue = new Integer(10);// Method java/lang/Integer.intValue:()
long longValue = new Long(10L);// Method java/lang/Long.longValue:()
short shortValue = new Short("10");// Method java/lang/Short.shortValue:()
double doubleValue = new Double(10.10);// Method java/lang/Double.doubleValue:()
```

**Należy pamiętać, że typ złożony dla typu prostego jest niezmienny (immutable)**. Czyli np. obiekt typu `Double`  nie możemy zmienić wartości tak jak w przypadku innych obiektów. Dlatego tego typu obiekty nie mają metod zmieniających ich stan `set`. Ma to taką konsekwencję, że parametr przekazywany np. jako `Integer` pomimo, że jest obiektem to w trakcie przetwarzania zostanie utworzona kopia lokalna.

```java
@RequestMapping("/test-boxing")
public void indexBoxing() {
    Integer value = new Integer(10);

    System.out.println("Przed zmianą: " + value); // 10

    incrementByTen(value);

    System.out.println("Przed zmianą: " + value); // 10
}

public void incrementByTen(Integer value) {
    System.out.println("Przed zmianą wewnątrz: " + value); // 10
    
	// value to nie jest ten sam obiekt który został przekazany przy wywołaniu.
    value = value + 10;

    System.out.println("Po zmianą wewnątrz: " + value); // 20
}
```

W bytecode zostanie zapisane to w następujący sposób:

```
19: invokevirtual #13                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
22: invokevirtual #14                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
25: aload_1
26: invokevirtual #26                 // Method java/lang/Integer.intValue:()I
29: bipush        10
31: iadd
32: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
35: astore_1
36: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;
39: new           #7                  // class java/lang/StringBuilder
```

Zwróć uwagę na linijkę 26 i 27. Poniże typ `Integer` jest nie zmienny wiec przed dokonaniem dodania zostaje zmieniony na wartość. Następnie dodana wartość 10, linia 26, 31. A następnie spowrotem zamieniony na `Integer` w lini 32.

Nie możliwe jest rozszerzanie typów wrappujących typy proste. Czyli taki zapis jest niepoprawny.

```java
class OwnInteger extends Boolean {
	// ...
}
```

Jeśli chce zaimplementować własny typ numeryczny muszę rozszerzyć typ `Number`.

```java
static class OwnInteger extends Number {
    private int value;

    public void add(int value) {
        this.value += value;
    }

    public OwnInteger(int value) {
        this.value = value;
    }

    @Override
    public int intValue() { return value; }

    @Override
    public long longValue() { return value; }

    @Override
    public float floatValue() { return value; }

    @Override
    public double doubleValue() { return value; }
}
```

Co ciekaw implementacja własnego typu numerycznego może zostać wykorzystana zrzutowana na typy numeryczne takie jak `Integer, Double ...`. Tylko przy żyrowaniu należy pamiętać, że powstanie nowy obiekt. Zmiana nowego obiektu nie spowoduje zmiany obiektu pochodnego.

Dzięki temu możliwe jest takie wywołanie OwnInteger do funkcji w parametrem `Integer`

```java
@RequestMapping("/test-boxing")
public void indexBoxing() {
    OwnInteger value = new OwnInteger(10);

    System.out.println("Przed zmianą: " + value); // 10

    incrementByTen(value);

    System.out.println("Przed zmianą: " + value); // 10
}

public void incrementByTen(Integer value) {
    value = value + 10;
}
```
# Adnotacje
Jest to rozszerzenie składni języka o elementy pozwalające na adnotowanie samego języka programowania. Adnotacje używane są przy tgz. meta programowaniu. Adnotację pozwalają na opisywanie różnych elementów języka takich jak klasy, metody, zmienne, parametry dodatkowymi informacjami. Pozwala to na implementowanie bardziej złożonych mechanizmów.

Dobrym przykładem jest AOP który interpretuje adnotacje w celu wykonywania dodatkowych informacji. Możemy mieć np. adnotację `@LogCall`. Jeśli metoda zostanie oznaczona taką adnotacją to jej wywołanie zostanie zalogowanie. **Ważne jest to, że musi istnieć inny mechanizm który te adnotację odczyta.** Może to być np. proxy które przed wywołaniem metody sprawdzi jej adnotacje i wykona dodatkowe operacje.

W PHP (jeszcze za moich czasów) adnotacje były realizowane przez komentarze. W Javie jest to część języka.

Za pomocą adnotacji możemy oznaczyć **pakiet, typ, inną adnotację, pole klasy, konstruktor, metoda, parametr, zmienna lokalna, typ parametru**.
## Deklaracja adnotacji
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationOnMethod {
    boolean logCall() default false;
}
```

W trakcie deklaracjami musimy oznaczyć `@Target` który wskazuje do jakiego typu elementu można użyć adnotacji. Może to być jedna wartość lub lista.

| Typ w języku                  | Opis                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `ElementType#TYPE`            | Adnotacją możemy oznaczyć klasę np. z adnotacji `@Entity` korzysta Hibernate. |
| `ElementType#FIELD`           | Adnotacją możemy oznaczyć pola klasy. Przykładem może być adnotacja `@Autowire` lub `@Inject` . |
| `ElementType#METHOD`          | Adnotacją możemy oznaczyć metodę. Przykładem może być `@ResponseBody` w Springu. |
| `ElementType#PARAMETER`       | Adnotacją możemy oznaczyć parametr w metodzie. Przykładem może być `@PathVariable` w Springu do przekazywania informacji jakie parametry z żądania HTTP mają być mapowane na zmienne. |
| `ElementType#CONSTRUCTOR`     | Adnotacja dla konstruktora. przykładem może być `@Inject` w bibliotece Guice. |
| `ElementType#LOCAL_VARIABLE`  |                                                              |
| `ElementType#ANNOTATION_TYPE` | Adnotacja może służyć do do oznaczenia inne adnotacji. Dobrym przykładem jest adnotacja `@Target` która jest używana przy innych adnotacjach. |
| `ElementType#PACKAGE`         | Cały pakiet możemy oznaczyć adnotacją w pliku `package-info.java` która np. doda globalny mechanizm logowania wszystkich wywołań metod. |
| `ElementType#TYPE_PARAMETER`  | Adnotacja dla typu parametru.                                |
| `ElementType#TYPE_USE`        |                                                              |
| `ElementType#MODULE`          |                                                              |

Drugim parametrem który można zdefiniować `@Retention`. Określa on politykę dostępu do adnotacji.

| Typ w języki              | Opis                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `RetentionPolicy#SOURCE`  | Adnotacja jest w kodzie źródłowym. Kompilator usunie informację o niech w trakcie kompilacji. Tego typu polityka jest przydatna jeśli np. korzystam z narzędzia do analizy kod który zwraca uwagę określone adnotacje. |
| `RetentionPolicy#CLASS`   | Informacja o adnotacji zostanie umieszczona w byte kodzie ale nie będzie można jej odczytać np. przez refleksje. Może zostać to użyte np. gdy odczytujemy byte kod https://asm.ow2.io. Jest to podstawowe zachowanie. |
| `RetentionPolicy#RUNTIME` | Informacja o adnotacji będzie dostępna w trakcie działania programu przez mechanizm refleksji. |
## Odczytanie adnotacji
Informacje na temat użytych adnotacji pozyskujemy przez mechanizm refleksji. Prosty przykład odczytania informacji z pakietu został umieszczony powyżej. Więcej przykładów mam w repozytorium.

```java
Method findByIdMethod = userRepo.getClass().getMethod("findById", String.class);

AnnotationOnPackage annotation = findByIdMethod.getDeclaringClass().getPackage().getAnnotation(AnnotationOnPackage.class);

if (annotation.logOnPackage()) {
    System.out.printf("Log on package level");
}

```
## Wbudowanie adnotacje
Jest to grupa adnotacji dostarczanych przez JDK. 

- `@Override` sprawdza czy metoda jest nadpisana, jeśli nie to generowany jest błąd,
- `@Deprecated` generuje ostrzeżenie jeśli metoda jest wywołana,
- `@SuppressWarnings`wyłącza ostrzeżenia.
- `@SafeVarargs`,
- `@FunctionalInterface` definiuje interfejs jako funkcyjny,
- `@Repeatable`.
## Dziedziczenie adnotacji
Podstawowe zachowanie jest takie, że adnotacje nie są dziedziczone. **Klasa podrzędna nie dziedziczy adnotacji po klasie nadrzędnej**. To zachowanie można zmienić przez oznaczenie adnotacji inną adnotacją `@Inherited`. Oznacza to, że dana adnotacja będzie dziedziczone przez klasy rozszerzające. 

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface AnnotationInherited {
    boolean callLater();
}
```

Jeśli mamy taką strukturę.

```java
@AnnotationOnType(table = "USER")
@AnnotationInherited(callLater = true)
public class User {
	// ...
}

public class AdminUser extends User {
	// ...
}
```

To adnotacja `@AnnotationInherited` będzie dostępna również na `AdminUser`.
## Przetwarzanie adnotacji w czasie kompilacji
Java umożliwia generowanie/modyfikacje różnego rodzaju kodów/dokumentacji z wykorzystaniem tgz. procesora przy kompilacji. Tworzymy adnotację za pomocą której zdefiniujemy klasy dla których mają zostać wygenerowane obiekty fabryk (Factory).

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface CreateFactory {}
```

Każdy typ oznaczony adnotacją `@CreateFactory` powinien mieć wygenerowaną klasę `${NazwaKlasy}Factory` która będzie zawierała metody `set`, dla atrybutów które mają odpowiednią metodę `set` oraz metodę `create` która utworzy obiekt.

Poniżej tworzę procesor który przetworzy klasy oznaczone adnotacją i wygeneruje odpowiednie klasy fabryk.

Każdy procesor powinien implementować interfejs `javax.annotation.processing.Processor`, jednak nie implementujemy go bezpośrednio, lepiej jest rozszerzyć klasę `javax.annotation.processing.AbstractProcessor` która udostępnia dodatkowe narzędzia.

```java
public class FactoryProcessor extends AbstractProcessor {
    private Types typeUtils;
    private Elements elementUtils;
    private Filer filer;
    private Messager messager;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);

        typeUtils = processingEnv.getTypeUtils();
        elementUtils = processingEnv.getElementUtils();
        filer = processingEnv.getFiler();
        messager = processingEnv.getMessager();
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        Set<String> annotataions = new HashSet<>();

        annotataions.add(CreateFactory.class.getCanonicalName());

        return annotataions;
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }
    
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnvironment) {
        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(CreateFactory.class);

        if (!elements.isEmpty()) {
            for(Element element: elements) {
                if (element instanceof TypeElement) {
                    try {
                        processCreateFactory((TypeElement) element, roundEnvironment);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }

        return true;
    }

    private void processCreateFactory(
		// ...
    }

    private String getSetterFor(String classname, VariableElement variableElement) {
		// ...
    }

    private String getSetterMethodName(VariableElement field) {
		// ...
    }

    private boolean hasSetter(VariableElement variableElement, TypeElement typeElement) {
		// ...
    }
}
```

Każdy procesor powinien implementować metody: init, getSupportedAnnotationTypes, process, getSupportedSourceVersion.

W metodzie getSupportedAnnotationTypes zwracane są adnotacje które chcemy przetworzyć. W tej metodzie można ograniczyć sie tylko do określonych adnotacji jakie mają być przetworzone.

Metoda process jest uruchomiona w momencie przetwarzania adnotacji. Zmienna roundEnvironment przechowuje odpowiednie cykle przetwarzania kodu. Udostępnia metody takie jak getElementsAnnotatedWith która zwraca wszystkie elementy oznaczone określona adnotacją.

Na tym etapie należy pamiętać, że kod jest przetwarzany jako trzewo elementów. Podobnie jak dokument XML.

W metodzie processCreateFactory generowany jest kod klasy fabryki. Do generowania kodu użyty jest JavaFileObject a nastepnie zwykły Writer.

```java
PackageElement packageElement = (PackageElement) typeElement.getEnclosingElement();

List<? extends Element> childsElement = typeElement.getEnclosedElements();

final String classname = typeElement.getSimpleName() + "Factory";

JavaFileObject javaFileObject = filer.createSourceFile(packageElement.getQualifiedName() + "." + classname);

Writer writer = javaFileObject.openWriter();

writer.append(format("package %s;", packageElement.getQualifiedName()));
writer.append(format("public class %s {", classname));

List<VariableElement> createdSetter = new ArrayList<>();

for(Element childElement: childsElement) {
    if (childElement instanceof VariableElement) {
        VariableElement field = (VariableElement) childElement;

        if (!hasSetter(field, typeElement)) {
            continue;
        }

        writer.append(format("private %s %s;\n", field.asType(), field.getSimpleName()));
        writer.append("\n");
        writer.append(getSetterFor(classname, field));

        createdSetter.add(field);
    }

    writer.append("\n");
}

// Create creat() method
writer.append(format("public %s create() {\n", typeElement.getQualifiedName()));
writer.append(format("%s ob = new %s();\n", typeElement.getQualifiedName(), typeElement.getQualifiedName()));

for(VariableElement field: createdSetter) {
    writer.append(format("ob.%s(%s);\n", getSetterMethodName(field), field.getSimpleName()));
}

writer.append(format("return ob;\n"));
writer.append("}");

writer.append("}");
writer.flush();
writer.close();
```

Kod można wygenerować za pomocą JavaWriter w wykorzystaniem metod.

```java
TypeElement superClassName = elementUtils.getTypeElement(qualifiedClassName);
String factoryClassName = superClassName.getSimpleName() + SUFFIX;

JavaFileObject jfo = filer.createSourceFile(qualifiedClassName + SUFFIX);
Writer writer = jfo.openWriter();
JavaWriter jw = new JavaWriter(writer);

// Write package
PackageElement pkg = elementUtils.getPackageOf(superClassName);
if (!pkg.isUnnamed()) {
    jw.emitPackage(pkg.getQualifiedName().toString());
    jw.emitEmptyLine();
} else {
    jw.emitPackage("");
}

jw.beginType(factoryClassName, "class", EnumSet.of(Modifier.PUBLIC));
jw.emitEmptyLine();
jw.beginMethod(qualifiedClassName, "create", EnumSet.of(Modifier.PUBLIC), "String", "id");

jw.beginControlFlow("if (id == null)");
jw.emitStatement("throw new IllegalArgumentException(\"id is null!\")");
jw.endControlFlow();

for (FactoryAnnotatedClass item : itemsMap.values()) {
    jw.beginControlFlow("if (\"%s\".equals(id))", item.getId());
    jw.emitStatement("return new %s()", item.getTypeElement().getQualifiedName().toString());
    jw.endControlFlow();
    jw.emitEmptyLine();
}

jw.emitStatement("throw new IllegalArgumentException(\"Unknown id = \" + id)");
jw.endMethod();

jw.endType();
jw.close();
```

Efekt jest taki sam (drugi fragment kodu jest innym przykładem). 

Procesor można uruchomić przez opcję -processor.

```shell
javac -cp processors/target/advanced-java-part-14-java7.processors-0.0.1-SNAPSHOT.jar 
  -processor com.javacodegeeks.advanced.processor.MutatingAnnotationProcessor    
  -d examples/target/classes
  examples/src/main/java/com/javacodegeeks/advanced/processor/examples/MutableClass.java 
```

Lub np. przez konfigurację Mavena w pom.

```xml
<plugin>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.8.0</version>
    <configuration>
        <annotationProcessors>
     		<processor>...processor.FactoryProcessor</processor>
        </annotationProcessors>
    </configuration>
</plugin>
```

W obu przypadkach trzeba pamiętać o tym, że procesor powinien być wcześniej skompilowany a następnie dołączony jako zależność albo w classpath.

Wygenerowane pliki są umieszczane w pliku target. Efekt działania.

```java
User user = (new UserFactory())
    .setFirstName("Paweł Kowalski")
    .setBirthDate(new Date())
    .create();

System.out.println("user: " + user);
```

```
user: User{id='null', firstName='Paweł Kowalski', lastName='null', birthDate=Tue Apr 21 22:51:08 CEST 2020}
```

Za pomocą tego mechanizmu można wygenerować dokumentacj lub różnego rodzaju klasy. Hibernate np. generuje klasy metadanych.

Możemy wygenerować np. klasę fabryki abstrakcyjnej tworząc adnotacje @Factory która by generowała kod z towrzacy obiekt na podstawie ID i typu.

```java
@Factory(
    id = "Margherita",
    type = Meal.class
)
public class MargheritaPizza implements Meal {

  @Override public float getPrice() {
    return 6f;
  }
}
```

**AutoService**

Jest to biblioteka Googla która nieco upraszcza samo generowanie konfigurowanie procesowa. Wystarczy adnotacją oznaczyc klasę aby ta została dodana jako procesor.

```java
@AutoService(Processor.class)
public class AutoFactoryProcesser extends AbstractProcessor {
  @Override
  public synchronized void init(ProcessingEnvironment env) { ... }
  @Override
  public Set<String> getSupportedAnnotationTypes() { ... }

  @Override
  public SourceVersion getSupportedSourceVersion() { ... }
  @Override
  public boolean process(Set<? extends TypeElement> set,          
                         RoundEnvironment env) { ... }
}
```
# IoC I DI
W Javie zostały ustandaryzowane dwie adnotacje wykorzystywane do definiowania zależności.

`@Inject, @Named`.

Sama Java nie dostarcza standardowej biblioteki do wstrzykiwania zależności.

- Spring,
- Guice
- ...

Dostępnych jest kilka bibliotek które dostarczają kontener który na postawie adnotacji w odpowiedni sposób buduje tworzy obiekty.
# IO
 http://tutorials.jenkov.com/java-io/index.html

Java dostarcza wiele mechanizmów związanych z przetwarzaniem wejśćia/wyjśćia. Wiekszość elementów jest zdenfiniowana w pakiecie `java.io`. Poza wspomnianym pakietem dostępny jest Java NIO, który zawiera implementacją tgz. "non bloking input/output", czyli przetwarzanie bez blokowania. Istnieją również inne implementację input/output poza wymienionym pakietem mogą to być np. implementację Servletów.

Podstawowe klasy związane z przetwarzaniem wejścia i wyjścia:

|                  | Byte Based                                                   |                                                              | Character Based                                              |                                                              |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
|                  | Input                                                        | Output                                                       | Input                                                        | Output                                                       |
| Basic            | [InputStream](http://tutorials.jenkov.com/java-io/inputstream.html) | [OutputStream](http://tutorials.jenkov.com/java-io/outputstream.html) | [Reader](http://tutorials.jenkov.com/java-io/reader.html) [InputStreamReader](http://tutorials.jenkov.com/java-io/inputstreamreader.html) | [Writer](http://tutorials.jenkov.com/java-io/writer.hml) [OutputStreamWriter](http://tutorials.jenkov.com/java-io/outputstreamwriter.html) |
| Arrays           | [ByteArrayInputStream](http://tutorials.jenkov.com/java-io/bytearrayinputstream.html) | [ByteArrayOutputStream](http://tutorials.jenkov.com/java-io/bytearrayoutputstream.html) | [CharArrayReader](http://tutorials.jenkov.com/java-io/chararrayreader.html) | [CharArrayWriter](http://tutorials.jenkov.com/java-io/chararraywriter.html) |
| Files            | [FileInputStream](http://tutorials.jenkov.com/java-io/fileinputstream.html) [RandomAccessFile](http://tutorials.jenkov.com/java-io/randomaccessfile.html) | [FileOutputStream](http://tutorials.jenkov.com/java-io/fileoutputstream.html) [RandomAccessFile](http://tutorials.jenkov.com/java-io/randomaccessfile.html) | [FileReader](http://tutorials.jenkov.com/java-io/filereader.html) | [FileWriter](http://tutorials.jenkov.com/java-io/filewriter.html) |
| Pipes            | [PipedInputStream](http://tutorials.jenkov.com/java-io/pipedinputstream.html) | [PipedOutputStream](http://tutorials.jenkov.com/java-io/pipedoutputstream.html) | [PipedReader](http://tutorials.jenkov.com/java-io/pipedreader.html) | [PipedWriter](http://tutorials.jenkov.com/java-io/pipedwriter.html) |
| Buffering        | [BufferedInputStream](http://tutorials.jenkov.com/java-io/bufferedinputstream.html) | [BufferedOutputStream](http://tutorials.jenkov.com/java-io/bufferedoutputstream.html) | [BufferedReader](http://tutorials.jenkov.com/java-io/bufferedreader.html) | [BufferedWriter](http://tutorials.jenkov.com/java-io/bufferedwriter.html) |
| Filtering        | [FilterInputStream](http://tutorials.jenkov.com/java-io/filterinputstream.html) | [FilterOutputStream](http://tutorials.jenkov.com/java-io/filteroutputstream.html) | [FilterReader](http://tutorials.jenkov.com/java-io/filterreader.html) | [FilterWriter](http://tutorials.jenkov.com/java-io/filterwriter.html) |
| Parsing          | [PushbackInputStream](http://tutorials.jenkov.com/java-io/pushbackinputstream.html) [StreamTokenizer](http://tutorials.jenkov.com/java-io/streamtokenizer.html) |                                                              | [PushbackReader](http://tutorials.jenkov.com/java-io/pushbackreader.html) [LineNumberReader](http://tutorials.jenkov.com/java-io/linenumberreader.html) |                                                              |
| Strings          |                                                              |                                                              | [StringReader](http://tutorials.jenkov.com/java-io/stringreader.html) | [StringWriter](http://tutorials.jenkov.com/java-io/stringwriter.html) |
| Data             | [DataInputStream](http://tutorials.jenkov.com/java-io/datainputstream.html) | [DataOutputStream](http://tutorials.jenkov.com/java-io/dataoutputstream.html) |                                                              |                                                              |
| Data - Formatted |                                                              | [PrintStream](http://tutorials.jenkov.com/java-io/printstream.html) |                                                              | [PrintWriter](http://tutorials.jenkov.com/java-io/printwriter.html) |
| Objects          | [ObjectInputStream](http://tutorials.jenkov.com/java-io/objectinputstream.html) | [ObjectOutputStream](http://tutorials.jenkov.com/java-io/objectoutputstream.html) |                                                              |                                                              |
| Utilities        | [SequenceInputStream](http://tutorials.jenkov.com/java-io/sequenceinputstream.html) |                                                              |                                                              |                                                              |

Przetwarzanie wejścia i wyjścia wiąże się z takimi pojęciami jak źródło oraz wyjście (inpurt/output). Dane przychodzą ze źródła, są przetwarzane a następnie są przekazywane do wyjścia.

![image-20200225113004619](../../../.files/image-20200225113004619.png)
## Strumienie (Streams)
Jest to podstawowa koncepcja zwiazana z przetwarzaniem wejścia i wyjścia. Strumień jest niekończącym przepływem danych. Do strumienia można pisać lub z niego czytać. Strumienie są połączone z wejściem lub wyjściem. 

Java definiuje dwa typy strumieni: 

- działające na znakach (te na ogół zawierają słowo **Reader**/**Writer**),

- działające na bytes (są to klasy zawierające **InputStream/OutputStream**),.


Reader/Writer w pewnym sensie są pewnymi szczególnymi typami zwykłych strumieni wejścia i wyjścia. Na ogół do działania wykorzystują InputStream/OutputStream np. InputStreamReader wymaga przekazania parametru InputStream do tego aby odczytać znaki lub OutputStreamWriter wymaga przekazania OutputStream gdy chcemy np. wartości znakowe zapisywać w pliku.

```java
OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream("Test"));
```

Java dostarcza wiele implementacji gotowych strumieni do przetwarzania różnego rodzaju wejścia i wyjścia, sa to między innymi:

- File Access
- Network Access
- Internal Memory Buffer Access
- Inter-Thread Communication (Pipes)
- Buffering
- Filtering
- Parsing
- Reading and Writing Text (Readers / Writers)
- Reading and Writing Primitive Data (long, int etc.)
- Reading and Writing Objects

**Bufory** - są to klasy które pozwalają na przetwarzanie strumieni za pośrednictwem buforów. Jeśłi np. czytamy plik to możemy go odczytywać znak po znaku i przekazywać na wyjście lub najpierw wczytać cześć danych do bufora a następnie czytać linia po linii. Bufory występują również w przypadku strumieni wyjściowych, tam podobnie możemy dane najpierw umieścić w buforze (pamięci) aby następnie jednym poleceniem wszystkie przekazać na wyjście.
## Przetwarzanie Reader i Writer
Reader/Writer przetwarza dane traktując się jako znaki. Przykładem jest InputStreamReader do którego  przekazywany jest InputStream z którego wyciągane są znaki. Następnie dane są przekazywane do Writera który zapisuje dane znakowe.

| Typ               | Opis                                                         |
| ----------------- | ------------------------------------------------------------ |
| BufferedReader    | Pozwala na umieszczenie danych z InputStream w pamięci i przetwarzania ich w inny sposób niż po znaku. <br /><br />Typowym przykładem jest pobranie danych tekstowych do bufora i przetwarzanie ich linia po linii. <br /><br />Dodatkowo przetwarzanie za pomocą bufora redukuje ilość operacji odczytu i zapisu. |
| CharArrayReader   | Odczytanie z listy znaków.                                   |
| FilterReader      | Odczytanie odfiltrowanych znaków.                            |
| InputStreamReader | Odczytanie na postawie InputStream                           |
| PipedReader       | Odczytanie potokowe (pipe).                                  |
| StringReader      | Odczytanie ze ciągu znakow (Stringa).                        |

Poniżej przykłady inicjowania Readerów.

```java
StringReader reader = new StringReader("Test");
CharArrayReader reader = new CharArrayReader(new char[]{'1', '2', '3', '4', '5'});

BufferedReader bufferedReader = new BufferedReader(new StringReader("Test\nJan"));

// FilterReader
RemoveCommentReader reader = new RemoveCommentReader(new StringReader("test\n// comment\nkowalski"));
InputStreamReader reader = new InputStreamReader(this.getClass().getResourceAsStream("/input-test.txt"));

// Pipe
PipedWriter pipedWriter = new PipedWriter();
PipedReader reader = new PipedReader(pipedWriter);

pipedWriter.write(10);
pipedWriter.write(20);
```

Następnie odczytanie danych:

```java
int data;

while ((data = reader.read()) != -1) System.out.println(data);
```

W przypadku przetwarzania za pomocą bufora możliwe jest odczytywanie linii.

```java
BufferedReader bufferedReader = new BufferedReader(new StringReader("Test\nJan"));

String line;

while ((line = bufferedRseader.readLine()) != null) System.out.println(line);
```

Writer jest odpowiedzialny za przyjęcie danych (Writer jest pewnym przypadkiem OutputStream).

Istnieje kilka podstawowych Writerów:

| Typ                | Opis                                                         |
| ------------------ | ------------------------------------------------------------ |
| BufferedWriter     | Pozwala wpisywać wartości do buffora a następnie paczki przekazywanie ich do Writera. |
| CharArrayWriter    | Pozwala na umieszczanie znaków.                              |
| FilterWriter       | Wprowadzane dane są filtrowane.                              |
| OutputStreamWriter | Zapisuje dane do strumienia wyjściowego.                     |
| PipedWriter        | Przekazuje dane do potoku.                                   |
| PrintWriter        |                                                              |
| StringWriter       |                                                              |

**BufferedWriter**

Pozwala na umieszczenie danych w buforze a następnie za jednym razem przekazanie ich do docelowego Writera.

```java
StringWriter stringWriter = new StringWriter();
BufferedWriter writer = new BufferedWriter(stringWriter);

writer.write("Paweł");
writer.newLine();
writer.write("!@#$");

// Następuje przekazanie danych do stringWriter.
writer.flush();

System.out.println(stringWriter.toString());
```

**CharArrayWriter**

Pozwala na wpisywanie pojedynczych znaków.

```java
InputStreamReader reader = new InputStreamReader(this.getClass().getResourceAsStream("/input-test.txt"));

CharArrayWriter writer = new CharArrayWriter();

int data;
while ((data = reader.read()) != -1) writer.append((char) data);

System.out.println(writer.toString());
```

**OutputStreamWriter**

Pozwala na przekazanie danych do zwykłego OutputStream.

```java
InputStreamReader reader = new InputStreamReader(this.getClass().getResourceAsStream("/input-test.txt"));

OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream("input-test-copy.txt"));

int data;
while ((data = reader.read()) != -1) writer.append((char)data);

writer.flush();
```
## Interfejs `Closeable`
W zasadzie w przypadku wszystkich klas które implementuj strumienie udostępniaj mechanizm **try-with**. 

```java
try (InputStream inputStream = getClass().getResourceAsStream("/text.txt")) {
    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));

    int c;

    while ((c = bufferedReader.read()) > 0) {
        stringBuilder.append((char)c);
    }

    return stringBuilder.toString();
}
```
# Typy danych
## Typy generyczne
Typy generyczne pojawiły się od `JDK 5.0`. Typy generyczne są podobne do szablonów `C++`. Typy generyczne są pod typami dla normalnych typów.

Typowym przykładem klas generycznych są różnego rodzaju kontenery (`List, Stack, Map, HashKey ...`). Poniżej przykład listy bez określonego typu, typem jest `Object`.

```java
List myIntList = new LinkedList(); // 1
myIntList.add(new Integer(0)); // 2
Integer x = (Integer) myIntList.iterator().next(); // 3
```

Kompilator nie jest wstanie sprawdzić jakiego typu obiekty znajdują się na liście. Dlatego w momencie pobierania obiektu wymagane jest rzutowanie obiektu na określony typ, programista musi wiedzieć jaki. Taka operacja niesie pewne ryzyko, że np. obiekt na liście nie będzie mógł być rzutowany na określony typ.

**Typy generyczne pozwalają wprowadzić dodatkowe informacje do kodu, dzięki czemu kompilator może sprawdzić czy typy są zgodne.**

```java
List<Integer> myIntList = new LinkedList<Integer>(); // 1'
myIntList.add(new Integer(0)); // 2
Integer x = myIntList.iterator().next(); // 3
```

Typy generyczne są definiowane następująco:

```java
public interface List <E> {
    void add(E x);
    Iterator<E> iterator();
}

public interface Iterator<E> {
    E next();
    boolean hasNext();
}
```

Można to czytać następująco (uproszczenie) :

```java
public interface IntegerList {
    void add(Integer x);
    Iterator<Integer> iterator();
}
```

**Nie oznacza to**, że powstaje nowy typ, nowa klasa itp. Różni się to od szablonów w `C++`. Typ jest kompilowany tylko raz i wykorzystywany wielokrotnie.

Przyjeło się, że nazwy typów generycznych oznaczane są dużymi literami `T, E, S` .
### Kowariancja i kowariancja i inwariancja
W przypadku typów generycznych kowariancja i kontrwariancja nie dzieje się "samoczynnie" jak w przypadku typów normalnych. Standardowo typy generyczne są **inwariantne**. Kowariancja i kontrwariancja jest możliwa gdy zostanie ona zdefiniowana odpowiednimi wyrażeniami.

W przypadku typów generycznych, pod typy, nad typy nie działają tak jak w przypadku normalnych typów. Np.

```java
List<String> ls = new ArrayList<String>(); // 1
List<Object> lo = ls; // 2
```

W przykładzie powyżej, nie możemy np. do zmiennej z lista obiektów przypisać listę obiektów typu `String` pomimo, że `String` jest pod typem `Object`. Intuicja podpowiada, że lista `String` jest również listą `Object`.

Wyżej opisana sytuacja wynika stąd, że po takim przypisaniu moglibyśmy do listy dodać inny obiekt.

```java
lo.add(new Object()); // 3
String s = ls.get(0); // 4: Attempts to assign an Object to a String!
```

Następnie z referencji `ls` pobieramy obiekt dodany przez referencje `lo`. Taka sytuacja powoduje, że dowolny obiekt próbujemy rzutować na `String` nie mają pewności, że jest to obiekt tego typu. Taka sytuacja została zabezpieczona tym, że nie możemy w taki sposób przypisać obiektów generycznych.

**Powyższa reguła wyjaśnia, dlaczego `G<A>` nie jest równe `G<B>` pomimo, że B > A**
### Symbole wieloznaczne (Wildcards)
Symbole wieloznaczne pozwalają rozszerzyć zakres dopuszczalnych typów generycznych.

Na przykładzie kolekcji obiektów. Przed wersją 5.0. iteracja po obiektach wyglądała tak:

```java
void printCollection(Collection c) {
    Iterator i = c.iterator();
    for (k = 0; k < c.size(); k++) {
        System.out.println(i.next());
    }
}
```

Możemy to również zapisać tak (za pomocą typów):

```java
void printCollection(Collection<Object> c) {
    for (Object e : c) {
        System.out.println(e);
    }
}
```

Nowy zapis wymaga aby funkcja  miała typ parametru  `Collection<Object>`. Nie jest to praktyczne, ponieważ wymagane jest aby obiekty były typu `Object`. O czym pisałem wcześniej.

```java
public void testing() {
    run(new ArrayList<Object>()); // OK
    // run(new ArrayList<String>()); // Wrong
}

public void run(Collection<Object> list) {

}
```

Aby powyższe wywołane było możliwe, musimy użyć notacji `?`, aby dopuścić dowolny typ dla typu generycznego. Ponieważ obiekt jest niezdefiniowany to kolekcja zwraca typ `Object`.

```java
@Test
public void testing() {
    run(new ArrayList<Object>()); // OK
    run(new ArrayList<String>()); // OK
}

public void run(Collection<?> list) {

}
```

Załóżmy, że mamy następującą hierarchię klas.

```java
public abstract class Shape {
    public abstract void draw(Canvas c);
}

public class Circle extends Shape {
    private int x, y, radius;
    public void draw(Canvas c) {
        ...
    }
}

public class Rectangle extends Shape {
    private int x, y, width, height;
    public void draw(Canvas c) {
        ...
    }
}
```

Możemy stworzyć mechanizm do rysowania:

```java
public class Canvas {
    public void draw(Shape s) {
        s.draw(this);
   }
}
```

Powyższy mechanizm działa dobrze dla pojedynczych przypadków.

Załóżmy, że chcemy mieć funkcje która będzie wszystkie figury z listy.

```java
public void drawAll(List<Shape> shapes) {
    for (Shape s: shapes) {
        s.draw(this);
   }
}
```

W przypadku tej funkcji jest taki problem, że musi ona zostać wywołana dokładnie z listą typu `Shape` (o tym pisałem wyżej), a nie np. `Cirle, Rectangle`.

Możemy to naprawić, rozszerzając dopuszczalny typ `? extends Shape`. Dopuszczamy kowariancję, czyli dopuszczamy rzutowanie obiektu na `Shape`.

```java
public void drawAll(List<? extends Shape> shapes) {
    ...
}
```

W tym momencie jest dopuszczalne jest wywołanie funkcji z listą `Circle` lub `Rectangle` ponieważ dla obu typem nadrzędnym jest `Shape`.  Wewnątrz funkcji następuje kowariancja z typu nieokreślonego na typ `Shape`. Taką operację nazywamy górnym ograniczeniem.

Niestety taki zapis powoduje, że nie możemy dodać nowych obiektów do listy.

```java
public void addRectangle(List<? extends Shape> shapes) {
    // Compile-time error!
    shapes.add(0, new Rectangle());
}
```

Wynika to stąd, że nie wiemy jakiego typu obiekty zawiera lista, wiemy tylko tyle, że dziedziczą one po `Shape`.

Inny przykład, z wykorzystaniem mapy.

```java
public class Census {
    public static void addRegistry(Map<String, ? extends Person> registry) {
}

Map<String, Driver> allDrivers = ... ;
Census.addRegistry(allDrivers);
```

Załóżmy, że mamy taki kod:

```java
class Generic<T> {
    T t;

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }
}

Generic a = new Generic();
Generic<?> b = new Generic<>();
Generic<Object> c = new Generic<>();
Generic<String> d = new Generic<>();

a.set("Test"); // OK
// b.set("Test"); // Wrong
c.set("Test"); // OK
d.set("Test"); // OK

// Wariant A
a = b;
a = c;
a = d;

// Wariant B
b = a;
b = c;
b = d;

// Wariant C
c = a;
// c = b; // Żle
// c = d; // Żle

// Wariant D
d = a;
// d = b; // Żle
// d = c; // Żle
```

Zmienna `a` nie ma zdefiniowanego typu dla typu generycznego. Oznacz to, że:

- metody `get, set` będą działały na zmiennej typu `Object`,
- do zmiennej może zostać przypisany dowolny obiekt, tak jak w `Wariant A` gdzie do zmiennej możemy wpisać dowolny inne obiekt tego typu.

Zmienna `b` ma określony typ generyczny jako dowolny, oznacza to, że nie wiemy jakiego typu przechowuje ona obiekt, nie możemy również wykonać metody `set` ponieważ typ jest nieokreślony. Podobnie jak dla zmiennej `a`, do tej zmiennej możemy przypisać dowolny obiekt. Z tym, że staje się on tylko do odczytu.

Zmienna `c` definiuje już typ (dla typu generycznego). Czyli takie zdefiniowanie narzuca. Dlatego do zmiennej możemy przypisać tylko obiekt `a`.

Zmienna `d` również definiuje typ, tutaj również nie możemy przypisać innego typu niż `a`.

Z powyżej analizy wynika `Generic != Generic<Object>`, bez zdefiniowanego typu (dla typu generycznego) możliwe jest przypisane do tej zmiennej do innej zmiennej (z określonym typem) lub przypisanie tej zmiennej do innej zmiennej bez określonego typu. W poniższym kodzie wykorzystałem zmienna `a` do tego aby dodać coś do zmiennej `b` pomimo, że ta nie ma określonego typu.

```java
Generic a = new Generic();
Generic<?> b = new Generic<>();
Generic<Object> c = new Generic<>();
Generic<String> d = new Generic<>();

a.set("Test"); // OK
// b.set("Test"); // Wrong
c.set("Test"); // OK
d.set("Test"); // OK

a = b;

a.set("Test");

System.out.println(b.get());// Test
```

Odczytuje to tak, że zmienna `a` nie ma zdefiniowanego typu (dla typu generycznego), więc tak jak by cały mechanizm sprawdzający jest pomijamy.
### Dolny i górny zakres `? extend T` i `? super T`.
Górny zakres pojawił w poprzednim rozdziale. Pozwolił on zdefiniować górny zakres dla typu generycznego.

Ogólnie bez zdefiniowanego zakresu klasa generyczna nie wie jakiego typu jest obiekt, wiec nie może wykonać żadnej operacji na tym obiekcie. Jest to spore ograniczenie. 

```java
class Resolver<T> {
    public void resolve(T object) {
        // object.resolve() ???
    }
}
```

Dzięki zakresowi wprowadzamy ograniczenie ale jednocześnie dostajemy możliwość wykonania operacji na obiekcie.

```java
interface Printable {
    void print();
};

class Printer<T extends Printable> {
    public void print(T document) {
        document.print(); // OK
    }
}
```

W powyższym przykładzie, dzięki wprowadzeniu górnego ograniczenia, że obiekt generyczny musi być pod typem `Printable` mogę wywołać metodę `print`.

Wprowadzenie górnego zakresu sprawia, że wewnątrz klasy (jak i na zewnątrz) nie można utworzyć obiektu i przypisać go do zmiennej typu `T`.  Jak poniżej, do zmiennej `last` próbuje przypisać obiekty które rozszerzają `A`. Nie możemy tego zrobić ponieważ nie wiemy dokładnie czym jest `T` w konkretnym przypadku. `T` może być `B,C` **Nie wiem tego z poziomu klasy**.

```java
class A {
    public int count() {
        return 1;
    }
};

class B extends A{};
class C extends B{};

class Counter<T extends A> {
    T last;

    public int count(T e) {
        e.count();

        last = new A(); // Error
        last = new B(); // Error
        last = new C(); // Error
    }
}
```

Dlatego użycie górnego ograniczenia `? extends T` nazywane jest mechanizmem konsumpcji. Dolny zakres (`? supper T` ) pozwala na zdefiniowanie dolnego zakres. Typowym przykładem wykorzystania dolnego zakresu jest `Consumer`. Przykładowy `Consumer` jest wykorzystywany w listach dla metody `forEach`.

```java
List<A> listA = new ArrayList<>();
List<B> listB = new ArrayList<>();
List<C> listC = new ArrayList<>();

Consumer<A> ca = new Consumer<A>() {
    @Override
    public void accept(A a) {}
};

Consumer<B> cb = new Consumer<B>() {
    @Override
    public void accept(B b) {}
};

Consumer<C> cc = new Consumer<C>() {
    @Override
    public void accept(C c) {}
};

listA.forEach(ca);
// listA.forEach(cb); // Error
// listA.forEach(cc); // Error

listC.forEach(ca);
listC.forEach(cb);
listC.forEach(cc);

listB.forEach(ca);
listB.forEach(cb);
// listB.forEach(cc); Error

```

`Consumer` ma metodę `accept` która jest wywoływana z elementem listy przy iterowaniu. Załóżmy, że mamy listę obiektów `C`, teoretycznie do iterowania możemy wykorzystać `Consumer<A, B, C>` tutaj nie ma z tym problemy ponieważ `C` możemy prze typować na `A, B` . Dzięki dolnego zakresowi, możliwe jest wywołanie ogólnego `Consumera<A>` dla wszystkich list.

Spróbujmy zrobić coś takiego za pomocą górnego ograniczenia `? extends T`. W tym celu zaimplementowałem własną listę oraz własnego `Consumera`.

```java
interface ConsumerExtends<T> {
    void call(T t);
}

class ListExtends<T> {
    public void forEach(ConsumerExtends<? extends T> consumer) {
        // ... forlopp
    }
}

ListExtends<A> listExtendsA = new ListExtends<>();
ListExtends<B> listExtendsB = new ListExtends<>();
ListExtends<C> listExtendsC = new ListExtends<>();

ConsumerExtends<A> consumerExtendsA = new ConsumerExtends<A>() {
    @Override
    public void call(A a) {}
};

ConsumerExtends<B> consumerExtendsB = new ConsumerExtends<B>() {
    @Override
    public void call(B b) {}
};

ConsumerExtends<C> consumerExtendsC = new ConsumerExtends<C>() {
    @Override
    public void call(C c) {}
};

listExtendsA.forEach(consumerExtendsA);
listExtendsA.forEach(consumerExtendsB);
listExtendsA.forEach(consumerExtendsC);

// listExtendsB.forEach(consumerExtendsA); // Error
listExtendsB.forEach(consumerExtendsB);
listExtendsB.forEach(consumerExtendsC);

// listExtendsC.forEach(consumerExtendsA); // Error
// listExtendsC.forEach(consumerExtendsB); // Error
listExtendsC.forEach(consumerExtendsC);

```

Problem jest tego typu, że dla `ListExtends<A>` możemy użyć `Consumera<B, C>` co jest niepoprawne i spowoduje błąd. W trakcie wywoływania metody `call` obiekt będzie typu `A` dla `Consumera<C, B>`.

Gdyby nie było dolnego ograniczenia, to nie było by możliwe wywołanie metody `forEach` z `Consumerem` innego typu niż ten ustawiony na kolekcji.

**Jest to dobry przykład pokazujący kiedy dolne ograniczenie jest potrzebne.**

Należy zwrócić uwagę, że dolne ograniczenie używane jest w parametrach metod. Czyli nie napiszemy czegoś takiego:

```java
interface ConsumerExtends<T super A> {
    void call(T t);
}
```
#### Przykład z listą
```java
class A {
    public int count() {
        return 1;
    }
};

class B extends A{};
class C extends B{};

class ListOwn<T> {
    List<T> items = new ArrayList<>();

    // Producer
    public void copyTo(ListOwn<? super T> target) {
        for(T item: items) {
            target.put(item);
        }
    }

    // Consumer
    public void putAll(ListOwn<? extends T> target) {
        for(T item: items) {
            items.add(item);
        }
    }

    public void put(T item) {
        items.add(item);
    }

    public List<T> getAll() {
        return items;
    }
}

```

Mamy listę z dwie metoda:

- `copyTo` przenosi zawartość listy do innej listy,
- `putAll` kopiuje zawartość listy do siebie.

Metoda `copyTo` jest typowym przykładem tgz. `Producera`. Aby móc przenieść obiekty na inna listę ta inna lista musi być typu co najmniej `T` lub wyżej. Jeśli nie jest typu `T` nastąpi rzutowanie obiektu. Rzutowanie jest możliwe ponieważ został zdefiniowany dolny zakres.

Metoda `putAll` działa znowu jako `Consumer`, czyli odczytuje z listy elementy i dodaje je do swojej listy. Jest to możliwe dlatego, że każdy obiekt na liście może zostać przekształtowany na obiekt `T`.

```java
listA.copyTo(listA);
// listA.copyTo(listB); // Error
// listA.copyTo(listC); // Error

listB.copyTo(listA);
listB.copyTo(listB);
// listB.copyTo(listC); // Error

listC.copyTo(listA);
listC.copyTo(listB);
listC.copyTo(listC);

// putAll
listA.putAll(listA);
listA.putAll(listB);
listA.putAll(listC);

// listB.putAll(listA); // Error
listB.putAll(listB);
listB.putAll(listC);

// listC.putAll(listA); // Error
// listC.putAll(listB); // Error
listC.putAll(listC);
```

Powyżej wywołanie poszczególnych metod w odpowiednich kombinacjach.
#### Dolny zakres i komparatory
Dolny zakres znajduje zastosowanie również w przypadku komparatorów. Komparator to obiekt który otrzymuje dwa obiekty i zwraca informację który obiekt jest większy od drugiego.

```java
class A {}
class B extends A {}

SortedList<A> listA = new SortedList<>();
SortedList<B> listB = new SortedList<>();

Comparator<A> comparatorA = new Comparator<A>() {
    @Override
    public int compare(A o1, A o2) {
        return 0;
    }
};

Comparator<B> comparatorB = new Comparator<B>() {
    @Override
    public int compare(B o1, B o2) {
        return 0;
    }
};

listA.setComparator(comparatorA);
// listA.setComparator(comparatorB); // ERROR

listB.setComparator(comparatorA);
listB.setComparator(comparatorB);
```

Dzięki dolnego zakresu możliwe jest wykorzystanie komparatora `A` dla listy `B`. Jako kontr przykład stwórzmy listę która wymaga komparatora dla zdefiniowanego typu.

```java
class A {}
class B extends A {}

class ListStrict<T> {
    T[] elements;

    public void setComparator(Comparator<T> comparator) {
        comparator.compare(elements[0], elements[1]);

        // ...
    }
}

ListStrict<A> listStrictA = new ListStrict<>();
ListStrict<B> listStrictB = new ListStrict<>();

Comparator<A> comparatorA = new Comparator<A>() {
    @Override
    public int compare(A o1, A o2) {
        return 0;
    }
};

Comparator<B> comparatorB = new Comparator<B>() {
    @Override
    public int compare(B o1, B o2) {
        return 0;
    }
};

listStrictA.setComparator(comparatorA);
// listA.setComparator(comparatorB); // ERROR

// listStrictB.setComparator(comparatorA); // ERROR
listStrictB.setComparator(comparatorB);
```

Przy komparatorze z konkretnie określonym typem `Comparator<B>` lub `Comparator<A>`, nie możemy użyć komparatora `A` dla listy `B`.
### Wnioskowanie typu
Przy typach generycznych nie jest zawsze koniecznie zdefiniowanie typu. Java jest w stanie wywnioskować jaki jest typ. Weźmy prosty przykład metody która zwraca podana wartość lub inna jeśli ta pierwsza jest NULLEM.

```java
public static void main(String[] args ) {
    String test = ifnull(null, "test");
}

private static <T> T ifnull(T object, T def) {
    if (object == null) {
        return def;
    } else {
        return object;
    }
}
```

W powyższym przykładzie, metoda `ifnull` jest metodą generyczną, przy wywołaniu Java domyśliła się, że zwracany obiekt jest `String`bez potrzeby definiowania typy przy wywołaniu.
#### Przykład
```java
class A {}
class B extends A {}
class C extends B {}

class Sink<T> {
    void flush(T t) {}
}
```

W powyższym przykładzie mamy klasę `Sink` na której wywoływana jest metoda `flush` z obiektem typu `T`.

Mamy metodę `flushAll` która iteruje po wszystkich obiektach i przekazuje je do metody `flush`. Metoda `flushAll` zwraca ostatni element.

```java
private static <T> T flushAll(List<T> list, Sink<T> sink) {
    T last = null;

    for(T item: list) {
        sink.flush(item);

        last = item;
    }

    return last;
}
```

W przypadku tej metody ciekawy jest sam proces wnioskowania typów przez Jave.

```java
Sink<A> sinkA = new Sink<>();
Sink<B> sinkB = new Sink<>();
Sink<C> sinkC = new Sink<>();

A a = flushAll(new ArrayList<A>(), sinkA);
B b = flushAll(new ArrayList<B>(), sinkB);
C c = flushAll(new ArrayList<C>(), sinkC);
```

Na przykładzie powyższych wywołań, każde jest poprawne. Typ `T` jest odczytywany jako typ `A, B, C` w zależności od wywołania.

```java
A a = flushAll(new ArrayList<A>(), sinkA);
B b = flushAll(new ArrayList<B>(), sinkA); // Error
C c = flushAll(new ArrayList<C>(), sinkA); // Error
```

Aby móc wywołać `Sink<A>`, musimy zmienić metodę.

```java
private static <T> T flushAll(List<T> list, Sink<? super T> sink)
```

Wtedy takie wywołanie staje się możliwe.
### Metody generyczne
Podobnie jak dla klas Java posiada możliwość definiowania metod generycznych.

```java
static <T> void fromArrayToCollection(T[] a, Collection<T> c) {
    for (T o : a) {
        c.add(o); // Correct
    }
}
```

Powyższą metodę możemy wywołać z dolnym typem parametru.

```java
Object[] oa = new Object[100];
Collection<Object> co = new ArrayList<Object>();

// T inferred to be Object
fromArrayToCollection(oa, co);

String[] sa = new String[100];
Collection<String> cs = new ArrayList<String>();

// T inferred to be String
fromArrayToCollection(sa, cs);

// T inferred to be Object
fromArrayToCollection(sa, co);

Integer[] ia = new Integer[100];
Float[] fa = new Float[100];
Number[] na = new Number[100];
Collection<Number> cn = new ArrayList<Number>();

// T inferred to be Number
fromArrayToCollection(ia, cn);

// T inferred to be Number
fromArrayToCollection(fa, cn);

// T inferred to be Number
fromArrayToCollection(na, cn);

// T inferred to be Object
fromArrayToCollection(na, co);

// compile-time error
fromArrayToCollection(na, cs);
```

W przypadku metod generycznych warto zwrócić uwagę na to, że nie jest konieczne definiowanie typu (dla metody generycznej), kompilator sam spróbuje się domyśleć jakiego typu użyć.

Mamy metodę która zwraca pierwszy element listy.

```java
private static <T> T getFirst(List<T> elements) {
    if (elements.size() > 0) {
        return elements.get(0);
    } else {
        return null;
    }
}
```

Wywołując metodę, nie musimy definiować typu. Kompilator się spróbuje domyśleć jakie typu jest `T`.

```java
String name = getFirst(new ArrayList<String>());
Car car = getFirst(new ArrayList<Car>());
Alfa alfa = getFirst(new ArrayList<Alfa>());
```
# Strumienie
Strumienie danych pojawiły się od Javy 8. Znajdują się one w pakiecie `java.util.stream`. Są one odpowiedzialne za przetwarzanie danych w postaci strumieni oraz za operacje na wielu elementach. Do reprezentowania kolekcji w trakcie przetwarzania służy nowy interfejs `Stream<T>`. Na strumieniach możemy wykonać szereg operacji, aby na końcu pobrać wynik (metoda agregująca) tych operacji bez zmiany stanu samego strumienia.

Operacje na strumieniach można podzielić na dwa typy:

- terminalne (ang. *terminal*)
  są to operacje, które zamykają strumień. Kończą one pracę ze strumieniem. Uwaga! Może być tylko jedna operacja kończąca, w przeciwnym wypadku wystąpi wyjątek,
- pośrednie (ang. *intermediate*)
  czyli metody, które operują na strumieniu, ale go nie zamykają. Dzięki temu, możliwy jest **chaining.

Strumienie są leniwie inicjowane (ang. *laziness-seeking*), czyli operacje pośrednie wykonywane są dopiero wtedy, kiedy natrafią na operację terminalną.

Wykonywanie operacji w łańcuchu (ang. *chaining*) jest możliwe dzięki metodom (wykonywanym na strumieniach), które zwracają przetworzony strumień.

**Strumienie są “jednorazówkami” (ang. *nonreusable*), czyli nie wykorzystujemy ich kilka razy, ponieważ każde użycie strumienia musi być zakończone operacją terminalną (zamykającą strumień).**

Operacje na strumieniach domyślnie wykonywane są sekwencyjnie, czyli w jednym wątku. Natomiast mamy możliwość przestawienia sposobu wykonywania operacji na równoległy, czyli wykonywany w kilku wątkach.

Pakiet stream w bardzo elegancki sposób dostarcza nam możliwość przełączenia trybu pracy na równoległy:

```
stream.parallel()
```

Natomiast jeśli chcemy wywołać przetwarzanie sekwencyjne (które jest ustawione domyślnie):

```
stream.sequential()
```

Strumienie można tworzyć na różne sposoby. Poniżej znajdują się trzy przykłady:

Wywołanie metody stream() na obiekcie kolekcji (najczęściej wykorzystywane).

```
Collection.stream()
```

Wykorzystanie pakietu `Stream`.

```
Stream.of()
```

Wykorzystanie pakietu `Arrays`.

```
Arrays.stream()
```
## Wykorzystanie `filter, sorted, map`, count
W poniższym przykładzie listę obiektów przetwarzam za pomocą strumienia. W przykładzie korzystam z metody `stream`  

```java
public class App
{
    public static void main(String[] args) {
        ArrayList<Person> persons = new ArrayList<Person>(5);

        persons.add(new Person("Janek", 10));
        persons.add(new Person("Maciek", 20));
        persons.add(new Person("Godia", 25));
        persons.add(new Person("Krystian", 55));

        Stream<Person> personStream = persons.stream();

        // Możemy zliczyć ilość danych w strumieniu
        long count = persons.stream()
            .count()
        ;
        
        List<Integer> list = persons.stream()
            // Możemy np. odfiltrować kilka osób.
            .filter(new Predicate<Person>() {
                @Override
                public boolean test(Person person) {
                    return person.getAge() >= 25;
                }
            })
            // Sortujemy
            .sorted(new Comparator<Person>() {
                @Override
                public int compare(Person person, Person t1) {
                    return t1.compareTo(person);
                }
            })
            // Mapujemy na inne dane
            .map(new Function<Person, Integer>() {
                @Override
                public Integer apply(Person person) {
                    return person.getAge();
                }
            })
            // Zwracamy wynik
            .collect(Collectors.toList())
        ;
    }

    private static class Person implements Comparable<Person>{
        private String name;
        private int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }

        public int compareTo(Person person) {
            return getAge() > person.getAge() ? 1 : -1;
        }

        @Override
        public String toString() {
            return "Person{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }
}
```
## Wykorzystanie `reduce`
`reduce` pozwala na wyciągnięcie wartości ze strumienia danych. Jest poleceniem terminującym.

```java
public class App
{
    public static void main(String[] args) {
        ArrayList<Person> persons = new ArrayList<Person>(5);

        persons.add(new Person("Janek", 10));
        persons.add(new Person("Maciek", 20));
        persons.add(new Person("Godia", 25));
        persons.add(new Person("Krystian", 55));

        String names = persons.stream()
            .map(new Function<Person, String>() {
                @Override
                public String apply(Person person) {
                    return person.getName();
                }
            })
            .reduce(new BinaryOperator<String>() {
                @Override
                public String apply(String s, String s2) {
                    return s + "," + s2;
                }
            }).orElse("Brak danych")
        ;

        System.out.println(names);
    }
}
```
## Łączenie strumieni `concat`
Funkcja pozwala na łączenie ze strumieni.

```java
IntStream.concat(IntStream.of(new int[]{2, 1}), IntStream.of(new int[]{4, 3}))
    .sorted()
    .forEach(System.out::println)
;
```
## Grupowanie za pomocą `groupingBy `
...

## Wady i zalety
**Zalety**

1. zaletą strumieni jest to, że pozwalają one pisać kod w bardziej **deklaratywny sposób**. Oznacza, że to, że nie piszę kodu który np. mapuje jedną wartość na drugą tylko piszę wywołane funkcji `map`. Jeśli mamy kilka takich operacji to taki sposób deklaratywny jest czytelniejszy.

2. podobieństwo do stylu funkcyjnego - sposób zapisu operacji jest bardziej intuicyjny.

3. Operacje na strumieniu z założenia nie modyfikują obiektów tylko generują nowe. Takie podejście jest lepsze dla przetwarzania wielowątkowego.

4. Możemy przetwarzać strumienie nie wiedząc jakie jest jego źródło ani też nie wiedząc jak zostanie on zakończony. Dzięki czemu np. możemy przekazywać strumień do metody która przetworzy w określony sposób i przekaże dalej. 

5. Za pomocą strumieni możemy złożone operacje zapisać w prosty sposób

   ```java
   stream.filter(myfilter).findFirst();
   ```

6. Przetwarzanie przez strumienie daje perspektywę nowych możliwości, optymalizacji przetwarzania itp. nawet jeśli aktualnie nie wygląda to lepie. Być może w przyszłości pojawią mechanizmy które będą usprawniać ten proces.

7. Proste zastosowanie przetwarzania równoległego. Pewne operację na strumieniach mogą być zrównoleglone w dość prosty sposób. **Strumień musi spełniać określone warunki.**

**Wady**

1. Na ogół gorsza wydajność w porównaniu ze zwykłym przetwarzaniem. 

   ```
   int-array, for-loop : 0.36 ms
   int-array, seq. stream: 5.35 ms
   ```

2. Trudniejsze debugowanie

3. Inny sposób zapisu co może być trudniejsze do interpretowania dla dla osoby która jest bardziej przyzwyczajona do stylu imperatywnego.

## Wydajność
Wydajność przetwarzania strumieniowego dobrze opisuje artykuł **How fast are the Java 8 streams**. Głównym celem przetwarzania za pomocą strumieni jest przetwarzanie szybciej niż prosta pętlą. Strumienie mają wprowadzić inny sposób przetwarzania danych, bardziej deklaratywny z możliwością łatwego przetwarzania równoległego, przekazywania tych strumieni itp.

Chociaż ciekawe są wyniki. Zwykłe przechodzenie po liście `ArrayList` w porównaniu do przetwarzania strumieniowego wypada znacznie lepiej.

```
int-array, for-loop : 0.36 ms
int-array, seq. stream: 5.35 ms
```

Ale już np. iterowanie przez iterator nie wypada aż tak dobrze w porównaniu do strumieni.

```
ArrayList, for-loop : 6.55 ms
ArrayList, seq. stream: 8.33 ms
```

Więc jeśli mowa o zwykłym iterowaniu po liście to nie ma sensu moim zdaniem wprowadzać strumieni ponieważ te na ogół będą wypada wolniej niż zwykły `for`. Ale jeśli w tej pętli wykonujemy wiele operacji mapowa, szukania, ograniczania itp. wtedy przetwarzanie za pomocą strumieni może uprościć zapis i nie koniecznie będzie wolniejsze niż przetwarzanie za pomocą pętli. 

# Programowanie reaktywne
## Wprowadzenie
Programowanie reaktywne to asynchroniczny paradygmat programowania polegający na przetwarzaniu strumieni danych i propagowaniu ich zmian. Podejście to nawiązuje do wzorca projektowego Observer i przyjmuje się koncepcja programowania reaktywnego wywodzi się właśnie z niego.

Dzięki takiemu rozwiązaniu możemy tworzyć wydajne i skalowane systemy.

Programowanie reaktywne (reactive programming) polega na asynchronicznym, nieblokującym przetwarzaniu danych.

Wykorzystując to podejście operujemy na zdarzeniach *(events)*, będące przekazywane pomiędzy:

- *Publisher* – odpowiada za publikowanie
- *Subscriber* – nasłuchuje i odczytuje dane

Całość działa na zasadzie subskrypcji, gdzie *Subscriber* nasłuchuje zdarzeń wybranego *Publisher’a*. Jeśli porcja danych zostanie wyemitowana, to *Subscriber* od razu pozyska te dane.

![Komunikacja zachodząca pomiędzy Publisher a Subscriber](../../../.files/backpressure-publisher-subscriber.jpg)

Subscriber z wykorzystaniem zdarzeń, również może przekazywać informacje do Publishera. Interfejs wymiany informacji od Subscriber‚a w stronę Publisher‚a jest nazywany BackPressure. Dzięki niemu Publisher może otrzymywać feedback między innymi zawierający takie informacje jak:

ograniczenie informacji otrzymywanych od Puhlisher’a, w przypadku kiedy Subscriber nie nadąża przetwarzać otrzymywanych paczek;
błędów dotyczących przetwarzania danych, które mogą przerwać proces strumienia.
Należy pamiętać, że komunikacja od Publisher’a do Subscriber’a jest ciągła i trwa tak długo jak aktywna jest subskrypcja. W przypadku BackPressure komunikacja zachodzi na żądanie (on demand), czyli wtedy kiedy jest to niezbędne.

Przykładowo rozpatrzmy REST API napisane w modelu reaktywnym. Jego zadaniem jest pobranie danych z bazy, a następnie udostępnienie ich. Taka usługa będzie klasycznym przypadkiem *Publisher*‚a, natomiast klient pobierający dane z tego API stanowić będzie *Subscriber*‚a

Jednak, aby aplikacja w pełni spełniała koncepcje programowania reaktywnego to muszą zostać uwzględnione dodatkowe założenia:

- Asynchroniczność
  - zdarzenia przetwarzane są asynchronicznie
  - inna funkcjonalność odpowiada za wywołanie zdarzenia
  - inna funkcjonalność kiedy emitowany jest błąd
- Non Blocking
  - jeden wątek przyjmuje żądanie i deleguje je dalej, po czym nasłuchuje kolejnych żądań

Dla kontrastu w przypadku klasycznego, blokującego podejścia – jeden wątek obsługuje żądanie po czym czeka, aż dostanie odpowiedź (np.) z bazy danych (chodź równie dobrze przykładem może być pobieranie danych z sieci, z dysku). Dopiero jak dostanie on odpowiedź z bazy danych to może wrócić do klienta. Zwróć uwagę – wątek musi (bezczynnie) czekać aż baza danych przetworzy żądanie, dopiero wątek potem wraca do klienta. Na ten czas jest on zamrożony (nieużywalny).

![img](../../../.files/komunikacja-blokujaca.jpg)

W podejściu nieblokującym jeden wątek odpowiada za obsługę żądania i kiedy żądanie się pojawi wówczas deleguję on obsługę do dedykowanej puli wątków (np odpowiadającą za pobieranie danych z bazy) a sam jest gotowy działać dalej – nie czeka. Dzięki mechanizmowi callbacków (odpowiedziom na zdarzenie) wątek delegujący żądanie dowiaduje się o jego ukończeniu i przekazuje odpowiedź do *Subscriber*‚a.

![Komunikacja nieblokująca - non blocking io](../../../.files/komunikacja-noblocking.jpg)

Więc przewagą programowania reaktywnego jest optymalne wykorzystanie działanie wątków, bez oczekiwania jak jest to w przypadku podejścia klasycznego.
## Kiedy stosować programowanie reaktywne
Rozwiązania reaktywne mają znacznie bardziej większą złożoność od rozwiązań klasycznych. Rozwiązania blokujące mogą nieefektywnie zarządzać pulą wątków, ale problemem występuje dopiero kiedy danemu serwerowi skończy się pula dostępnych wątków.

Dla przykładu Apache Tomcat domyślnie dysponuje 200 wątkami. Po przekroczeniu tej puli zaczyna się problem – ponieważ kolejny requesty będą musiały oczekiwać na obsłużenie.

Jednak przetwarzanie 200 żądań w tym samym czasie jeszcze nie jest powodem do zmiany stosu na reaktywny. W pierwszej kolejności należy optymalizować czas obsługi żądania, tak, aby zwiększyć współczynnik RPS (Requests per second) czyli ilość obsłużonych żądań na sekundę. Im ten współczynnik mamy większy tym bardziej zaoszczędzoną mamy pulę wątków.

Dlatego programowanie reaktywne praktykuje się w dużych lub perspektywiczni dużych projektach, natomiast porównanie wydajności stosów można osiągnąć poprzez realizacje testów
# Kolekcje

[//]: (collections)

Jest to podstawowe API w Javie do operacji na różnego rodzaju zbiorach obiektów. Podstawowym interfejsem reprezentującym kolekcje jest `java.util.Collection`. Definiuje on dowolnego typu kolekcje. Interfejs definiuje takie metody jak `size()`, `iterator()`, `add()`, `remove()`, `clear()`, służą one do podstawowych operacji na listach.

W tamach API zdefiniowane są następujące szczegółowe interfejsy:  `java.util.List`, `java.util.Set`, `java.util.Queue` i `java.util.Map`. 

**Interfejs Map jest częścią API, ale nie dziedziczy po Collection !**

![image-20210408235119938](../.files/image-20210408235119938.png)

Ciekawy jest interfejs RandomAccess. Jest to interfejs znacznikowy określa kolekcje które udostępniają szybki swobodny dostęp.

W ramach Javy możemy wyróżnić Listy, Zbiory, Kolejki, Mapy.

| Typ   |                                                              |
| ----- | ------------------------------------------------------------ |
| List  | Definiuje listę elementów. Elementy mogą się powtarzać, mogą być posortowane. |
| Set   | Definiuje zbiór elementów. Każdy element w zbiorze występuje tylko w jednym egzemplarzu. Do określenia czy element istnieje w zbiorze wykorzystywany jest `hashCode` który grupuje elementy oraz `equals` który pozwala na pobranie elementu. |
| Queue | Definiuje kolejkę. Cechuje się ona tym, że elementy są dynamicznie dodawane i pobierane. Są to takie struktury jak Stos, FIFO, LIFO, kolejka priorytetowa. |
| Map   | Czyli tgz. klucz-wartość. Elementy pobierane są na podstawie klucza. |
## Implementacje
Java udostępnia różne implementacje kolekcji. Możemy je podzielić na **List, Set, Map, Queue**. W zasadzie w ramach każdego typu kolekcji mamy implementacje oparte na trzech różnych strukturach.

| Struktura                 | Opis                                                         |
| ------------------------- | ------------------------------------------------------------ |
| prosta lista              | Na ogół implementacje na liście cechują się szybkim dostępem do poszczególnych elementów ale dość słabo wypadają gdy chcemy ją modyfikować. |
| tabela hashy              | Umożliwia szybki dostęp do obiektów `O(1)`, ale elementy listy nie są posortowane. Przykładowa implementacja to HashSet, HashMap. |
| struktura listy połączone | Implementacje oparte na listach kierunkowych łączonych cechują się szybką możliwością modyfikacji elementów ale wolniejszym dostępem do pojedynczych elementów. Przykładowe implementacje to LinkedHashMap, LinkedHashSet |
| struktura drzewa          | Umożliwia szybki dostęp do elementu `O(log(n))`  , wyszukiwania elementów. Zachowuje kolejność elementu, ale do gorzej wypada przy dodawaniu elementu ponieważ wymagane jest przesortowanie całej struktury. Do poprawnego działania wymagany jest komparator. Są to np. TreeSet, TreeMap. |

Podstawowe implementacje.

| Implementacja | Opis                                                         |
| ------------- | ------------------------------------------------------------ |
| ArrayList     | Implementacja oparta jest na prostej liście. Cechuje się szybkim dostęp do konkretnych elementów listy. Natomiast dość słabo wypada przy modyfikacji. Wynika to stąd, że wymaga zmiana listy wymaga modyfikacji całej listy. |
| LinkedList    | Implementacja oparta jest na liście połączonych elementów `next, previous`. Dobrze sprawdza się przy modyfikacji. Natomiast gorzej przy pobieraniu elementu po indeksie ze względu na to, że wymaga przechodzenia po całej liście w celu znalezienia elementu. |
| HashSet       | Implementacja zbioru. Każdy elementy może występować tylko raz. Wykorzystywana jest metoda `hashCode` do wstępnego grupowania elementów. Następnie metoda `equals` do znalezienia konkretnego elementu. kolejność elementów nie jest zachowana. Warto jest korzystać z tej implementacji jeśli kolejność nie ma dla nas znaczenia. |
| LinkedHashSet | Zbiór oparty na liście połączonej.                           |
| TreeSet       | W przypadku HashSet kolejność elementów nie ma znaczenia. Czyli tego zbioru możemy użyć gdy kolejność w trakcie iteracji nie ma dla nas znaczenia. Znowu TreeSet oparte jest na strukturze drzewa. Do poprawnego jej działania potrzeba jest poprawna implementacja komparatora. |
| ArrayDeque    | Implementacja kolejki. Implementacja oparta na liście.       |
| PriorityQueue | Kolejka gdzie każdy element ma swój priorytet. **Elementy są posortowane za pomocą komparatora**. np. usunięcie elementu powoduje usunięcie elementu o najmniejszej wartości. |
| HashMap       | Mapa oparta na hashu. Kolejność jest niezachowana.           |
| TreeMap       | Wartości kluczy są uporządkowane w strukturze drzewa. Kolejność jest zachowana zachowana. Ważne jest aby klucz dostarczał metody komparatora. |
| LinkedHashMap | Wartości kluczy są uporządkowane w strukturze połączonej listy. Kolejność zachowana. |
### Kolejka
Podstawowa specyfikacja jest opisana w interfejsie `java.util.Queue`. Dostarcza ona podstawowe metody.

```java
boolean add(E var1);
boolean offer(E var1);
E remove();
E poll();
E element();
E peek();
```

Inna specyfikacją kolejki, która rozszerza tą podstawową jest `java.util.Deque`. Jest specyfikacja dwukierunkowej kolejki. Przykładową implementacją jest `java.util.ArrayDeque`. Implementacja jest oparta na zwykłej tablicy. Metoda `addLast` wygląda następująco.

```java
public void addLast(E var1) {
    if (var1 == null) {
        throw new NullPointerException();
    } else {
        this.elements[this.tail] = var1;
        if ((this.tail = this.tail + 1 & this.elements.length - 1) == this.head) {
            this.doubleCapacity();
        }

    }
}
```
### EnumSet i EnumMap

[//]: (enum-set-and-enum-map)

Są to dwie implementacje dostosowane do przechowywania słowników. Ze względu na to, że słownik ma określoną długość to implementacja opiera się na liście bitów. Jeśli dany element jest na liście to odpowiadający pit jest zaznaczony. Poniżej fragment implementacji dodawania nowego elementu. **Zwróć uwagę**, że mamy przesunięcie bitowe.

```java
public boolean add(E e) {
    typeCheck(e);

    long oldElements = elements;
    elements |= (1L << ((Enum<?>)e).ordinal());
    return elements != oldElements;
}
```

Są dwie implementacje EnumSet.

|                |                                                              |
| -------------- | ------------------------------------------------------------ |
| RegularEnumSet | Opiera się na jednej wartości `long` do przechowywania. Jeśli liczba wartości jest mniejsza od 64. |
| JumboEnumSet   | Opera się na liście wartość `long`.                          |

EnumMap jest implementacją zoptymalizowaną pod kątem Mapy gdzie kluczem jest typ wyliczany. Podobnie jak w przypadku EnumSet zarządzanie kluczami oparte jest na `longu` i operacjach na maskach.
### IdentityHashMap
Jest to specjalna implementacja mapy która korzysta z funkcji `hashCode` do grupowania obiektów ale do porównania korzysta z **operatora `==` a nie metody `equals`**. Taka specjalna mapa przydaje się np. w różnych algorytmach gdzie np. możemy mieć wiele wystąpień tego samego elementu w strukturze i chcemy je wszystkie przechowywać.

Jeśli korzystamy z podstawowych implementacji `equals` i `hashCode`  to jest to samo w pewnym sensie dlatego, że podstawowa implementacja `equals` korzysta z operatora `==`.

```java
// java.lang.Object#equals
public boolean equals(Object obj) {
    return (this == obj);
}
```
## Iterator
Jest to obiekt który dostarcza mechanizmy do przeglądania listy. W różnych językach programowania jest zaprojektowane na różne sposoby. W Javie podstawowym interfejsem `java.lang.Iterable` definiuje on między innymi metodę `iterator`. 

```java
Iterator<T> iterator()
```

Powinna ona zwracać obiekt klasy `java.util.Iterator` który definiuje takie metody jak `hasNext, remove, next`.  Te metody są wykorzystywane do iterowania po liście.

**ListIterator**

------

Klasa `java.util.ListIterator` jest rozszerzoną wersją zwykłego iteratora. Definiuje kilka dodatkowych metod za pomoca których możliwe jest modyfikowanie list w trakcie poruszania się, możliwość odwoływania się do poprzedniego elementy itp. `hasPrevious, previous, nextIndex, previousIndex, set, add`.

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

ListIterator<Integer> listIterator = list.listIterator();

while(listIterator.hasNext()) {
    listIterator.add(10);

    Integer v = listIterator.next();
}

System.out.println(list);
```

**ConcurrentModificationException**

------

W kontekście iteratorów może wystąpić takiego typu wyjątek gdy jeden iterator zmodyfikuje listę gdy inny jeszcze iteruje. Dzieje się tak dlatego, że iterator zapamiętuje operację jakie zostały wykonane.
## Widoki i lekkie listy
Są to to takie mechanizmy jak `Arrays.asList` które tworzą niezmienna listę zoptymalizowaną pod kątem pamięci.

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
```

Tworzona instancja jest typu `java.util.Arrays.ArrayList` ma taką samą nazwę jak `java.util.ArrayList` co może być mylące. Ale są to całkowicie różne typy. 

**Widoki niezmienne**

------

Jest to zbiór metoda za pomoca których możemy utworzyć kolekcje które są niezmienne. Jest to lista metod `Collections.unmodifiable...` dla każdego typu kolekcji.

```
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 10));

List<Integer> unmodifiableList = Collections.unmodifiableList(list);

unmodifiableList.add(20);// UnsupportedOperationException
```

Mechanizm jest realizowany przez wzorzec dekoratora tzn. bazowy obiekt jest owrapowany obiektem który dla każdej metody która próbuje zmodyfikować obiekt wyrzuca wyjątek.

**Widoki synchroniczne**

------

Podobnie jak niezmienne możliwe jest tworzenie widoków synchronicznych. Jest to grupa metod `Collections.synchronized...` które tworzą obiektu dla których wszystkie metody są synchroniczne.

To rozwiązanie jest podobne do Vector ale **blokada jest nałożona na tgz. mutex a w przypadku Vectora na cały obiekt.**

```java
// SynchronizedList
public E get(int index) {
	synchronized (mutex) {return list.get(index);}
}

// Vector
public synchronized E get(int index) {
    if (index >= elementCount)
    throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
```

Z punktu widzenia wydajności może mieć to znaczenia.

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 10));
List<Integer> synchronizedList = Collections.synchronizedList(list);
```

**Widoki kontrolowane**

------

Podobnie jak niezmienne i synchroniczne jest to widok który dostarcza mechanizmy do sprawdzenia czy dodawany mechanizm jest określonego typu. Wynika to trochę stąd, że możliwa jest taka sytuacja, że do listy wartości typu `Integer` dodajemy inny element. Co prawda IDEA i kompilator poinformuje ostrzeżeniem o tym, ale kod się skompiluje.

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 10));

List p = list;
p.add(new Date());
```

Dlatego powstały widoki kolekcji kontrolowanych, które w trakcie dodawania widoku sprawdzają czy obiekt jest określonego typu. Jest to mechanizm bardziej pod kątem kompatybilności wstecznej.

```
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 10));
List p = Collections.checkedList(list, Integer.class);
p.add(new Date());
```

Metoda sprawdzająca typ wygląda następująco.

```java
E typeCheck(Object o) {
    if (o != null && !type.isInstance(o))
        throw new ClassCastException(badElementMsg(o));
    return (E) o;
}
​```## Optymalizacja
W zależności od implementacji każda ma swoje plusy i minusy. Poniżej częściowa lista złożoności operacji na listach. (**TODO** do dokończenia )
## Summary
Let's summarize the whole discussion in the below table.

| Operacja                | **LinkedList time complexity** | **ArrayList time complexity**                         | **Preferred** |
| ----------------------- | ------------------------------ | ----------------------------------------------------- | ------------- |
| Dodanie na koniec listy | O(1)                           | O(1)(If array copy operation is Considered then O(N)) | LinkedList    |
| Insert at given index   | O(N)                           | O(N)                                                  | LinkedList    |
| Search by value         | O(N)                           | O(N)                                                  | ArrayList     |
| Get by index            | O(N)                           | O(1)                                                  | ArrayList     |
| Remove by value         | O(N)                           | O(N)                                                  | LinkedList    |
| Remove by index         | O(N)                           | O(N)                                                  | LinkedList    |

## Pozostałe
### Przedziały
Jest to mechanizm za pomocą którego możemy pobrać cześć listy przez podanie zakresu. Ważne jest to, że wybrany przedział jest połączony z bazową listą co oznacza, że jeśli będziemy zmieniać podzbiór to będzie również to wpływać na główną listę.

​```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
List<Integer> sub1 = list.subList(2, 4);

// Dodanie do przedziały i do listy bazowe
sub1.add(10);
sub1.add(20);

System.out.println(format("A.list: %s", list)); System.out.println(format("A.sub1: %s", sub1));

sub1.removeIf(v -> v == 20);

System.out.println(format("B.list: %s", list)); System.out.println(format("B.sub1: %s", sub1));

// Usunięcie
sub1.clear();

System.out.println(format("C.list: %s", list)); System.out.println(format("C.sub1: %s", sub1));
```

Wynik.

```
A.list: [1, 2, 3, 4, 10, 20, 5]
A.sub1: [3, 4, 10, 20]
B.list: [1, 2, 3, 4, 10, 5]
B.sub1: [3, 4, 10]
C.list: [1, 2, 5]
C.sub1: []
​```### Funkcje tworzące
Od Javy 9 dostępna jest lista funkcji statycznych za pomocą których można w szybki sposób utworzyć różne obiekty kolekcji. Na ogół zaczynają się one of wyrażenia `of...`

​```java
List<String> band = List.of("Bruce","Steve","Adrian", "Dave", "Janick");

Set<String> band = Set.of("Bruce","Steve","Adrian", "Dave", "Janick","Nicko");

Map<String, Long> age = Map.of("Bruce", 59L, "Bruce", 59L);
Map<String, Long> age = Map.ofEntries(Map.entry("Bruce", 59L), Map.entry("Bruce", 59L));
Map<String, Long> age = Map.of("Bruce", 59L, "Steve", 61L, "Dave", 60L, "Adrian", 60L, "Janick", 60L, "Nicko", 65L);
```
### Wartość inicjalna ArrayList
ArrayList pozwala na zdefiniowanie inicjalnej wielkości listy przez parametr.

```java
ArrayList<Integer> arrayList = new ArrayList<>(100);

// Jeśli jest nie podane to 10
ArrayList<Integer> arrayList = new ArrayList<>();
```

Inicjalna wielkość listy ma dość spory wpływ na wydajność. Można przyjąć tu dwa warianty:

1. Jeśli parametr będzie za duży w stosunku do ilości danych to czas potrzebny na zainicjowanie listy będzie większy niż jest to potrzebne.
2. Jeśli parametr będzie za mały to w trakcie dodawania elementów wymagana będzie operacja kopiowania wewnętrznej listy co wymaga czasu.

Optymalnym wariantem jest podanie takiej wielkości inicjalnej listy jaka będzie nam potrzebna. Co powoduje, że zaalokujemy tylko tyle pamięci ile jest wymagane i jednocześnie nie dojdzie do kopiowania listy. Dość dobrze zostało to opisane w artykule **Performance Evaluation of Java ArrayLists**.
### HashMap `computeIfAbsent, putIfAbsent, computeIfPresent, getOrDefault `
Jest to zbiór metod usprawniający pobieranie wartości z mapy. Główna korzyść jest taka, że nie musimy sprawdzać czy wartość istnieje.

```java
private BigInteger fibonacci(int n) {
    return memoizeHashMap.computeIfAbsent(n, (key) -> fibonacci(n - 1).add(fibonacci(n - 2)));
}

productPrice.putIfAbsent("Fish", 4.5);
map.computeIfPresent(word, (String key, Integer value) -> ++value);
productPriceMap.getOrDefault("Fish", 29.4);
```
### Pozostałe implementacje
| Implementacja | Opis                                                         |
| ------------- | ------------------------------------------------------------ |
| Hashtable     | Jest to poprzednia wersja HashMap. Podobnie jak Vector jest w pełni synchroniczna. W przypadku programów wielowątkowych zalecane jest ConcurrentHashMap. |
| Enumeration   | Poprzednia implementacja Iteratora.                          |
| Properties    |                                                              |
| Stack         |                                                              |
| BitSet        |                                                              |
### Wyszukiwanie binarne
Kolekcje dostarczają wyszukiwanie binarne `java.util.Collections#binarySearch`. Wymaga ono aby dane w pierwszej kolejności zostały posortowane a następnie podanie komparatora.

```java
List<Integer> list = new ArrayList<>(Arrays.asList(23, 1, 304, 123, 45, 23, 123, 598, 234, 120));

list.sort(Integer::compareTo);

int i = Collections.binarySearch(list, 45);// 3
```
### Wyjątek ConcurrentModificationException
Wyjątek się pojawia w momencie gdy przechodzimy po liście w w środku listy usuwamy element. 

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

for(Integer v: list) {
    System.out.println(v);

    if (v == 3) {
        list.remove(v);// ERROR
    }
}
```

Wynika to między innymi stąd, że w trakcie iterowania po kolekcji przez iterator który jest tworzony w kontekście pętli `for` zapisuje on sobie wielkości listy. W przypadku typu ArrayList jest implementacja iteratora to `java.util.ArrayList.Itr`. Zwróć uwagę na oznaczone miejsca.

```java
private class Itr implements Iterator<E> {
    // ...
    int expectedModCount;

    Itr() {
        // Pobranie wartości w momencie inicjacji iterator
        this.expectedModCount = ArrayList.this.modCount;
    }

    // ...
    public E next() {
        // Sprawdzamy czy wartości są spójne
        this.checkForComodification();
		// ...
    }

    public void remove() {
				// ...
       			// Przy usuwaniu wartość jest aktualizowana dlatego możliwe jest usunięcie 
        		// elementu przez iterator.
                this.expectedModCount = ArrayList.this.modCount;
            } catch (IndexOutOfBoundsException var2) {
                throw new ConcurrentModificationException();
            }
        }
    }

	// ...
    final void checkForComodification() {
        if (ArrayList.this.modCount != this.expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }
}
```

Do usunięcia obiektu z listy możemy użyć metody `remove` w iteratorze. Tylko trzeba pamiętać aby użyć przed usunięciem metody `next`  bo dopiera wykonanie tej metody ustawia wewnętrzny wskaźnik na element który ma zostać usunięty. Nie usunięcie tej metody spowoduje wyjątek `IllegalStateException`.

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

Iterator<Integer> iterator = list.iterator();

while(iterator.hasNext()) {
    iterator.next();
    iterator.remove();
}
```

Możemy użyć `removeAll` .

```java

// Usunięcie po wyjściu z pętli
List<Integer> integers = newArrayList(1, 2, 3);
List<Integer> toRemove = newArrayList();

// ...
integers.removeAll(toRemove);
```

Możemy również użyć metodę `removeIf`.

```java
// Metoda removeIf
List<Integer> integers = newArrayList(1, 2, 3);
 
integers.removeIf(i -> i == 2);
```
### Implementacje `Weak...`
Podobnie jak w JavaScripcie Java udostępnia taką implementację jak WeakHashMap. Podobnie jak w Js działa ona w taki sposób, że jeśli referencja do klucza nie jest już wykorzystywana w innymi miejscu to Garbage Collector może usunąć element pod tym kluczem i klucz **Oparte jest to na mechanizmie WeakReference**.
### Różnica między Enumeration i Iterator
Enumeration i Iterator to dwa interfejsy w pakiecie `java.util`, które służą do przechodzenia między elementami obiektu Collection. Chociaż pełnią tę samą funkcję, tj. Przemierzają obiekt Collection, istnieją między nimi pewne różnice.

Korzystając z wyliczenia, można tylko przechodzić przez obiekt Collection. Ale za pomocą Iteratora możesz również usunąć element podczas przechodzenia przez kolekcję. Jest to jedna główna różnica między wyliczaniem a iteratorem w Javie. Można powiedzieć, że Iterator jest zaawansowaną wersją wyliczania. W tym poście zobaczymy różnice między Enumeration Vs Iterator In Java.

| **Iterator** | **Enumeration**   |
| ------------ | ----------------- |
| hasNext()    | hasMoreElements() |
| next()       | nextElement()     |
| remove()     | (Not Available)   |

| **Enumeration**                                              | **Iterator**                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Using *Enumeration*, you can only traverse the collection. You can’t do any modifications to collection while traversing it. | Using *Iterator*, you can remove an element of the collection while traversing it. |
| *Enumeration* is introduced in JDK 1.0                       | *Iterator* is introduced from JDK 1.2                        |
| *Enumeration* is used to traverse the legacy classes like *Vector*, *Stack* and *HashTable*. | *Iterator* is used to iterate most of the classes in the collection framework like *ArrayList*, *HashSet*, *HashMap*, *LinkedList* etc. |
| Methods : *hasMoreElements()* and *nextElement()*            | Methods : *hasNext()*, *next()* and *remove()*               |
| *Enumeration* is fail-safe in nature.                        | *Iterator* is fail-fast in nature.                           |
| *Enumeration* is not safe and secured due to it’s fail-safe nature. | *Iterator* is safer and secured than *Enumeration*.          |
### ArrayList i Vector
Są to dwie implementację listy. Vector jest starszą implementacją i w poprzednich wersjach była głównie wykorzystywany jako dynamiczna lista. ArrayList jest nowszą implementacją.

Główną różnica między Vector a ArrayList jest taka, że Vector jest synchroniczny każda metoda jest synchroniczna. Ta cecha wydajnościowo jest określana jako minus dlatego, że wywołanie każdej metody wymaga obsługi bloku synchronicznego. **W przypadku aplikacji jednowątkowych jest to niepotrzebny narzut.** ArrayList nie jest synchroniczny. Więc w przypadku aplikacji jednowątkowej będzie wydajniejsze. 

Vector jako poprzednia implementacja dostarcza dwa mechanizmy iteracji przez Iterator i Enumeration. Natomiast ArrayList dostarcza tylko iterator.
### Hermetyczna lista
Poniżej przykład obsługi pola listy w taki sposób aby ta lista była ukryta za metodami.

```java
public class MyClass {

    private final List<String> myStrings = new ArrayList<>();

    public void setMyStrings(Collection<String> s) {
        this.myStrings.clear(); 
        if (s != null) { 
            this.myStrings.addAll(s); 
        } 
    }

    public List<String> getMyStrings() {
        return new ArrayList<>(this.myStrings);
    }

    public void addString(String s) { 
        this.myStrings.add(s); 
    }

    public void removeString(String s) { 
        this.myStrings.remove(s); 
    }

    // And maybe a few more helpful methods...
}
```
# Programowanie funkcjonalne

## Wyrażenia `lambda`

Wyrażenia `lambda` to sposób na wykonywanie fragmentów kodu w różnych kontekstach. W Javie tego typu wyrażenia są oparte na interfejsach funkcyjnych. Są to interfejsy które mają tylko jedno metodę.

W innych językach takich jak JavaScript wyrażenia lambda są realizowane za pomocą funkcji. W języku PHP podobnie.

W wielu przypadkach wyrażenia lambda mogą zastąpić klasy anonimowe (o ile taka klasa ma tylko jedną metodę.)

Wyrażenie lambda ma następującą składnię.

```java
<lista parametrów> -> <ciało wyrażenia>
```

Przykład, typy parametrów są opcjonalne.

```java
(Integer x, Long y) -> System.out.println(x * y)
```

Lub gdy zawiera więcej linii.

```java
(Integer x) -> {
    if (x != null && x % 2 == 0) {
        return (long) x * x;
    }
    else {
        return 123L;
    }
}
```

Wyrażenia `lambda` oparte są na **interfejsach funkcyjnych**.

Interfejsy funkcyjny to taki które zawiera jedną metodę abstrakcyjną. W zasadzie każdy taki interejs może być interfejsem funkcyjnym.

```java
@FunctionalInterface
interface Counter<E> {
    int count(E name, int a, int b);
}
```

Na podstawie takiego interfejsu możemy:

- stworzyć klasę anonimową,
- stworzyć wyrazenie `lambda`.

Klasa anonimowa wyglądała by tak:

```java
Counter<String> c = new Counter<String>() {
    @Override
    public int count(String name, int a, int b) {
        System.out.println("Obliczam " + name);

        return a + b;
    }
};

System.out.println(c.count("Suma", 10, 20));
```

Przed wyrażeniami `lambda` klasy anonimowe były jednym ze sposobów przekazywania np. callbacków lub akcji które maja się wykonać po określonym zdarzeniu.

Wyrażenie `lambda` miała by taką postać.

```java
Counter<String> c2 = (String name, int a, int b) -> {
    System.out.println("Obliczam " + name);

    return a + b;
};

System.out.println(c2.count("Suma", 10, 20));
```

Możemy je zapisać rownież:

```java
Counter<String> c2 = (String name, int a, int b) -> a + b;
```

Twórcy języka Java przygotowali zestaw interfejsów funkcyjnych, które możesz implementować. W większości przypadków w zupełności wystarczy ich użycie. Część z nich znajduje się w pakiecie [`java.util.function`](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html). Najważniejsze z nich zebrałem poniżej:

- `Function<T, R>` zawiera metodę `apply`, która przyjmuje instancję klasy `T` zwracając instancję klasy `R`,
- `Consumer<T>` zawiera metodę `accept`, która przyjmuje instancję klasy `T`,
- `Predicate<T>` zawiera metodę `test`, która przyjmuje instancję klasy T i zwraca flagę. Interfejs ten może posłużyć do zastąpienia interfejsu `Checker`,
- `Supplier<T>` zawiera metodę `get`, która nie przyjmuje żadnych parametrów i zwraca instancję klasy `T`,
- `UnaryOperator<T>` jest specyficznym przypadkiem interfejsu `Function`. W tym przypadku typ argumentu i typ zwracany są te same.

Inny przykład tworzący wątek.

```java
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.print("Run method");
    }
};

// lub
Runnable r = ()-> System.out.print("Run method");
​```## Podstawowe interfejsy funkcyjne
- Function
  To represent a function that takes an argument of type T and returns a result of type R.
- BiFunction
  To represent a function that takes two arguments of types T and U, and returns a result of type R.

- Predicate
  To represent a boolean function that returns true or false for the specified argument.

- BiPredicate
  To represent a boolean function that returns true or false for the two specified arguments.

- Consumer
  To represent an operation that takes an argument and returns no result.

- BiConsumer
  To represent an operation that takes two arguments and returns no result.

- Supplier
  To represent a function that returns a value as of type T.

- UnaryOperator
  To represent a function that takes an argument and returns a result of the same type.

- BinaryOperator
  To represent a function that takes two arguments and returns a result of the same type.
## Odwoływanie się do metod
Wraz z wyrażeniami lambda Java została rozbudowana o składnię pozwalającą na odwoływanie się do metod. Służy do tego `::`.  Dzięki temu wyrażeniu możemy przypisać metodę do zmiennej bez jej wywołania. Takie podejście pozwala na przekazanie tak wyłuskanej metody i wywołanie jej w zupełnie innym miejscu. Proszę spójrz na przykład poniżej:

​```java
Car carA = new Car("A");
Car carB = new Car("B");

// http://www.java2s.com

// Interfejs Supplier dostarcza generyczny interfejs z metodą get()
Supplier<String> getNameA = carA::getName;
Supplier<String> getNameB = carB::getName;

System.out.println(getNameA.get());// A
System.out.println(getNameB.get());// B
```

Możemy również zapisac referencję i wywołac ja w innym kontekście.

```java
// Wywołanie samej funkcji w innym kontekście.
Function<Car, String> apply = Car::getName;

System.out.println(apply.apply(carA));
System.out.println(apply.apply(carB));
```
## Interfejs `Supplier`
Interfejs opisuje obiekt który reprezentuje wywołanie metody lub funkcji. Interfejs pozwala na przekazanie wywołania funkcji lub metody.

```java
Person person = new Person("A", 10);
Person personB = new Person("B", 20);

Supplier<Integer> a = person::getAge;

System.out.println("getAge: " + a.get());
```
## Interfejs `Function/BiFunction`
Jest to interfejs reprezentujący wywołanie funkcji na określonym obiekcie. `BiFunction` jest wywołaniem funkcji z dwoma parametrami.

```java
Person person = new Person("A", 10);
Person personB = new Person("B", 20);

BiFunction<Person, Person, Integer> sum = new BiFunction<Person, Person, Integer>() {
    @Override
    public Integer apply(Person person, Person person2) {
        return person.getAge() + person.getAge();
    }
};

System.out.println(caller.apply(person));
```
## Interfejs `Function.identity()`

Jest to funkcja która zwraca interfejs który opisuję zwrócenie tej samej wartości jaka jest przekazana przez parametr.

```java
Map<Long, RegionEntity> regionMap = regionService.getRegionList(regionIdList).stream()
    .collect(Collectors.toMap(RegionEntity::getId, Function.identity()));
```

## Wywołanie `::new`

Pozwala na odwołanie się do konstruktora obiektu obiektu. Dzięki temu możemy np. przekazać konkretne wywołanie do innego obiektu.

```java
Function<Integer, Person[]> personListCreator = Person[]::new;

Person[] list = personListCreator.apply(3);

list[0] = new Person("A", 10);
list[1] = new Person("B", 10);
list[2] = new Person("C", 10);

System.out.println(Arrays.asList(list));
```

W powyższym przykładzie tworzę listę korzystając z referencji do konstruktora takiej listy.
## Przekazanie konstruktora
W poniższym przykładzie przekazuje konstruktor.

```java
public static void main(String[] args) {
    // Przekazanie konstruktora
    List<? extends Person> persons = creator(new BiFunction<String, Integer, Person>() {
        @Override
        public Person apply(String s, Integer integer) {
            return new FooPerson(s, integer);
        }
    }, 10);

    System.out.println(persons);
}

private static List<? extends Person> creator(BiFunction<String, Integer, ? extends Person> personFactory, int number) {
    ArrayList<Person> persons = new ArrayList<>();

    for(int i=0; i<number; i++) {
        persons.add(personFactory.apply("A" + i, i + 20));
    }

    return persons;
}
```

# Spring

[//]: "spring"

![Znalezione obrazy dla zapytania spring java](../.files/1a5584bc-d708-46d9-a199-57a242bd0d13.gif)

Oficjalne repozytorium:

https://github.com/spring-projects/spring-framework
## Architektura
![image-20200614124414122](../../../.files/image-20200614124414122.png)

Spring opiera się na dość prostej koncepcji (moim zdaniem). Podstawą tej koncepcji są tgz. komponenty nazywane Beanami (ziarnami). Każdy Bean jest prostym obiektem typu POJO (w uproszczeniu). Komponenty są połączone relacjami. Komponenty wraz z relacjami są umieszczone w kontenerze SpringContainer.

![1574260085658](../../../.files/141594bc-d708-46d9-a199-57a142bd0d1e.png)

Jednym z podstawowych mechanizmów które dostarcza Spring jest **IoC **. Spring tworzy komponenty, zarządzania nimi oraz dostarcza zależności do tych komponentów - wykorzystuje do tego mechanizm DI (Dependence injection).

Struktura tego kontenera komponentów jest zdefiniowana przez konfiguracje która może być zapisana w formie pliku `xml` lub adnotacji na klasach.

![1574260693583](../../../.files/175584bc-d708-46d9-a199-57a142bd0d13.gif)

W ogólnym schemacie wygląda to tak jak zostało zdefiniowane powyżej. Metadane w formie plików konfiguracyjnych definiuje wszystkie komponenty. Komponenty wykorzystują klasy typu POJO.

Poniżej wykorzystałem `XmlBeanFactory` do tworzenia komponentów. `XmlBeanFactory` tworzy komponenty na podstawie definicji XML.

Poniżej mamy konfiguracje komponentów w pliku XML.

```xml
<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "userEntity" class = "com.learning.springbeans.model.UserEntity">
      <property name = "name" value = "Paweł"/>
   </bean>
</beans>
```

W aplikacji uruchamiamy nasz komponent.

```java
public class ComLearningSpringbeansApplication {
	public static void main(String[] args) {
		// SpringApplication.run(ComLearningSpringbeansApplication.class, args);

        XmlBeanFactory xmlBeanFactory = new XmlBeanFactory(new ClassPathResource("beans.xml"));

        ((UserEntity) xmlBeanFactory.getBean("userEntity")).helloWorl();
	}
}
```

Wynik działa:

```
Hello, I'm Paweł
```
### Kontekst `ApplicationContext`
`ApplicationContext` to centralny interfejs w aplikacji Spring służący do dostarczania aplikacji informacji konfiguracyjnych.

Implementuje interfejs `BeanFactory`. Stąd, `ApplicationContext` zawiera całą funkcjonalność `BeanFactory` i wiele więcej! Jego główną funkcją jest wspieranie tworzenia dużych aplikacji biznesowych.

Cechy:

- Tworzenie komponentów,
- Automatyczna rejestracja `BeanPostProcessor`,
- Automatyczna rejestracja `BeanFactoryPostProcessor`,
- Wygodny dostęp do źródła wiadomości (dla i18n), publikacja `ApplicationEvent`.

Podobnie jak w przypadku `BeanFactory` możemy taki kontekst zainicjować:

```java
public class ComLearningSpringbeansApplication {
	public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");

		((UserEntity) context.getBean("userEntity")).helloWorl();
	}
}
```

`ApplicationContext` obejmuje wszystkie funkcje `BeanFactory`. Ogólnie zaleca się stosowanie tego pierwszego. Istnieją pewne ograniczone sytuacje, na przykład w aplikacjach mobilnych, w których zużycie pamięci może być krytyczne. W takich sytuacjach uzasadnione byłoby użycie bardziej lekkiego `BeanFactory`. Jednak, w większości aplikacji dla przedsiębiorstw `ApplicationContext` jest tym, czego będziesz chciał użyć.

Taki kontekst aplikacji inicjuje Spring Boot. Spring Boot na podstawie adnotacji tworzy konfigurację.

Więc `UserEntity` musi zostać oznaczone adnotacją `@Component`.

```java
import org.springframework.stereotype.Component;

@Component
public class UserEntity {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        System.out.println("UserEntity.setName: " + name);

        this.name = name;
    }

    public void helloWorl() {
        System.out.println("Hello, I'm " + name);
    }
}
```

Wtedy taki kontekst aplikacji tworzymy:

```java
@SpringBootApplication
public class ComLearningSpringbeansApplication {
	public static void main(String[] args) {
		ApplicationContext context = SpringApplication.run(ComLearningSpringbeansApplication.class);

		((UserEntity) context.getBean("userEntity")).helloWorl();
	}
}
```

Trzeba pamiętać aby dodać adnotację `@SpringBootApplication`. Bez niej nie zostaną zarejestrowane komponenty.
## Inicjacja projektu - Maven
Spring Boot to projekt zbudowany na bazie frameworka Spring. Zapewnia prostszy i szybszy sposób konfigurowania i uruchamiania zarówno prostych, jak i złożonych aplikacji.

W ramach szkieletu Springa musisz skonfigurować wszystkie rzeczy. Dlatego możesz mieć wiele plików konfiguracyjnych, takich jak deskryptory XML. To jeden z głównych problemów, które rozwiązuje dla Ciebie SpringBoot.

Inteligentnie wybiera Twoje zależności, automatycznie konfiguruje wszystkie funkcje, których będziesz chciał używać i możesz uruchomić aplikację jednym kliknięciem. Ponadto upraszcza także proces wdrażania aplikacji.

Projekt można zainicjować za pomocą narzędzia https://start.spring.io. Wygeneruje on prosty projekt z zdefiniowanymi zależnościami.

Następnie instalujemy zależności zdefiniowane w `pom.xml`.

```shell
mvn install
```

I uruchamiamy aplikację z wiersza poleceń.

```
mvn spring-boot:run
```
## Konfiguracja
Spring udostępnia kilka metod konfiguracji:

- za pomocą pliku XML,
- za pomocą klas (Java base configuration),
- za pomocą Groovy DSL.

Konfiguracja może być zapisana jednocześnie na kilka sposobów, wszystkie konfiguracje zostaną zaczytane z Spring Context.
### Stereotypy
Jest to grupa charakterystyk definiująca określone rzeczy.  W Springu mamy cztery podstawowe stereotypy.

![Znalezione obrazy dla zapytania spring stereotypes](../../../.files/1a5594bc-d708-26d9-a199-57a112bd0d1d.gif)

Za pomocą stereotypów wskazujemy jakiego typu są to elementy.

Podstawową adnotacją jest adnotacja `@Component`, rozszerzają ją `@Controller, @Service, @Repository`. Poszczególne rozszerzenia pozwalają dokładniejsze zdefiniowanie w jakiej warstwie zostanie umieszczony komponent i w jaki sposób Spring będzie go traktował. np. adnotacja `@Repository` spowoduje, że wyjątki wyrzucane będą przekształcane na ogólne wyjątki Springa albo adnotacja `@Controller` spowoduje, że komponent zostanie dodatkowo przeskanowany w poszukiwaniu dodatkowych adnotacji `@GetMapping, @RequestMapping ...`.

**Podstawowym zadaniem stereotypów jest wyrażenie celu (intencji) komponentu.**

### Automatyczna konfiguracja
Mechanizm polega na tym, że Spring Boot skanuje wszystkie pakiety w poszukiwaniu klas oznaczonych odpowiednimi adnotacjami.

Opcja automatycznego skanowania jest uruchomiona w momencie ustawienia adnotacji `@EnableAutoConfiguration`. Wtedy zostaje przeszukane wszystkie klasy z classpath.

Adnotacja `@SpringBootApplication` zawiera w sobie `@EnableAutoConfiguration` dzięki czemu nie ma potrzeby definiowania takiej adnotacji.

Adnotacja `@EnableAutoConfiguration` udostępnia parametr za pomocą które możliwe jest wykluczenie.`
### Skanowanie komponentów
jedną z podstawowych operacji które wykonuje Spring jest skanowanie w poszukiwaniu komponentów. W podstawowej konfiguracji Spring skanuje pakiety w który znajduje klasa oznaczona adnotacją `@SpringBootApplication`.

Jeśli mamy klasę:

```java
package comjgexampleA;

@SpringBootApplication
public class ComJgExampleAApplication {
	public static void main(String[] args) {
		SpringApplication.run(ComJgExampleAApplication.class, args);
	}
}
```

To skanowane będą wszystkie pakiety będące w `comjgexampleA`.

Przez adnotację `@ComponentScan` możemy zdefiniowanie dodatkowe pakiety które maja zostać przeskanowane w poszukiwaniu pakietów.

Jeśli chcemy skanować inne pakiety:

```java
@ComponentScan(basePackages = "com.baeldung.componentscan.springapp.animals")
@Configuration
public class SpringComponentScanApp {
   // ...
}
```

Pominięcie określonych komponentów.

```java
@ComponentScan(excludeFilters =
@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = Rose.class))
```
### Konfiguracja za pomocą Javy
Spring umożliwia definiowanie konfiguracji za pomocą plików Java. Klasa musi być oznaczona adnotacją `@Configuration`. Takie klasy są skanowane przez Spring Boota.
#### Definiowanie komponentu `@Bean`
Adnotacja `@Bean` pozwala na zdefiniowanie komponentu na poziomie konfiguracji.

```java
@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
```

Metoda `transferService` jest oznaczona adnotacją. Spowoduje to, że zwrócona wartość zostanie zapisana jako komponent który można wykorzystać jako zależność.

Adnotacja jest jednoznaczna z:

```xml
<beans>
    <bean name="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
```

Adnotacja działa podobnie jak adnotacja `@Component` pozwala na zdefiniowanie Beana w kontekście aplikacji (`Application Context`).

Różnica jest taka, że adnotacja `@Component` możemy oznaczyć tylko klasy z własnego pakietu. Jeśli np. korzystamy z zewnętrznej biblioteki to nie mamy pewności które klasy są oznaczone adnotacją `@Component`, więc w takiej sytuacji w konfiguracji musimy zdefiniować metody które zainicjują nam komponenty z zewnętrznych bibliotek.

Poniżej jest przykład w którym definiuje komponent tworzony z klasy która zawiera się w zewnętrznej bibliotece.

```java
@Configuration
public class JokesConfiguration {

    @Bean
    public ChuckNorrisQuotes chuckNorrisQuotes() {
        return new ChuckNorrisQuotes();
    }
}
```

Klasa `ChuckNorrisQuotes` jest z zewnętrznej biblioteki nie jest oznaczona przez adnotację `@Component`.

**Ten mechanizm jest praktyczny gdy chcemy wykorzystać zewnętrzne biblioteki (jar).**

**Tutaj należy pamiętać również, że tworzenie komponentu mechanizm adnotacji `@Component`.**
### Konfiguracja XML
Spring umożliwia konfigurację komponentów za pomocą pliku XML. Plik z konfiguracją umieszczamy w katalogu `resources`.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
   <!-- bean definitions here -->
   <bean name="chuckNorrisQuotes" class="guru.springframework.norris.chuck.ChuckNorrisQuotes" />
   <bean id="textProcessor" class="pl.edu.usos.adm.textProcessor.TextProcessorImpl" scope="prototype">
      <constructor-arg ref="trescSymbolResolver" />
   </bean>
   <bean id="trescSymbolResolver" class="pl.edu.usos.adm.powiadomienia.resolvers.TrescSymbolResolver" scope="prototype">
      <constructor-arg ref="deklinacjaServices" />
   </bean>
   <bean id="deklinacjaServices" class="pl.edu.usos.adm.deklinacje.services.DeklinacjaServicesImpl">
      <constructor-arg ref="deklinacjaDao" />
   </bean>
   <bean id="resourcePropertiesLoader" class="pl.edu.usos.common.utils.ResourcePropertiesLoader">
      <property name="resourceFileNames">
         <list>
            <value>filterFields</value>
            <value>sortOrders</value>
            <value>filterExpressions</value>
            <value>validation</value>
         </list>
      </property>
   </bean>
       <bean id="birtService" class="pl.edu.usos.adm.birt.BirtServiceImpl">
           <property name="birtRaportAuthService">
           <value>#{birtRaportAuthServices}</value>
           </property>
           <property name="url" value="${birt.url}" />
           <property name="source" value="${birt.source}" />
           <property name="service" value="${birt.service}" />
           <property name="sourceParam" value="${birt.sourceParam}" />
           <property name="serviceParam" value="${birt.serviceParam}" />
           <property name="guidParam" value="${birt.guidParam}" />
           <property name="reportParam" value="${birt.reportParam}" />
           <property name="formatParam" value="${birt.formatParam}" />
           <property name="osIdParam" value="${birt.osIdParam}" />
           <property name="unicode" value="${birt.unicode}" />
           </bean>
</beans>
```

W konfiguracji może być zdefiniowanych wiele komponentów. W głównej klasie musimy wskazać aby plik konfiguracyjny został zaimportowany.

```java
@SpringBootApplication
@ImportResource("classpath:beans.xml")
public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
```
## Komponenty
Jest to podstawowy elementem systemu w Springu. Komponenty możemy oznaczać za pomocą adnotacji lub w konfiguracji XML. Duża część IoC opiera się właśnie na odpowiednim konfigurowaniu komponentów, odczytywaniu ich adnotacji i konfiguracji.
### Cykl życia
Zgodnie ze wzorce IoC Spring zarządzania komponentami. Ustawia je w odpowiedni stan.

![1574436044705](../../../.files/1a5594bc-d708-36d1-2199-57a142bd0d1a.gif)

Spring udostępnia wiele mechanizmów (interfejsy, adnotacja) za pomocą których możemy dodać do komponentu funkcjonalności. Na ogół interfejsy pełniące takie funkcję kończą się zwrotem `...Aware`.

| Interfejs/Adnotacja        | Opis                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `@BeanNameAware`           | Definiuje metodę `void setBeanName(String var1)`. Do metody jest przekazywana nazwa komponentu. |
| `@BeanFactoryAware`        | Definiuje metodę `void setBeanFactory(BeanFactory var1) throws BeansException`. Do metody jest przekazywany `BeanFactory`, za pomocą niego możemy odwołać się do innych beanów. |
| `@ApplicationContextAware` | Definiuje metodę `void setApplicationContext(ApplicationContext var1) throws BeansException`. Do metody jest przekazywany `ApplicationContext` |
| `@InitializingBean`        | Definiuje metodę `void afterPropertiesSet() throws Exception`. Metoda jest wywoływana po ustawieniu właściwości. |
| `@DisposableBean`          | Definiuje metodę `void destroy() throws Exception`. Metoda jest wywołana w momencie niszczenia komponentu przez Springa. |
| `@BeanPostProcessor`       | Definiuje metody `Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException` oraz `Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException`. Metody pozwalają na zmianę komponentu na różnych etapach. |
| `@PostConstruct`           | Dekoruje metodę która zostanie wywołana po utworzeniu komponentu. |
| `@PreDestroy`              | Dekoruje metodę która zostanie wywołana przed usunięciem komponentu. |

Jest 14 typów interfejsów `Aware` które pozwalają na wpłynięcie na wewnętrzne procesy frameworku: `ApplicationContextAware, ApplicationEventPublisherAware, BeanClassLoaderAware, BeanFactoryAware, BeanNameAware, BootstrapContextAware, EmbeddedValueResolverAware, EnvironmentAware, ImportAware, LoadTimeWeaverAware, MessageSourceAware, NotificationPublisherAware, ResourceLoaderAware, SchedulerContextAware, ServletConfigAware, ServletContextAware`.
### Adnotacje
| Adnotacja          | Opis                                                         |
| ------------------ | ------------------------------------------------------------ |
| `@Configuration`   |                                                              |
| `@Bean`            |                                                              |
| `@Primary`         |                                                              |
| `@Profile`         | Pozwala na ustawienie profilu dla którego np. komponent zostanie zainicjowany. |
| `@ActiveProfilesU` | Ustawia profile. Adnotacja szczególnie przydatna w kontekście uruchamiania testów. |
#### Adnotacja `@Service`
Adnotacja opisuje komponent, który jest usługą. Za pomocą adnotacji powinna być oznaczona implementacja usługi Nie interfejs ani klasa abstrakcyjna.

Jeśli zostanie oznaczony interfejs lub klasa abstrakcyjna to Spring nie będzie w stanie zainicjować ten komponent. 

```java
// ŻLE
@Service
public interface AuthenticationService {

    boolean authenticate(String username, String password);
}

// ŻLE
@Service
public abstract class AbstractAuthenticationService {

    public boolean authenticate(String username, String password) {
        return false;
    }
}
```

W obu przypadkach dostaniemy komunikat.

```
org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No qualifying bean of type 'com.baeldung.annotations.service.abstracts.AbstractAuthenticationService' available: 
expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: 
...
```

Adnotacja powinna wskazywać na konkretną impementację.

```java
@Service
public class InMemoryAuthenticationService implements AuthenticationService {

    @Override
    public boolean authenticate(String username, String password) {
        //...
    }
}

@Service
public class LdapAuthenticationService extends AbstractAuthenticationService {

    @Override
    public boolean authenticate(String username, String password) {
        //...
    }
}
```
#### Adnotacja `@Value`
Adnotacja pozwala na wprowadzenie wartości plików konfiguracyjnych do komponentu. Adnotacje możemy użyć na poziomie pola/metody/konstruktora.

Na poziomie pola:

```java
@Value("string value")
private String stringValue;

// Za pomocą SpELa może odwołąć się np. do wartości plików konfiguracyjnych lub pisać bardziej złożone wyrażenia.
@Value("${value.from.file}")
private String valueFromFile;

@Value("${systemValue}")
private String systemValue;

@Value("${unknown.param:some default}")
private String someDefault;

@Value("#{systemProperties['priority']}")
private String spelValue;

@Value("#{systemProperties['unknown'] ?: 'some default'}")
private String spelSomeDefault;

@Value("#{someBean.someValue}")
private Integer someBeanValue;

@Value("#{'${listOfValues}'.split(',')}")
private List<String> valuesList;
```

Użycie do wstrzyknięcia wartości przez konstruktor:

```java
@Component
@PropertySource("classpath:values.properties")
public class PriorityProvider {
 
    private String priority;
 
    @Autowired
    public PriorityProvider(@Value("${priority:normal}") String priority) {
        this.priority = priority;
    }
 
    // ...
}
```

Lub przez metodę:

```java
@Component
@PropertySource("classpath:values.properties")
public class CollectionProvider {
    private List<String> values = new ArrayList<>();
 
    @Autowired
    public void setValues(@Value("#{'${listOfValues}'.split(',')}") List<String> values) {
        this.values.addAll(values);
    }

    // ...
}
```
### Przestrzenie komponentów
Spring przechowuje instancje komponentów w kilka typach przestrzeni (Scopes). Przestrzeń definiuje w jaki sposób będzie przetwarzany obiekt.

![Znalezione obrazy dla zapytania Spring beans scopes](../../../.files/1a5594bc-1708-36d1-2299-57a142bd0d1a.gif)

Podstawowe przestrzenie to:

- Singleton - jest tworzona jedna instancja i ta instancja komponentu - **jest to podstawowa przestrzeń**,
- Prototype - za każdym razem jest tworzona nowa instancja komponentu,
- Request - dla każdego zgłoszenia jest tworzona nowa instancja,
- Session - dla każdej instancji sesji jest tworzona nowa instancja,
- Global Session - jedna instancja dla całej sesji.

Przestrzeń można zdefiniować za pomocą adnotacji przy komponencie lub w konfiguracji XML.

```java
@Service
@Scope("prototype")
public class CounterService {
    private String id;

    public CounterService() {
        this.id = UUID.randomUUID().toString();
    }

    public String getId() {
        return this.id;
    }
}
```

Komponent będzie tworzony za każdym razem gdy się do niego odwołamy.

```java
CounterService a = applicationContext.getBean(CounterService.class);
CounterService b = applicationContext.getBean(CounterService.class);

return String.format("%s, %s", a.getId(), b.getId());
```

Oba obiekty maja różne ID. W przypadku konfiguracji XML.

```xml
<bean id="parametrDao" class="pl.edu.usos.adm.dao.CommonDaoImpl" scope="prototype">
    <constructor-arg value="pl.edu.usos.adm.model.Parametr" />
</bean>
```
### Autokonfiguracja
Jest to mechanizm dostarczany przez SpringBoota. Polega on na tym, że SpringBoot skanuje wszystkie pakiety `jar` w classpath (przeglądając `META-INF/spring.factories`) w poszukiwaniu informacji o automatycznych konfiguracjach.

Automatyczną konfigurację można wykorzystać do zainicjowania komponentów (beanów) w przestrzeni aplikacji (ApplicationContext).

Powstała konwencja, że pakiety które zawierają autokonfiguracje maja nazwę artefaktu `xxx-springboot-starter` i na ogół zawieraja one podstawe klasy konfiguracyjne. Więc np. dla biblioteki `logi` mielibyśmy starter `logi-springboot-starter`.

Ważnym mechanizm w przypadku automatycznej konfiguracji sa różnego rodzaju warunku za pomoca których można zdefiniować np. czy dana konfiguracja ma zostać uruchomiona.

| Adnotacja                         | Opis                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `@ConditionalOnBean`              |                                                              |
| `@ConditionalOnClass`             | Konfiguracja zostanie uruchomiona jeśli istniją okreslone klasy w classpath. |
| `@ConditionalOnCloudPlatform`     |                                                              |
| `@ConditionalOnExpression`        | Gdy wyrażenie SpEL                                           |
| `@ConditionalOnJava`              |                                                              |
| `@ConditionalOnJndi`              |                                                              |
| `@ConditionalOnMissingBean`       | Konfiguracja zostanie uruchomiona jeśli nie został zdefiniowany komponent (bean). |
| `@ConditionalOnMissingClass`      | Konfiguracja zostanie uruchomiona jeśli nie zostanie znaleziona klasa. |
| `@ConditionalOnNotWebApplication` | Konfiguracja dla aplikacji innej niż web.                    |
| `@ConditionalOnProperty`          | Kiedy zdefiniowana jest odpowiednia właściwość               |
| `@ConditionalOnResource`          | Jeśli dostępny jest zasobu np. `file:/home/user/test.dat`    |
| `@ConditionalOnSingleCandidate`   |                                                              |
| `@ConditionalOnWebApplication`    | Konfiguracja dla aplikacji web.                              |
#### Implementacja `logi-springboot-starter`
Mam moduł `logi`. Jest to przykładowy moduł który zwiera interfejs `Printer` i implementację `SimplePrinter`.

![image-20200117235220533](../../../.files/image-20200117235220533.png)

Nastepnie mam zdefiniowany następny moduł `logi-springboot-starter` który zwiera pliki konfiguracyjne.

![image-20200117235330646](../../../.files/image-20200117235330646.png)

Poniżej lista przykładowych konfiguracji.

```java
@Configuration
public class LogiAutoconfigureByName {

    @Bean("logiPrinter")
    public Printer printer() {
        return new SimplePrinter("LogiAutoconfigureByName");
    }
}

@Configuration
public class LogiAutoconfigureConditional {

    @Bean
    @ConditionalOnMissingBean(Printer.class)
    public Printer printer() {
        return new SimplePrinter("LogiAutoconfigureConditional");
    }
}

@Configuration
public class LogiAutoconfigure {
    // @Bean
    // public Printer printer() {
    //     return new SimplePrinter("LogiAutoconfigure");
    // }
}

@Configuration
public class LogiAutoconfigureOnClass {
    @Bean
    @ConditionalOnClass(name = "com.ttmdear.repository.springautoconfigure.UserService")
    public Printer printer() {
        return new SimplePrinter("LogiAutoconfigureOnClass");
    }
}
```

Jest to prosty przykład konfiugracji w którym tworze komponenty (beany) dla interfejsu `Printer`.

W następnym kroku pliki konfiguracujne umieszczamy w `src/main/resources/META-INF/spring.factories`, SpringBoot w trakcie uruchamiana skanuje pliki `jar` w poszukiwaniu tego pliku, na postawie zawartych tam informacji wczytuje pliki konfiguracyjne. Poniżej treść tego pliku dla modułu `logic`.

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.logi.autoconfigure.LogiAutoconfigure,\
com.logi.autoconfigure.LogiAutoconfigureConditional,\
com.logi.autoconfigure.LogiAutoconfigureByName,\
com.logi.autoconfigure.LogiAutoconfigureOnClass
```

Pliki konfiguracyjne zdefiniowane są pod kluczem `EnableAutoConfiguration`.

W tym momencie możemy dodać zależność do projektu który ma korzystać z tej biblioteki:

```properties
<dependency>
    <groupId>com.logi</groupId>
    <artifactId>logi-springboot-starter</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

Po uruchomieniu aplikacji w trubie DEBUG w wierszu poleceń powinny pojawić się informacje o zaczytanych konfiguracjach.

```
Unconditional classes:
----------------------

    com.logi.autoconfigure.LogiAutoconfigureByName

    org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration

    com.logi.autoconfigure.LogiAutoconfigureConditional

    com.logi.autoconfigure.LogiAutoconfigure

    org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration

    org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration

    com.logi.autoconfigure.LogiAutoconfigureOnClass
```

Z komponentów można korzystać w aplikacji:

```java
@SpringBootApplication
public class App implements CommandLineRunner {
	@Autowired
    private Printer printer;

	@Autowired
    @Qualifier("logiPrinter")
	private Printer logiPrinter;

	@Autowired
	private UserService userService;

	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
	    printer.print("Test 1");
	    logiPrinter.print("Test 2");

	    userService.print("Test 3");
	}
}
```

W przypadku automatycznych konfiguracji należy w odpowiedni sposób zdefniować warunki oraz kolejność `@Order` w kiedy i w jakiej kolejności ma zostać uruchomiona konfiguracja/komponent.

W zasadzie automatyczna konfiguracja nie różni się szczególnie od tej podstawowe,  możliwe jest np. nadpisanie komponentu przez lokalna implementację tak jak zrobiłem to poniżej.

```java
@Component
@Primary
public class OwnPrinter implements Printer {

    @Override
    public void print(String s) {
        System.out.println("OwnPrinter " + s);
    }
}
```
### Profile
Mechanizm profili pozwala na uruchomienie aplikacji z zdefiniowanym profile. Ustawienie profilu pozwala np. na ustawienie jaki komponent ma zostać uruchomione dla określonego profilu. Np. dla profilu `testing` zostanie skonfigurowany komponent `DataSource` dla  H2 z bazą testową, dla profilu `prodution` zostanie skonfigurowany komponent `DataSource` z bazą MySQL.

Ustawienie profilu wpływa na:

- jakie komponenty zostaną wczytane,
- jakie komponenty zostaną wstrzyknięte.

Podstawowy profil to `default` . Taki jest profil jeśli nie zostanie ustawiony w `application.properties` pod kluczem `spring.profiles.active=pl`.
#### Deklaracja komponentów dla profili
Komponenty dla określonych profili można zdefiniować na poziomie komponentu adnotacji `@Component` lub w konfiguracji przy metodzie do tworzenia komponentu.

```java
@Configuration
public class BeansConfiguration {

    @Bean
    @Primary
    @Profile({"default", "eng"})
    public HelloWorldService helloWorldENGNService() {
        return new HelloWorldENGService();
    }

    @Bean
    @Profile({"pl"})
    public HelloWorldService helloWorldPLService() {
        return new HelloWorldPLService();
    }
}
```

Profile można uwzględnić również przy kompensatach.

```java
@Component
@Profile({"default", "eng"})
public class CaseAENGService implements CaseAService {
    @Override
    public String getMessage() {
        return "Message";
    }
}

@Component
@Profile({"pl"})
public class CaseAPLService implements CaseAService {
    @Override
    public String getMessage() {
        return "Wiadomość";
    }
}
```

Efekt jest taki sam. Profile mogą również definiować to jakie kontrolery zostaną zdefiniowane.

```java
@Controller
@RequestMapping("/case-a")
@Profile("pl")
public class CaseAController {
    CaseAService caseAService;

    public CaseAController(CaseAService caseAService) {
        this.caseAService = caseAService;
    }

    @RequestMapping({""})
    @ResponseBody
    public String index() {
        return caseAService.getMessage();
    }
}
```

Możemy również zanegować tak aby dany komponent się nie uruchamiał w określonym profilu.

```java
@Profile("!test")
```
#### Ustawienie profilów
Aktywne profile można ustawić na kilka sposób.

1. Ustawienie za pomocą pliku właściwości

   ````properties
   spring.profiles.active=@spring.profiles.active@
   ````

2. Ustawienie przez parametry wywołania

   ```shell
   mvn ... -Dspring.profiles.active=dev
   
   # Lub zmienna
   export spring_profiles_active=dev
   ```

3. Profile Mavena

   ```xml
   <profiles>
       <profile>
           <id>dev</id>
           <activation>
               <activeByDefault>true</activeByDefault>
           </activation>
           <properties>
               <spring.profiles.active>dev</spring.profiles.active>
           </properties>
       </profile>
       <profile>
           <id>prod</id>
           <properties>
               <spring.profiles.active>prod</spring.profiles.active>
           </properties>
       </profile>
   </profiles>
   ```

4. Użycie adnotacji @ActiveProfiles

   ```java
   @ActiveProfiles("dev")
   ```

5. Ustawienie przez SpringApplication

   ```java
   SpringApplication.setAdditionalProfiles("dev");
   ```
#### Odczytanie aktywnego profilu
Aktywne profile można odczytać na kilka sposób:

1. Przez komponent środowiska

   ```java
   public class ProfileManager {
       @Autowired
       private Environment environment;
    
       public void getActiveProfiles() {
           for (String profileName : environment.getActiveProfiles()) {
               System.out.println("Currently active profile - " + profileName);
           }  
       }
   }
   ```

2. Wstrzyknięcie przez adnotację `@Value`

   ```java
   @Value("${spring.profiles.active}")
   private String activeProfile;
   ​```## Pozostałe
#### Interfejs `CommandLineRunner`
Jest to interfejs z jedną metodą `run()`. Interfejs może być implementowany przez główną aplikacje Springa. Wtedy metoda `run` zostanie wywołana gdy zostaną wczytany kontekst aplikacji.

```java
package com.tooki.api;

import com.tooki.api.services.Counter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class Application implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        // ...
    }
}
```

Interfejs może być również implementowany przez komponent.

```java
@Component
public class DataLoader implements CommandLineRunner {
    private final OwnerService ownerService;
    private final PetService petService;
    private final VetService vetService;

    public DataLoader() {
        ownerService = new OwnerServiceMap();
        petService = new PetServiceMap();
        vetService = new VetServiceMap();
    }

    @Override
    public void run(String... args) throws Exception {
        // ...
    }
}
```

Interfejs można wykorzystać np. do zaimplementowania mechanizmu do inicjowania danych w repozytoriach.
#### Moduł `BeanPostProcessor`
Za pomocą `BeanPostProcessor` możemy np. dodać dodatkowe wywołania dla innych komponentów. Poniżej mamy komponent `SimpleLogger`.

```java
@Component
public class SimpleLogger implements Logger {
    public void beforeInit() { /** ... */ }
    public void afterInit() { /** ... */ }
}
```

Definiujemy własny `CustomBeanPostProcessor` jako komponent. Musi być to komponent aby został rozpoznany.

```java
@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof SimpleLogger) {
            ((SimpleLogger) bean).beforeInit();
        }

        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof SimpleLogger) {
            ((SimpleLogger) bean).afterInit();
        }

        return bean;
    }
}
```

W ten sposób udało nam się rozszerzyć komponent `SimpleLogger` o dodatkowe wywołania.
#### Różnica między `BeanFactory` i `ApplicationContext`
Są to dwa podstawowe interfejsy. Pierwszy opisuje obiekt tworzący komponenty. Drugi opisuje cały kontekst aplikacji. Podstawową implementacją interfejsu `BeanFactory` jest `XMLBeanFactory ` który korzysta z pliku XML jako konfiguracji komponentów. Podstawową implementacją `ApplicationContext` jest `ClassPathXmlApplicationContext`.

Warto wspomnieć, że `ApplicationContext` rozszerza interfejs `BeanFactory` .

![What is difference between BeanFactory and ApplicationContext in Spring framework](../../../.files/image.png)

`ApplicationContext` względem `BeanFactory` dostarcza wielu dodatkowych funkcji:

- związanych z obsługą zdarzeń,
- internacjolizacją,
- obsługą wiadomości itp.

Ogólnie w kontekście aplikacji powinno stosować się `ApplicationContext` do inicjowania komponentów. Natomiast w celach testowych tylko po to aby zainicjować komponent wystarczy, że użyjemy zwykłego `BeanFactory` .
## MVC
https://spring.io/guides/gs/serving-web-content

![Znalezione obrazy dla zapytania MVC spring](../.files/1a5574bc-d708-46d9-a199-57a142bd0d1e.png)

Spring posiada wbudowaną obsługę kontrolerów, modeli oraz widoków.
### Kontroler
https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-arguments

Kontroler definiujemy za pomocą adnotacji `@Controller` lub `@RestController`.

`@RestController`  zapewnia, że wartości z oznaczonych metody bedą zwracane bezpośrednio. W przypadku `@Controller` trzeba było dodawać dodatkowo adnotację `@ResponseBody`.

```java
@RestController
public class Meetings {
    @Autowired
    TkMeetingRepo tkMeetingRepo;

    @Autowired
    Counter counter;

    @Autowired
    HttpSession session;

    // @RequestMapping(value = "/logs", method= RequestMethod.POST)
    @PostMapping(value = "/meetings")
    public Meeting post(
        @RequestParam(value="typeId",  required = false) String typeId,
        @RequestParam(value="latitude", required = false) String latitude,
        @RequestParam(value="longitude", required = false) String longitude
    ) {
        TkMeeting meeting = new TkMeeting();

        meeting.setTypeId(typeId);

        meeting.setLatitude(latitude);
        meeting.setLongitude(longitude);

        tkMeetingRepo.save(meeting);

        return meeting;
    }

    @GetMapping(value = "/meetings")
    public Meeting get(HttpRequest request) {
        System.out.println(request.getMethod());

        Meeting meeting = tkMeetingRepo.findLastMeetingWithCoffee();

        return meeting;
    }
}
```

Do kontrolera mogą zostać wstrzyknięte obiekty tak jak w przypadku zwykłych komponentów.

Do metody mogą zostać wstrzyknięte parametry żądania lub obiekty.

Poniżej lista obiektów które mogą zostać wstrzyknięte do metody:

| Controller method argument                                   | Description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `WebRequest`, `NativeWebRequest`                             | Generic access to request parameters and request and session attributes, without direct use of the Servlet API. |
| `javax.servlet.ServletRequest`, `javax.servlet.ServletResponse` | Choose any specific request or response type — for example, `ServletRequest`, `HttpServletRequest`, or Spring’s `MultipartRequest`, `MultipartHttpServletRequest`. |
| `javax.servlet.http.HttpSession`                             | Enforces the presence of a session. As a consequence, such an argument is never `null`. Note that session access is not thread-safe. Consider setting the `RequestMappingHandlerAdapter` instance’s `synchronizeOnSession` flag to `true` if multiple requests are allowed to concurrently access a session. |
| `javax.servlet.http.PushBuilder`                             | Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes. Note that, per the Servlet specification, the injected `PushBuilder`instance can be null if the client does not support that HTTP/2 feature. |
| `java.security.Principal`                                    | Currently authenticated user — possibly a specific `Principal` implementation class if known. |
| `HttpMethod`                                                 | The HTTP method of the request.                              |
| `java.util.Locale`                                           | The current request locale, determined by the most specific `LocaleResolver` available (in effect, the configured `LocaleResolver` or `LocaleContextResolver`). |
| `java.util.TimeZone` + `java.time.ZoneId`                    | The time zone associated with the current request, as determined by a `LocaleContextResolver`. |
| `java.io.InputStream`, `java.io.Reader`                      | For access to the raw request body as exposed by the Servlet API. |
| `java.io.OutputStream`, `java.io.Writer`                     | For access to the raw response body as exposed by the Servlet API. |
| `@PathVariable`                                              | Zwraca wartość umieszczoną w zmiennej zdefiniowanej w szablonie ścieżki (placeholderze). |
| `@MatrixVariable`                                            | Zwraca listę parametrów ścieżki. Parametry ścieżki są to parametry dodane po średniku w ścieżce. A Springu nazwane są Path Matrix Variable.<br />`GET /pets/42;q=11;r=22` |
| `@RequestParam`                                              | Wartości parametrów Query.                                   |
| `@RequestHeader`                                             | For access to request headers. Header values are converted to the declared method argument type. See [`@RequestHeader`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestheader). |
| `@CookieValue`                                               | For access to cookies. Cookies values are converted to the declared method argument type. See [`@CookieValue`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-cookievalue). |
| `@RequestBody`                                               | For access to the HTTP request body. Body content is converted to the declared method argument type by using `HttpMessageConverter`implementations. See [`@RequestBody`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestbody). |
| `HttpEntity<B>`                                              | For access to request headers and body. The body is converted with an `HttpMessageConverter`. See [HttpEntity](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-httpentity). |
| `@RequestPart`                                               | For access to a part in a `multipart/form-data` request, converting the part’s body with an `HttpMessageConverter`. See [Multipart](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-multipart-forms). |
| `java.util.Map`, `org.springframework.ui.Model`, `org.springframework.ui.ModelMap` | For access to the model that is used in HTML controllers and exposed to templates as part of view rendering. |
| `RedirectAttributes`                                         | Specify attributes to use in case of a redirect (that is, to be appended to the query string) and flash attributes to be stored temporarily until the request after redirect. See [Redirect Attributes](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-redirecting-passing-data) and [Flash Attributes](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-flash-attributes). |
| `@ModelAttribute`                                            | For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See [`@ModelAttribute`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args) as well as [Model](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-modelattrib-methods) and [`DataBinder`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-initbinder).Note that use of `@ModelAttribute` is optional (for example, to set its attributes). See “Any other argument” at the end of this table. |
| `Errors`, `BindingResult`                                    | For access to errors from validation and data binding for a command object (that is, a `@ModelAttribute` argument) or errors from the validation of a `@RequestBody` or `@RequestPart` arguments. You must declare an `Errors`, or `BindingResult` argument immediately after the validated method argument. |
| `SessionStatus` + class-level `@SessionAttributes`           | For marking form processing complete, which triggers cleanup of session attributes declared through a class-level `@SessionAttributes`annotation. See [`@SessionAttributes`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-sessionattributes) for more details. |
| `UriComponentsBuilder`                                       | For preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping. See [URI Links](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-uri-building). |
| `@SessionAttribute`                                          | For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level `@SessionAttributes`declaration. See [`@SessionAttribute`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-sessionattribute) for more details. |
| `@RequestAttribute`                                          | For access to request attributes. See [`@RequestAttribute`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestattrib) for more details. |
| Any other argument                                           | If a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by[BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-), it is a resolved as a `@RequestParam`. Otherwise, it is resolved as a `@ModelAttribute`. |

W zależności od tego co metoda zwraca, Spring wywoła odpowiedni mechanizm tworzący odpowiedź. Możliwe wartość zwracane przez metodę:
| Controller method return value                               | Description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `@ResponseBody`                                              | The return value is converted through `HttpMessageConverter` implementations and written to the response. See [`@ResponseBody`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-responsebody). |
| `HttpEntity<B>`, <br />`ResponseEntity<B>`                   | The return value that specifies the full response (including HTTP headers and body) is to be converted through `HttpMessageConverter`implementations and written to the response. See [ResponseEntity](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-responseentity). |
| `HttpHeaders`                                                | For returning a response with headers and no body.           |
| `String`                                                     | A view name to be resolved with `ViewResolver` implementations and used together with the implicit model — determined through command objects and `@ModelAttribute` methods. The handler method can also programmatically enrich the model by declaring a `Model`argument (see [Explicit Registrations](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-registration)). |
| `View`                                                       | A `View` instance to use for rendering together with the implicit model — determined through command objects and `@ModelAttribute`methods. The handler method can also programmatically enrich the model by declaring a `Model` argument (see [Explicit Registrations](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-registration)). |
| `java.util.Map`,<br /> `org.springframework.ui.Model`        | Attributes to be added to the implicit model, with the view name implicitly determined through a `RequestToViewNameTranslator`. |
| `@ModelAttribute`                                            | An attribute to be added to the model, with the view name implicitly determined through a `RequestToViewNameTranslator`.Note that `@ModelAttribute` is optional. See "Any other return value" at the end of this table. |
| `ModelAndView` object                                        | The view and model attributes to use and, optionally, a response status. |
| `void`                                                       | A method with a `void` return type (or `null` return value) is considered to have fully handled the response if it also has a `ServletResponse`, an `OutputStream` argument, or an `@ResponseStatus` annotation. The same is also true if the controller has made a positive `ETag` or `lastModified` timestamp check (see [Controllers](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-caching-etag-lastmodified) for details).If none of the above is true, a `void` return type can also indicate “no response body” for REST controllers or a default view name selection for HTML controllers. |
| `DeferredResult<V>`                                          | Produce any of the preceding return values asynchronously from any thread — for example, as a result of some event or callback. See [Asynchronous Requests](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async) and [`DeferredResult`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-deferredresult). |
| `Callable<V>`                                                | Produce any of the above return values asynchronously in a Spring MVC-managed thread. See [Asynchronous Requests](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async) and [`Callable`](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-callable). |
| `ListenableFuture<V>`,<br />`java.util.concurrent.CompletionStage<V>`,<br />`java.util.concurrent.CompletableFuture<V>` | Alternative to `DeferredResult`, as a convenience (for example, when an underlying service returns one of those). |
| `ResponseBodyEmitter`, `SseEmitter`                          | Emit a stream of objects asynchronously to be written to the response with `HttpMessageConverter` implementations. Also supported as the body of a `ResponseEntity`. See [Asynchronous Requests](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async) and [HTTP Streaming](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming). |
| `StreamingResponseBody`                                      | Write to the response `OutputStream` asynchronously. Also supported as the body of a `ResponseEntity`. See [Asynchronous Requests](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async) and [HTTP Streaming](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming). |
| Reactive types — Reactor, RxJava, or others through `ReactiveAdapterRegistry` | Alternative to `DeferredResult` with multi-value streams (for example, `Flux`, `Observable`) collected to a `List`.For streaming scenarios (for example, `text/event-stream`, `application/json+stream`), `SseEmitter` and `ResponseBodyEmitter` are used instead, where `ServletOutputStream` blocking I/O is performed on a Spring MVC-managed thread and back pressure is applied against the completion of each write.See [Asynchronous Requests](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async) and [Reactive Types](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-reactive-types). |
| POJO - Any other return value                                | Any return value that does not match any of the earlier values in this table and that is a `String` or `void` is treated as a view name (default view name selection through `RequestToViewNameTranslator` applies), provided it is not a simple type, as determined by[BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-). Values that are simple types remain unresolved. |

**Mapowanie URL na metodę**

------

Do mapowania adresu URL na metode służy adnotacja RequestMapping. Może zostać ona nadana na klase lub metodę.

```java
@RestController
@RequestMapping("/home")
public class IndexController {
  @RequestMapping(value = "/prod", produces = {"application/JSON"})
  @ResponseBody
  String getProduces(){
    return "Produces attribute";
  }

  @RequestMapping(value = "/cons", consumes = {"application/JSON", "application/XML"})
  String getConsumes(){
    return "Consumes attribute";
  }
}
```

Adnotacja pozwala na podpięcie wielu adresów pod jedną metodę.

```java
@RestController
@RequestMapping("/home")
public class IndexController {
    @RequestMapping(value={"", "/page", "page*","view/*,**/msg"})
    String indexMultipleMapping(){
        return "Hello from index multiple mapping.";
    }
}
```

Zostaną wygenerowane linki:

```
localhost:8080/home
localhost:8080/home/
localhost:8080/home/page
localhost:8080/home/pageabc
localhost:8080/home/view/
localhost:8080/home/view/view
```

Adnotację można połączyć z adnotacją RequestParam, za pomocą której można przekazać wartości parametrów.

```java
@RestController
@RequestMapping("/home")
public class IndexController {
  @RequestMapping(value = "/name")
  String getName(@RequestParam(value = "person", required = false defaultValue = "John" method = RequestMethod.GET) String personName){
    return "Required element of request param";
  }
}
```

Wygenerują linki:

```
/home/name?person=xyz
/home/name
```

W ramach żądania można zdefiniować jakiego typu wartość może zostać zwrócona lub jakiego typu wartość może odczytać (ACCEPT-CONTENT, CONTENT-TYPE).

```java
@RestController
@RequestMapping("/home")
public class IndexController {
  @RequestMapping(value = "/prod", produces = {"application/JSON"})
  @ResponseBody
  String getProduces(){
    return "Produces attribute";
  }

  @RequestMapping(value = "/cons", consumes = {"application/JSON", "application/XML"})
  String getConsumes(){
    return "Consumes attribute";
  }
}
```

Adnotacja umożliwia na definiowanie nagłówków w żądaniu.

```java
@RestController
@RequestMapping("/home")
public class IndexController {
  @RequestMapping(value = "/head", headers = {"content-type=text/plain", "content-type=text/html"})      String post(){
    return "Mapping applied along with headers";
  }
}
```

Definiowanie dynamicznych adresów URL.

```java
@RestController
@RequestMapping("/home")
public class IndexController {
  @RequestMapping(value = "/fetch/{id}", method = RequestMethod.GET)
  String getDynamicUriValue(@PathVariable String id){
    System.out.println("ID is "+id);
    return "Dynamic URI parameter fetched";
  }
  @RequestMapping(value = "/fetch/{id:[a-z]+}/{name}", method = RequestMethod.GET)
    String getDynamicUriValueRegex(@PathVariable("name") String name){
    System.out.println("Name is "+name);
    return "Dynamic URI parameter fetched using regex";
  }
}
```

Dostępne są również skróty:

```
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping
```
#### Odczytanie treści żądania
W przypadku gdy zażądamy obiektu dla metody który nie jest żadnym z wyżej opisanych Spring MVC odczyta kontent żądania i spróbuje go zmapować zdefiniowany obiekt. W przykładzie poniżej

```java
@Controller
@RequestMapping("/users")
public class UserController {
    @PostMapping("")
    @ResponseBody
    public String indexAction(UserInput userInput) {
        return userInput.toString();
    }

    public static class UserInput {
        public String id;
        public UserEmailInput[] email;
        public UserPaymentInput payment;
        // ...
    }

    public static class UserEmailInput {
        private String value;
    }

    public static class UserPaymentInput {
        private String type;
        private float rate;
    }
}
```

Klasa UserInput jest obiektem typu DTO. Obiekt zostanie wypełniony o dane przekazane w żądaniu. W przypadku gdy Content-Type jest np. `application/x-www-form-urlencoded`.

```
id=10&email[0].value=pawel@o2.pl&payment.type=rate&payment.rate=10.00
```

Dane zostaną odkodowane:

```
UserInput{id='10', email=[UserEmailInput{value='pawel@o2.pl'}], payment=UserPaymentInput{type='rate', rate=10.0}}
```

W przypadku deklaracji takiej jak wyżej:

```java
public String indexAction(UserInput userInput)
```

Zostanie odczytany tylko kontent zakodowany za pomocą `application/x-www-form-urlencoded`. Nie zostanie odczytany inny format typu `application/json, xml` etc.

Aby odczytać inne formaty należy dodać adnotacje `@RequestBody` do zmiennej wtedy zostanie użyty `HttpMessageConverter` do odkodowania wiadomości na postawie `Content-Type`.

Więc jeśli chcemy np. odczytać treść zakodowaną za pomocą jsona zmieniamy:

```
public String indexAction(@RequestBody UserInput userInput)
```

**Nie wiem dlaczego `application/x-www-form-urlencoded` jest traktowany inaczej niż pozostałe formaty.**

Jedyn z rozwiązań jest implementacja dwóch metod.

```java
@PostMapping(value = "", consumes = {"application/x-www-form-urlencoded"})
@ResponseBody
public String indexActionForForm(UserInput userInput) {
    return indexAction(userInput);
}

@PostMapping("")
@ResponseBody
public String indexAction(@RequestBody UserInput userInput) {

    return userInput.toString();
}
```

#### Mapowanie

Jest to mechanizm pozwalający na zmapowanie adresu URL na metodę w kontrolerze. W wyrażeniach możłiwe jest używanie wyrażeń SpEL.

```java
@Controller
@RequestMapping("${pageContext.request.contextPath}")
public class MainController {
    @RequestMapping("/")
    public ModelAndView index() {
    }
}
```

#### Kontekst ścieżka

Właściwość `server.contextPath` jest to ustawienie pozwalające na ustawienie ogólnej ścieżki `application.properties`.

`server.contextPath=/myapp/mypage`

controller

`@RequestMapping("/test")`

Wynik

`http://localhost:8080/myapp/mypage/test`
### Widok
W przypadku zwykłego kontrolera (`@Controller`) widok jest generowany z wykorzystaniem mechanizmu do tworzenia widoku. W standardowej konfiguracji jest to mechanizm szablonów Thymeleaf.

Thymeleaf jest typowym językiem szablonowym.

```html
<table>
  <thead>
    <tr>
      <th th:text="#{msgs.headers.name}">Name</th>
      <th th:text="#{msgs.headers.price}">Price</th>
    </tr>
  </thead>
  <tbody>
    <tr th:each="prod: ${allProducts}">
      <td th:text="${prod.name}">Oranges</td>
      <td th:text="${#numbers.formatDecimal(prod.price, 1, 2)}">0.99</td>
    </tr>
  </tbody>
</table>
```

Wyróżnia się na pewno tym, że wartości są umieszczane w znacznikach HTML. Na przykład w Smartach znaczniki szablonów są osobną składnią przez co szablony Smartowe wymagają osobnego podejścia.

O tym jaki widok zostanie zaczytany decydujemy w kontrolerze. W zależności od tego jaką wartość zwraca kontroler odpowiedni widok zostanie wczytany. **Kontroler musi być oznaczony adnotacją @Controller**. W przypadku oznaczenia adnotacją `@RestController` zwracana odpowiedź z metody jest interpretowana inaczej.
### Model
Model w Springu jest realizowany przez obiekt który może zostać wstrzyknięty do metody.

```java
@Controller
public class GreetingController {

    @GetMapping("/greeting")
    public String greeting(
        @RequestParam(name="name", required=false, defaultValue="World") String name, Model model) {
        model.addAttribute("name", name);
        return "greeting";
    }
}
```

Jeśli w metodzie odwołujemy się np. do parametru typu `org.springframework.ui.Model`. To zostanie wstrzyknięty model. Za pomocą tego obiektu możemy przekazać informacje do widoku.

Następnie w widoku można odwołać się do wartość ustawionych w modelu.

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Getting Started: Serving Web Content</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
    <p th:text="'Hello, ' + ${name} + '!'" />
</body>
</html>
```

Wartości do modelu możemy przekazać:

- przez DI do metody (jak powyżej),
- przez adnotacje `@ModelAttribute`.

Adnotacje **ModelAttribute** można użyć w kontekście metody lub parametru.

```java
public class StudentsController {
    // Metoda zwracająca atrybut modelu
    @ModelAttribute(name = "header")
    private Header getHeader() {
        return new Header();
    }

	// Metoda zwracająca atrybut modelu
    @ModelAttribute(name = "type")
    private String getType() {
        return "students";
    }

    @GetMapping({"", "/"})
    public String indexAction(@ModelAttribute("mode") ModeDTO mode, Model model) {
        // Dodanie do wstrzykniętego modelu
        model.addAttribute("status", "active");

        return "students/index";
    }

    private static class Header {
		// ...
    }

    public static class ModeDTO {
		// ...
    }
}
```
### Mechanizm WebDataBinder
Jest to mechanizm pośredniczący w przetwarzaniu danych tgz. RAW np. z formularza na odpowiednie obiekty w Javie.

Aby zkonfigurować taki WebDataBinder musimy utworzyc metodę która przyjmie taki parametr oraz metoda oznaczyć adnotacją InitBinder.

```java
@Controller
@RequestMapping("/works")
public class WorksController {
    @InitBinder
    public void initBinder(WebDataBinder webDataBinder) {
        // webDataBinder.setFieldDefaultPrefix("user");

        // Ustawiamy jakie pola mogą być przekazane
        webDataBinder.setAllowedFields("id", "name");
    }

    @GetMapping({"", "/"})
    public String indexAction(@ModelAttribute("input") InputData inputData) {
        return "works/index";
    }
}
```

Za pomocą tego mechanizmu możemy zdefiniować tgz. edytor który może przetworzyć dane w określony sposób.

```java
@InitBinder
public void initBinder(WebDataBinder webDataBinder) {
    // webDataBinder.setFieldDefaultPrefix("user");

    // Ustawiamy jakie pola mogą być przekazane
    // webDataBinder.setAllowedFields("id", "name");

    // Edytor powoduje, że czyszczone są białe znaki oraz
    // pusta wartość zamieniana jest na NULLA
    webDataBinder.registerCustomEditor(String.class, new StringTrimmerEditor(true));
}
```
### Handler Mapping
Jest to komponent odpowiedzialny za zmapowanie przychodzących żądań na handlery. Jest dostępnych kilka standardowych Handler Mapperów jak:

- SimpleUrlHandlerMapping,
- BeanNameUrlHandlerMapping.

`HandlerMapping`  w trakcie przetwarzania tworzy `HandlerExecutionChain`, jest to plan wykonania (realizacji) żądania. Z ``HandlerExecutionChain` korzysta `DispatcherServlet` który wykonuje `Handler` oraz tgz. `Interceptors`.



### Przekierowanie

Z poziomu kontrolera możliwe jest przekierowanie na inna akcję. Przekierowanie może dotyczyć przeglądatki (Redirect) lub przekierowanie wewnętrzne (forward).

Jednym ze sposób przekierowania jest zwórcenie instacji obiektu RedirectView przez akcje.

```java
@Controller
@RequestMapping("/")
public class RedirectController {

    @GetMapping("/redirectWithRedirectView")
    public RedirectView redirectWithUsingRedirectView(
      RedirectAttributes attributes) {
        attributes.addFlashAttribute("flashAttribute", "redirectWithRedirectView");
        attributes.addAttribute("attribute", "redirectWithRedirectView");
        return new RedirectView("redirectedUrl");
    }
}
```

Przekierowanie jest realizowane przez zwrócenie nagłówka HTTP.

```
HTTP/1.1 302 Found
Server: Apache-Coyote/1.1
Location:
  http://localhost:8080/spring-rest/redirectedUrl?attribute=redirectWithRedirectView
```

Innym sposobem jest wrócenie instacji obiektu ModelAndView z przekazym prefiksem (redirect, forward).

```java
@Controller
@RequestMapping("/")
public class RedirectController {

    @GetMapping("/redirectWithRedirectPrefix")
    public ModelAndView redirectWithUsingRedirectPrefix(ModelMap model) {
        model.addAttribute("attribute", "redirectWithRedirectPrefix");
        return new ModelAndView("redirect:/redirectedUrl", model);
    }
}
```

Efekt jest podobny.

Możemy równiez użyc przekierowanie wewnętrznego forward.

```java
@Controller
@RequestMapping("/")
public class RedirectController {

    @GetMapping("/forwardWithForwardPrefix")
    public ModelAndView redirectWithUsingForwardPrefix(ModelMap model) {
        model.addAttribute("attribute", "forwardWithForwardPrefix");
        return new ModelAndView("forward:/redirectedUrl", model);
    }
}
```

W trakcie przekierowania możliwe jest przekazanie atrybutów. Robimy to w ten sposób.

```java
@GetMapping("/redirectWithRedirectAttributes")
public RedirectView redirectWithRedirectAttributes(RedirectAttributes attributes) {

    attributes.addFlashAttribute("flashAttribute", "redirectWithRedirectAttributes");
    attributes.addAttribute("attribute", "redirectWithRedirectAttributes");
    return new RedirectView("redirectedUrl");
}
```

Następnie w docelowej akcji.

```java
@GetMapping("/redirectedUrl")
public ModelAndView redirection(
  ModelMap model,
  @ModelAttribute("flashAttribute") Object flashAttribute) {

     model.addAttribute("redirectionAttribute", flashAttribute);
     return new ModelAndView("redirection", model);
 }
```
### Obsługa błędów i wyjątków
Spring udostępnia kilka mechanizmów do obsługi błędów i wyjątków.
#### Adnotacja @ResponseStatus
Za pomocą adnotacji możemy oznaczyć jaki kod Http ma zostać zwrócone jeśli wyjątek zostanie przechwycony.

```java
@ResponseStatus(code = HttpStatus.NOT_FOUND)
public class NotFound extends RuntimeException {
}
```

Adnotacja może być połączona z adnotacją @ExceptionHandler dzięki czemu w ramach handlera możemy ustawić zwracany kod.
#### Adnotacja @ExceptionHandler
Adnotacja pozwala na poziomie kontrolera MVC zdefiniować metodę która przechwyci i obsłuży wyjątek. W poniższym przykładzie metoda jest zdefiniowana na poziomie bazowego kontrolera.

```java
public class BaseController {
    @ExceptionHandler(NotFound.class)
    public ModelAndView handleNotFound() {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("notFound");

        return modelAndView;
    }

    @ExceptionHandler(PermissionDenied.class)
    public ModelAndView handlePermissionDenied() {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("permissionDenied");

        return modelAndView;
    }
}
```

Inny przykłąd w którym przechwytuje bląd i przekazuje do widoku.

```java
@RestController
public class PhoneController {
    @RequestMapping(value = "/phones/{id}")
    public Long get(@PathVariable Long id) {
        return id;
    }

    @ExceptionHandler(NumberFormatException.class)
    public ModelAndView handleNumberFormatException(Exception exception) {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("400error");
        modelAndView.addObject("exception", exception);

        return modelAndView;
    }
}
```
#### Adnotacja @ControllerAdvice
Pozwala na globalne zdefiniowanie obsługi wyjątków.

```java
@ControllerAdvice
public class ExceptionHandlerController {
    @ResponseStatus(HttpStatus.NOT_FOUND)
    @ExceptionHandler(NotFound.class)
    public ModelAndView handleNotFound() {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("notFound");

        return modelAndView;
    }

    @ResponseStatus(HttpStatus.FORBIDDEN)
    @ExceptionHandler(PermissionDenied.class)
    public ModelAndView handlePermissionDenied() {
    	// ...
    }

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(NumberFormatException.class)
    public ModelAndView handleNumberFormatException(Exception exception) {
		// ...
    }
}	
```
##### ResponseEntityExceptionHandler
Klasa ResponseEntityExceptionHandler jest podstawową implementacją dla kontrolera typu ControllerAdvice. Zawiera ona wszystkie podstawowe metody do obsługi błędów.

W poniższym przykładzie ciekawy jest interfejs ErrorCodeAware. Jeśli taki zostanie dodany do wyjątku to pozwala on na zdefiniowanie jaki kod ma zostać zwrócony.

```java
@Slf4j
@ControllerAdvice
public class ErrorController extends :w {
    @ExceptionHandler({ValidationException.class})
    public ResponseEntity<ErrorResponse> handleError(ValidationException e) {
        return createClientErrorResponse(e);
    }

    @ExceptionHandler({RuntimeException.class})
    public ResponseEntity<ErrorResponse> handleInternalError(RuntimeException e) {
        return createInternalErrorResponse(e);
    }

    @Override
    protected ResponseEntity<Object> handleExceptionInternal(Exception ex, Object body, HttpHeaders headers,
        HttpStatus status, WebRequest request) {

        ResponseEntity<ErrorResponse> communicationResponse = createCommunicationErrorResponse(ex);

        return new ResponseEntity<>(communicationResponse.getBody(), communicationResponse.getHeaders(),
            communicationResponse.getStatusCode());
    }
	
    // ...
}
```

### Żądanie multipart

Jest to żądanie które może zawierać w sobie kilka wiadomości w różnych formatach. Często jest wykorzystywany do przekazywania plików.

```
POST http://localhost:8080/api/attachment/upload
Authorization: Bearer {{token}}
Content-Type: multipart/form-data; boundary=---------------------------9051914041544843365972754266
Content-Length: 554

-----------------------------9051914041544843365972754266
Content-Disposition: form-data; name="name"

text default
-----------------------------9051914041544843365972754266
Content-Disposition: form-data; name="file"; filename="a.txt"
Content-Type: text/plain

Content of a.txt.

-----------------------------9051914041544843365972754266
Content-Disposition: form-data; name="file2"; filename="a.html"
Content-Type: text/html

<!DOCTYPE html><title>Content of a.html.</title>

-----------------------------9051914041544843365972754266--
```

Powyższe żądanie zawiera trzy części, nazwę pliku, plik 1 oraz plik 2. Aby odwołać się do tych wartości w kontrolerze możemy zastosować adnotację `@RequestPart` za pomocą której wskażemy który element chcemy pobrać.

Metoda może wyglądać tak:

```java
@PostMapping("/upload")
	public void upload(@RequestPart String name, @RequestBody MultipartFile file) {
	System.out.println("Test");
}
```

Aby odwołać się do wszystkich pól możemy zmapować żądanie na StandardMultipartHttpServletRequest.

```java
@PostMapping("/upload")
public void upload(@RequestPayload StandardMultipartHttpServletRequest multipartRequest) {
    System.out.println("Test");
}
```

### Przykład

W tym przykładzie zostanie stworzony kontroler wraz z obsługą widoku i modelu do wyświetlania listy zadań. W pierwszym kroku definiujemy kontroler.

```java
@Controller
public class TodoController {
    @RequestMapping(value = "/todo", method = RequestMethod.GET)
    public String index() {
        return "todo";
    }
}
```

Metoda `index` jest z mapowana na adres `/todo`. Oznacza to, że zostanie wywołana odwołamy się do adresu `/todo` z metodą `GET`.

W ciele metody umieszczana jest logika. Jeśli metoda zwróci `Stringa` to zostanie to potraktowane jako nazwa szablony który ma zostać skompilowany. W naszym przypadku to `todo.html` znajdujący się w katalogu `src/main/resources/templates/todo.html`.

> A view name to be resolved with `ViewResolver` implementations and used together with the implicit model — determined through command objects and `@ModelAttribute` methods. The handler method can also programmatically enrich the model by declaring a `Model`argument (see [Explicit Registrations](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-registration)).

W wyniku takiej konfiguracji pod adresem `localhost:8080/todo` mamy:

![1570912956298](../../../.files/1a6695bc-d708-46d9-a299-57a142bd0d12.gif)

Przykażdy przez model więcej danych.

```java
package com.tooki.api.controllers;

import com.tooki.api.models.Meeting;
import com.tooki.api.models.TkMeeting;
import org.springframework.http.HttpMethod;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.context.request.WebRequest;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;

@Controller
public class TodoController {
    @RequestMapping(value = "/todo/{userId}", method = RequestMethod.GET)
    public String index(
            WebRequest request,
            NativeWebRequest nativeWebRequest,
            HttpMethod method,
            Locale locale,
            TimeZone timeZone,
            InputStream inputStream,
            @PathVariable(value = "userId") String userId,
            Model model
    ) {
        model.addAttribute("method", method.toString());
        model.addAttribute("locale", locale.toString());
        model.addAttribute("localeLanguage", locale.getLanguage());
        model.addAttribute("timeZone", timeZone.getDisplayName());
        model.addAttribute("userId", userId);

        List<Meeting> meetingList = new ArrayList<>();

        meetingList.add(new TkMeeting(){{setName("A");}});
        meetingList.add(new TkMeeting(){{setName("B");}});
        meetingList.add(new TkMeeting(){{setName("C");}});
        meetingList.add(new TkMeeting(){{setName("D");}});
        meetingList.add(new TkMeeting(){{setName("E");}});

        model.addAttribute("meetings", meetingList);

        return "todo";
    }
}

```

W powyższym przykładzie przez model przekazujemy dane do widoku. W widoku implementujemy sposób wyświetlenia danych.

```java
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>Todo</title>
</head>
<body>
    <h1> Lista parametrów </h1>
    <table>
        <thead>
            <tr>
                <th>Atrybut</th>
                <th>Wartość</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Method</td>
                <td th:text="${method}"/>
            </tr>
            <tr>
                <td>Locale</td>
                <td th:text="${locale}"/>
            </tr>
            <tr>
                <td>Locale language</td>
                <td th:text="${localeLanguage}"/>
            </tr>
            <tr>
                <td>Time zone</td>
                <td th:text="${timeZone}"/>
            </tr>
                <td>User ID</td>
                <td th:text="${userId}"/>
            </tr>
        </tbody>
    </table>
    <h1> Iterowanie </h1>
    <ul th:each="meeting : ${meetings}">
        <li th:text="${meeting.name}"></li>
    </ul>
</body>
</html>
```

W wyniku mamy:

![1570916422553](../../../.files/1a5594bc-d708-47d9-a199-57a142bd0d13.gif)

## Filtry i interceptory

Filtry i interceptory pozwalają na podłączenie się w proces przetwarzania żądania i wykonania określonych operacji na żądaniu lub odpowiedź.

Z filtrów korzystamy np. gdy chcemy zmodyfikować żądanie/odpowiedź. Dodać nowy nagłówek np. `X-Powered-By`, zmienić URL.

Interceptory służą bardziej do modyfikacji przychodzących i zwracanych danych.

### Filtry

Aby filtr został rozpoznany przez Springa musi implementować interfejs `Filter`.

```java
@Component
@Order(1)
public class TransactionFilter implements Filter {

    @Override
    public void doFilter(
      ServletRequest request, 
      ServletResponse response, 
      FilterChain chain) throws IOException, ServletException {
 
        HttpServletRequest req = (HttpServletRequest) request;
        LOG.info(
          "Starting a transaction for req : {}", 
          req.getRequestURI());
 
        chain.doFilter(request, response);
        LOG.info(
          "Committing a transaction for req : {}", 
          req.getRequestURI());
    }

    // other methods 
}
```

### Interceptory

Jest to mechanizm za pomocą którego możemy wykonać kod w trakcie przetwarzania żądania (przed, po i po przetworzeniu). Interceptor powinien implementować interfejs `HandlerInterceptor` lub rozszerzać klasę `HandlerInterceptorAdapter`.

```java
public class LoggerInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle");

        // true - żądanie jest przetwarzane,
        // false - przetwarzanie jest zakończone
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion");
    }
}

```

Powyżej jest przykładowa implementacja interceptora. Interceptor może implementować `preHandle, postHandle, afterCompletion`.

Aby interceptor był użyty musimy w konfiguracji go zarejestrować.

```java
@Configuration
public class WebMvcConfigurer implements org.springframework.web.servlet.config.annotation.WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoggerInterceptor());
    }
}
```

Istotne jest, że jest to konfiguracja typu `WebMvcConfigurer` gdzie implementujamy metodę `addInterceptors`.

Interceptory moga posłużyć np. do wyciągania informacji z żądania. Spotkalem się z przypadkiem gdzie za pomocą interceptora była wyciągana informacja o podpisie WSS dla żądania SOAP. Wyciągany był podpis i identyfikowana była osoba. Po identyfikacji encja osoby była wysyłana do innego komponentu z którego można bylo potem ją pobrać już w trakcie przetwarzania żądania - na poziomie kontrolera.

Innym przypadkiem wykorzystania interceptora jest zbieranie statystyk i logów. Za pomocą interceptora możemy odkładać logi żądań a następnie wyświetlać je za pomocą zewnętrznego programu.

Jeszcze innym przykładem jest wykorzystanie intercaptora do wczytania odpowiedniej konfiguracji językowej.

### Pozostałe

#### Filtr `OncePerRequestFilter`

Jest to typ filtru który gwarantuje, że zostanie on wywołany tylko raz. W przypadku gdy w ramach przetwarzania żądania wywoływane są różne serwlety wtedy filtr może być wywołany kilka razy. Rozszerzając tą klasę możemy zapewnić, że zostanie to wykonane tylko raz w ramach żądania.

```java
public class AuthenticationFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws
            ServletException, IOException {
        String usrName = request.getHeader(“userName”);
        logger.info("Successfully authenticated user  " +
                userName);
        filterChain.doFilter(request, response);
    }
}
```

## Walidacja

Zależności

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency> 
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency> 
<dependency> 
    <groupId>com.h2database</groupId> 
    <artifactId>h2</artifactId>
    <version>1.4.197</version> 
    <scope>runtime</scope>
</dependency>
```

## WebFlux

Spring WebFlux to w pełni reaktywne środowisko, które zostało wprowadzone w Spring 5.0. Pozwala ono na wykorzystywanie strumieni reaktywnych przy zastosowaniu nieblokujących kontenerów webowych takich jak **Netty** lub **Undertow**.

Spring Boot 2 dostarcza pełne wsparcie dla programowania reaktywnego. Warto wspomnieć, że WebFlux bazuje na Project Reactor – czyli bibliotece służącej do programowania reaktywnego w Java. WebFlux dostarcza jedynie wygodne interfejsy i obsługę, która pozwala na wykorzystanie możliwości Reactor’a w Springu.
## Spring Boot
Spring Boot to projekt zbudowany na bazie frameworka Spring. Zapewnia prostszy i szybszy sposób konfigurowania i uruchamiania zarówno prostych, jak i złożonych aplikacji.

W ramach szkieletu Springa musisz skonfigurować wszystkie rzeczy. Dlatego możesz mieć wiele plików konfiguracyjnych, takich jak deskryptory XML. To jeden z głównych problemów, które rozwiązuje dla Ciebie Spring Boot.

Inteligentnie wybiera Twoje zależności, automatycznie konfiguruje wszystkie funkcje, których będziesz chciał używać i możesz uruchomić aplikację jednym kliknięciem. Ponadto upraszcza także proces wdrażania aplikacji.

Poniżej przykładowy schemat uruchomienia aplikacji za pomoca Spring Boot.

```java
package com.httpio.app;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

Dodanie adnotacji `SpringBootApplication` powoduje, że mechanizm String Boot uruchamia cały proces uruchomienia.

## Dev Tools
Jest to zbiór narzędzi za pomoca których możliwe jest skonfigurowanie Springa w taki sposób aby wszystkie zmiany były od razu widoczne na stronie WWW.

https://www.baeldung.com/spring-boot-devtools

https://www.vojtechruzicka.com/spring-boot-devtools
## Pliki właściwości i zmienne środowiskowe
Komponent `Environment` udostępnia metody za pomocą których można pobrać różnego rodzaju informacje związane z środowiskiem. Zmienne środowisko można podzielić na dwie grupy:

- na poziomie systemu,
- na poziomie aplikacji.

Na poziomie systemu są to zmienne środowiskowego takie jak: `PATH, CSPATH, color ...`. Na poziomie aplikacji zmienne zdefiniowane są za pomocą plików `*.properties`.

Zmienne środowisko pochodzące z systemu nadpisują zmienne zdefiniowane na poziomie aplikacji. Dzięki temu za pomocą zmiennych zdefiniowanych w systemie można nadpisać zmienne zdefiniowane na poziomie aplikacji.

Analogią do pliku z właściwościami są różnego rodzaju pliki konfiguracyjne w innych aplikacjach np. pliki typu `ini`.

Pliki z właściwościami powinny być zlokalizowane w katalogu: `src/main/resources`. Podstawowym plikiem właściwości jest `application.properties`. Jest to plik zaczytywany zawsze.

```properties
## Logging
logging.level=ERROR
logging.level.com.tooki=DEBUG
## logging.level.org.springframework.security=DEBUG
## ...
```

Istnieje również możliwość zdefiniowania dodatkowych plików z właściwościami które będą brane pod uwagę. Można to zrobić za pomocą adnotacji `@PropertySource` lub `@PropertySoruces` .

```java
@PropertySource("classpath:foo.properties")
@PropertySource("classpath:bar.properties")
public class PropertiesWithJavaConfig {
    //...
}

// Lub
@PropertySources({
    @PropertySource("classpath:foo.properties"),
    @PropertySource("classpath:bar.properties")
})
public class PropertiesWithJavaConfig {
    //...
}
```

Należy zwrócić uwagę również na to, że profil z jakim jest uruchamiana aplikacja determinuje to który plik zostanie zaczytany (podstawowy plik `application.properties` jest zawsze wczytywany).

Profil możemy ustawić za pomocą opcji `-Dspring.profiles.active=dev`. Dla takiego profilu zostanie wczytany doczytany plik `application-dev.properties`.

Adnotacja `@TestPropertySource`pozwala na zdefiniowanie jaki plik właściwości zostanie wczytany dla środowiska testowego.
### Poziomy odczytywanych właściwości
Spring Boot zaczytuje pliki właściwości z miejsc.

1. [Devtools global settings properties](https://docs.spring.io/spring-boot/docs/1.5.5.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-globalsettings) on your home directory (`~/.spring-boot-devtools.properties` when devtools is active).
2. [`@TestPropertySource`](https://docs.spring.io/spring/docs/4.3.10.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html) annotations on your tests.
3. [`@SpringBootTest#properties`](https://docs.spring.io/spring-boot/docs/1.5.5.RELEASE/api/org/springframework/boot/test/context/SpringBootTest.html) annotation attribute on your tests.
4. Command line arguments.
5. Properties from `SPRING_APPLICATION_JSON` (inline JSON embedded in an environment variable or system property)
6. `ServletConfig` init parameters.
7. `ServletContext` init parameters.
8. JNDI attributes from `java:comp/env`.
9. Java System properties (`System.getProperties()`).
10. OS environment variables.
11. A `RandomValuePropertySource` that only has properties in `random.*`.
12. [Profile-specific application properties](https://docs.spring.io/spring-boot/docs/1.5.5.RELEASE/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties) outside of your packaged jar (`application-{profile}.properties` and YAML variants)
13. [Profile-specific application properties](https://docs.spring.io/spring-boot/docs/1.5.5.RELEASE/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties) packaged inside your jar (`application-{profile}.properties` and YAML variants)
14. Application properties outside of your packaged jar (`application.properties` and YAML variants).
15. Application properties packaged inside your jar (`application.properties` and YAML variants).
16. [`@PropertySource`](https://docs.spring.io/spring/docs/4.3.10.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html) annotations on your `@Configuration` classes.
17. Default properties (specified using `SpringApplication.setDefaultProperties`).
### Odczytanie wartości
Do wartości tych właściwości możemy odwołać się na kilka sposób:

- za pomocą obiektu `org.springframework.core.env.Environment`,
- adnotacji `@ConfigurationProperties` która mapuje wartości na atrybuty,
- adnotacji `@Value` .
### Odczytanie za pomocą komponentu `Environment`
W poniższym przykładzie pobieram wartości za pomocą obiektu `Environment`.

```java
package com.tooki.api.controllers;

import com.tooki.api.services.TkLogger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

@RestController
@RequestMapping(value = "/tests")
public class TestsController {
    private Environment environment;

    @Autowired
    public void setEnvironment(Environment environment) {
        this.environment = environment;
    }

    @GetMapping("/get-properties")
    public HashMap<String, String> testGetProperties() {
        return new HashMap<String, String>(){{
            put("user", environment.getProperty("tk.endpoint.user"));
            put("password", environment.getProperty("tk.environment.password"));
        }};
    }
}
```
### Mapowanie z prefiksem
Jeśli chcemy aby mapowanie działało musimy dodać adnotację `@EnableConfigurationProperties`.

```java
@SpringBootApplication
@EnableConfigurationProperties
public class NoticeGeneratorApplication {
    public static void main(String[] args) {
        SpringApplication.run(NoticeGeneratorApplication.class, args);
    }
	// ...
}
```

Istnieje również możliwość mapowania właściwości na pola klasy. Służy do tego adnotacja @`ConfigurationProperties`.

```java
@Component
@ConfigurationProperties(prefix = "logger")
public class TkLogger {
    private String level;
    private String path;

    public TkLogger() { }

	// .. Gettery i Settery
}
```

Powyżej został zdefiniowany komponent `TkLogger` z adnotacją `@ConfigurationProperties`. Taki zapis powoduje, że wartości właściwości `logger.*` zostaną zmapowane na właściwości obiektu.

Następnie taki komponent może zostać użyty w dowolnym miejscu.

**UWAGA, przy odwoływaniu się przez np. komponenty lub obiekty typu POJO pobierana instancja nie może byc wstrzyknięta do metody (akcji) w przypadku kontrolera. Musi być wstrzyknięcia do kontrolera przez metodę.**

```java
    @GetMapping("/get-properties-by-mapping")
    public HashMap<String, String> testGetPropertiesByLogger(TkLogger tkLogger) {
        return new HashMap<String, String>(){{
            // put("level", environment.getProperty("logger.level"));
            // put("path", environment.getProperty("logger.path"));

            put("level", tkLogger.getLevel());
            put("path", tkLogger.getPath());
        }};
    }
```

Chodzi o wstrzyknięcie taki jak powyżej. Powoduje to, że w obiekcie nie zostaną przypisane wartości.

**Pisze o tym ponieważ spędziłem kilka godzin aby ustalić co działa nie tak.**
### Mapowanie całej konfiguracji
W powyższym przykładzie wykonane było mapowanie pewnej konfiguracji znajdującej się pod określonym kluczem, ale możemy też chcieć mapować wartość z całej konfiguracji. Wtedy po prostu nie podajemy prefiksu. 

```yaml
templates:
  -
    typ: "ogl_o_zm_ogl"
    versions:
      - "1.0.0"
templates2:
  ogl_o_zm_ogl:
    versions:
      - "1.0.0"
```

Mapujemy wtedy tak:

```java
@SuppressWarnings("ConfigurationProperties")
@Setter
@Getter
@Configuration
@ConfigurationProperties
public class TemplatesConfig {
    private List<TemplateConfig> templates;
    private Map<String, Object> templates2;

    public TemplatesConfig() {
    }

    @Data
    public static class TemplateConfig {
        private String type;
        private List<String> versions;
    }
}
```
### Pobranie wartości za pomocą `@Value`
Wartość właściwości można pobrać za pomocą adnotacji `@Value`. Używając w parametrze odpowiedni placeholder. W adnotacji umieszczamy `${tk.endpoint.user}`.

```java
@RestController
@RequestMapping(value = "/tests")
public class TestsController {
    @Value(value = "${tk.endpoint.user}")
    private String user;

    @Value(value = "${tk.endpoint.password}")
    private String password;

    @GetMapping("/get-properties-by-value")
    public HashMap<String, String> testGetPropertiesByValue() {
        return new HashMap<String, String>(){{
            put("user", user);
            put("password", password);
        }};
    }
}
```
### Mapowanie w metodzie `@Bean`
Istnieje możliwość przekazania właściwości do obiektu przy jego tworzeniu za pomocą metody oznaczonej przerez `@Bean`.

Tworzymy obiekt do którego zostanie wczytana konfiguracja.

```java
public class TkEndpointProperties {
    private String user;
    private String password;
    private List<String> permissions;

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public List<String> getPermissions() {
        return permissions;
    }

    public void setPermissions(List<String> permissions) {
        this.permissions = permissions;
    }

    @Override
    public String toString() {
        return "TkEndpointProperties{" +
                "user='" + user + '\'' +
                ", password='" + password + '\'' +
                ", permissions=" + permissions +
                '}';
    }
}
```

Następnie, definiujemy metodę tworzącą komponent.

```java
@Configuration
public class PropertiesConfiguration {

    @Bean
    @ConfigurationProperties(prefix = "tk.endpoint")
    public TkEndpointProperties tkEndpointProperties() {
        return new TkEndpointProperties();
    }
}
```

Metodę dekorujemy adnotacją `@ConfigurationProperties(prefix = "tk.endpoint")` oznacza to, że na zwróconej wartości zostaną ustawione właściwości.

Następnie np. w kontrolerze odwołujemy się do tworzonego obiektu.

```java
@RestController
@RequestMapping(value = "/tests")
public class TestsController {
    private TkEndpointProperties tkEndpointProperties;

    @Autowired
    public void setTkEndpointProperties(TkEndpointProperties tkEndpointProperties) {
        this.tkEndpointProperties = tkEndpointProperties;
    }

    @GetMapping("/get-properties-by-bean")
    public HashMap<String, String> testGetPropertiesByBean() {
        return new HashMap<String, String>(){{
            put("user", tkEndpointProperties.getUser());
            put("password", tkEndpointProperties.getPassword());
        }};
    }
}
```
## Webservices
Zależności:

```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web-services</artifactId>
</dependency>

<dependency>
	<groupId>wsdl4j</groupId>
	<artifactId>wsdl4j</artifactId>
</dependency>
```
## Konwertery
Springa udostępnia kilka narzędzi (w tym interfejs) do defniowania konwerterów.

```java
package org.springframework.core.convert.converter;

import org.springframework.lang.Nullable;

@FunctionalInterface
public interface Converter<S, T> {
    @Nullable
    T convert(S var1);
}
```
## Cache
Spring dostarcza generyczny mechanizm pamięci podręcznej który pełni rolę pośrednika między dostępnymi implementacjami takimi jak Enhance Cache czy CoffeCache. 

W Springu cache można podłączyć w dość elegancki sposób przy wywołaniu metody przez oznaczenie jej adnotacją `@Cacheable`.

### Komponent `CacheManager`
Za pośrednictwem tego komponentu możemy bezpośrednio wykonywać operacje.

```java
@Autowired
CacheManager cacheManager;

public void evictSingleCacheValue(String cacheName, String cacheKey) {
    cacheManager.getCache(cacheName).evict(cacheKey);
}

public void evictAllCacheValues(String cacheName) {
    cacheManager.getCache(cacheName).clear();
}
```

### Adnotacje
#### `@Cacheable`
Adnotacja mówi Springowi, że wynik metody ma zostać zapisany w pamięci podręcznej. Interpretowanie tej adnotacji odbywa się na poziomie wywołania metody i jest możliwe dzięki temu, że istnieje proxy.

```java
@Cacheable(value = "getNotificationEntityList")
public List<AdvisorRemarks> getNotificationEntityList() {
    return notificationEntityList;
}

@Cacheable(value = "getCacheAdvisorRemarks")
public List<AdvisorRemarks> getCacheAdvisorRemarks(final Set<String> userIds, final Boolean isCu) {}
```

Trzeba pamiętać, że kluczem do wpisu w pamięci podręcznej są też parametry wywołania. Czyli w powyższym przypadku mamy wpis z kluczem `getCacheAdvisorRemarks` z parametrami dla określonych użytkowników i flagą `isCu`.

#### `@CacheEvict`
Adnotacja pozwala na wyczyszczenie pamięci podręcznej. Możemy ją wywołać na kilka sposób.

```java
@Caching(
    evict = {
        @CacheEvict(value = "template", key = "#template.id"),
        @CacheEvict(value = "templates", allEntries = true)
    }
)
public void editTemplate(Template template) {}

@CacheEvict(value = "checkpointData", allEntries = true)
public void remove(String code){
    checkpointMapper.remove(code);
}
```

## Zdarzenia
Spring umożliwia nadsłuchiwanie i generowanie różnego rodzaju zdarzeń. Zdarzenia mogą pochodzić od Springa wtedy zdarzenia są emitowane z `ApplicationContext` lub być mogą być to zdarzenia niestandardowe.

https://www.baeldung.com/spring-events
### Emitowanie
Własne zdarzenie powinno być rozszerzeniem klasy `ApplicationEvent`.

```java
public class ReloadCacheEvent extends ApplicationEvent {
    private String message;

    public ReloadCacheEvent(Object source, String message) { /** ... */ }
    public String getMessage() { /** ... */ }
}
```

Następnie implementujemy komponent który będzie nadsłuchiwał nad tym zdarzeniem.

```java
// ...
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class ReloadCacheEventListener implements ApplicationListener<ReloadCacheEvent> {
    @Override
    public void onApplicationEvent(ReloadCacheEvent reloadCacheEvent) { /** ... */ }
}
```

Ważne jest aby implementował on interfejs `ApplicationListener` z odpowiednim typem oraz był komponentem. Aby zdarzenie wyemitować potrzebujemy `ApplicationEventPublisher`. Ten obiekt może być wstrzyknięty.

```java
@RestController
@RequestMapping(value = "/tests")
public class TestsController {
    private ApplicationEventPublisher applicationEventPublisher;

    @Autowired
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
    }

    @GetMapping("/emmit-reload-cache-event")
    public HashMap<String, String> emitReloadCacheEvent() {
        applicationEventPublisher.publishEvent(new ReloadCacheEvent(this, "Cache reloaded"));
		// ...
    }
}
```
### Obsługa zdarzeń
Możliwe jest również zdefiniowanie metody z adnotacją która obsłuży zdarzenie.

```java
@Component
public class AnnotationDrivenContextStartedListener {
    // @Async
    @EventListener
    public void handleContextStart(ContextStartedEvent cse) {
        System.out.println("Handling context started event.");
    }
}

// Nadsłuchowanie na kilku zdarzeniach
@EventListener(classes = { ContextStartedEvent.class, ContextStoppedEvent.class })
public void handleMultipleEvents() {
    System.out.println("Multi-event listener invoked");
}
```
#### Generyczne
```java
@Component
public class GenericSpringEventListener
  implements ApplicationListener<GenericSpringEvent<String>> {
    @Override
    public void onApplicationEvent(@NonNull GenericSpringEvent<String> event) {
        System.out.println("Received spring generic event - " + event.getWhat());
    }
}

// Lub przez adnotacje
@Component
public class AnnotationDrivenEventListener {
    @EventListener(condition = "#event.success")
    public void handleSuccessful(GenericSpringEvent<String> event) {
        System.out.println("Handling generic event (conditional).");
    }
}
```
#### JPA
Istnieje grupa zdarzeń związanych z JPA np. do obsługi transakcji.

- *AFTER_COMMIT* (default) is used to fire the event if the transaction has **completed successfully**
- *AFTER_ROLLBACK* – if the transaction has **rolled back**
- *AFTER_COMPLETION* – if the transaction has **completed** (an alias for *AFTER_COMMIT* and *AFTER_ROLLBACK*)
- *BEFORE_COMMIT* is used to fire the event right **before** transaction **commit**

```java
@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)
public void handleCustom(CustomSpringEvent event) {
    System.out.println("Handling event inside a transaction BEFORE COMMIT.");
}
```
#### Springowe
Sam Spring udostępnia duża listę zdarzeń które mogą być obsłużone. Kilka z nich:

- `ContextRefreshedEvent`,
- `ContextStartedEvent`,
- `ContextStoppedEvent`,
- `ContextClosedEvent`.
#### Asynchroniczne
W podstawowej konfiguracji wykonanie zdarzenia jest synchroniczne. Oznacza to, że np. jeśli mamy żądanie HTTP to przeglądarką będzie czekała aż wszystkie zdarzenia się wykonają. W przypadku obsługi asynchronicznej obsługa zdarzenia jest w innym wątku, wątek odpowiedzialny za obsługę żądania HTTP nie czeka aż zdarzenie zostanie wykonane, odpowiedź z przeglądarce jest natychmiastowa. Aby uruchomić obsługę zdarzeń asynchronicznych musimy zdefiniować komponent `ApplicationEventMulticaster`.

```java
// ...

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.event.ApplicationEventMulticaster;
import org.springframework.context.event.SimpleApplicationEventMulticaster;
import org.springframework.core.task.SimpleAsyncTaskExecutor;
import org.springframework.security.config.BeanIds;

@Configuration
public class EventsConfiguration {
    @Bean(name = "applicationEventMulticaster")
    public ApplicationEventMulticaster getApplicationEventMulticaster() {
        SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = new SimpleApplicationEventMulticaster();
        simpleApplicationEventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());

        return simpleApplicationEventMulticaster;
    }
}
```

Jest to prosta implementacja. W dużym uproszczeniu klasa `SimpleApplicationEventMulticaster` implementuje podstawowe metody. Natomiast `SimpleApplicationEventMulticaster` implementuje wywołanie, w tym przypadku jest to stworzenie wątku.

Spróbowałem zaimplementować własny mechanizm:

```java
@Override
public void multicastEvent(ApplicationEvent applicationEvent, ResolvableType resolvableType) {
    System.out.println("multicastEvent: " + applicationEvent);

    Iterator var5 = listeners.iterator();

    while(var5.hasNext()) {
        ApplicationListener<? super ApplicationEvent> listener = (ApplicationListener<? super ApplicationEvent>)var5.next();

        GenericApplicationListener g;

        if (!(listener instanceof GenericApplicationListener)) {
            g = new GenericApplicationListenerAdapter(listener);
        } else {
            g = (GenericApplicationListener) listener;
        }

        if (g.supportsEventType(resolvableType)) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    listener.onApplicationEvent(applicationEvent);
                }
            }).run();
        }
    }
}
```

Niestety nie udało się, po zaimplementowaniu zablokowałem kolejkę zdarzeń.
## Security
<https://docs.spring.io/spring-security/site/docs/5.2.1.BUILD-SNAPSHOT/reference/htmlsingle/>

Jest to moduł zawierający kontrakty (interfejsy) i mechanizmy związane z autentykacja, autoryzacja oraz inne wymagane do bezpiecznego przetwarzania zgłoszeń.

Jednym z podstawowych mechanizmów wykorzystywanym przez moduł są filtry servletów. Moduł wpina swój łańców filtrów do przetworzenia SpringSecurityFilterChain, gdzie przetwarzane są wszystkie procesy związane z bezpieczeństwem.

> The result is the same, another request for the same resource, but with credentials in proper HTTP Headers. This time Spring filters have a lot more to do. First, they extract credentials and use them to build Authentication object that acts as input for further processing. This Authentication is passed to AuthenticationManager that asks its configured and attached AuthenticationProviders, if any of them can process such type of Authentication (UsernamePasswordAuthentication). By default, there is such provider for Basic and it will query UserDetailsService for UserDetails object corresponding for such username. This UserDetails will then be validated against password and if everything is present, matches and is otherwise correct, new output Authentication object will be created. This output object is marked as successfully authenticated and filled with GrantedAuthorities that corresponds to the roles assigned to this particular user.
>
> Where are UserDetails taken from? It depends on configuration. It can be obtained from memory or from database or webservice call – it’s up to your implementation of UserDetailsService.
>
> So we have authenticated Authentication. The filter that initiated this operation will put this Authentication to SecurityContextHolder and pass the request down to the next filters. Any further filters will check if SecurityContextHolder holds valid Authentication and use GrantedAuthorities to do authorization validation. The same goes for AOP extended methods of our controllers (if we decide to use this approach).

Drugim ważnym elementem jest `SecurityContext`. Jest to obiekt który przetrzymuje autentykacyjne wpraz z uprawnieniami.
### Konfiguracja
Tworzymy klasę rozszerzerzającą `WebSecurityConfigurerAdapter`. Oznaczamy ją adnotacją `@Configuration`.

```java
import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.web.configuration.*;
import org.springframework.security.core.userdetails.*;
import org.springframework.security.provisioning.*;

@EnableWebSecurity
public class WebSecurityConfig {

    // @formatter:off
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("password")
            .roles("USER")
            .build();
        return  new InMemoryUserDetailsManager(user);
    }
    // @formatter:on
}
```

Implementując metody wprowadzamy konfigurację. Aby uruchomić mechanizm musimy dodać również adnotację `@EnableWebSecurity`.

Spring Security zarejestruje `springSecurityFilterChain` przez który będą przechodzić wszystkie zadania.

Poniżej kilka przykładowych konfiguracji:

```java
protected void configure(HttpSecurity http) throws Exception {
        // Wyłączam CSRF - Cross-site request forgery
        http.csrf().disable();

        // Uwstaienia dla CORS - Cross-Origin Resource Sharing
        http.cors().disable();

        // http.headers().addHeaderWriter()

        http.authorizeRequests()
            .antMatchers(HttpMethod.GET, "/template-a")
            .authenticated()
        ;

        // wymagane jest rola USER aby wejść na /template-b
        http.authorizeRequests()
            .antMatchers(HttpMethod.GET, "/template-b")
            .hasRole("USER")
        ;

        // Nie tworzymy sesji
        http.sessionManagement()
           .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        ;

        http.addFilterAfter(new SimpleFilter(), BasicAuthenticationFilter.class);
}

```

Jest kilkanaście metod które pozwalają na zdefiniowanie uprawnienia: `hasRole, hasAnyRole, hasAuthority, hasAnyAuthority, hasIpAddress, permitAll, anonymous, rememberMe, denyAll, authenticated, fullyAuthenticated, access`

Obiekt `HttpSecurity` posiada wiele metod pozwalających na wprowadzenie konfiguracji: `openidLogin, headers, cors, sessionManagement, portMapper, jee, x509, rememberMe, authorizeRequests, requestCache, exceptionHandling...`.
### Autentykacja
#### Kontekst (SecurityContextHolder)
`SecurityContextHolder` jest to przestrzeń w której przechowywane sa dane autentykacyjne. Wewnętrznie jest do tego wykorzysywany ``ThreadLocal` . Ale nie zawsze tak musi być.  Można to zmienić ustawieniami: `SecurityContextHolder.MODE_GLOBAL, MODE_INHERITABLETHREADLOCAL, MODE_THREADLOCAL`

Dostęp do kontenera uzykujemy przez wywołanie `getContext`:

```java
Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

if (principal instanceof UserDetails) {
	String username = ((UserDetails)principal).getUsername();
} else {
	String username = principal.toString();
}
```
#### Dane (UserDetails)
Po udanej autencykacji toworzony jest obiekt z danymi użytkownika. Utworzony obiekt powinien implementować interfejs `UserDetails`, ponieważ jest on wymagany w kontekście `SecurityContextHolder`. Na ogół w aplikacji jest to rzutowany (konwertowany) na obiekt aplikacji np. User.

Po udanej antykadencji obiekt `UserDetails` jest tworzony przez `UserDetailsService`. Jest to interfejs z jedna metod `UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException` której zadaniem jest utworzenie obiektu `UserDetails`.


#### Filtry
![1571255499115](../../../.files/1a5594bc-d708-46d9-a189-57a142bd0d1e.png)

Zgłoszenie przechodzi przez łańcuch filtrów. Każdy filtr może przekształcić zgłoszenie i przekazać je danej.

Poniżej przykład prostego filtru.

```java
public class SimpleFilter extends GenericFilterBean {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        servletRequest.setAttribute("valueFromFilter", "123");

        filterChain.doFilter(servletRequest, servletResponse);
    }
}
```

Filtr powinien rozszerzać `GenericFilterBean`. Implementujemy metodę `doFitler`. Metoda otrzymuje trzy parametry. Podstawowy `Request`, podstawowy `Response` oraz referencje do łańcucha kolejnych wywołań.

Następnie w konfiguracji rejestrujemy filtr.

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {

        http.authorizeRequests()
            .antMatchers(HttpMethod.GET, "/template-a")
            .authenticated()
        ;

        http.addFilterAfter(new SimpleFilter(), BasicAuthenticationFilter.class);
    }
}
```

Tak zarejestrowany filtr będzie wywoływany. Filtr jest ogólny, wiec Spring nie wie w jakiej kolejności powinien być wywołany, dlatego definiujemy po jakim filtrze ma się wywołać `BasicAuthenticationFilter`.

Jeśli nasz filtr implementował by jakis z standardowych fitrów Springa to nie było by konieczne określanie kolejności.

> - *addFilterBefore(filter, class) –* adds a *filter* before the position of the specified filter *class*
> - [*addFilterAfter(filter, class)*](https://docs.spring.io/spring-security/site/docs/5.0.0.M5/api/org/springframework/security/config/annotation/web/builders/HttpSecurity.html#addFilterAfter(javax.servlet.Filter,%20java.lang.Class)) – adds a *filter* after the position of the specified filter *class*
> - [*addFilterAt(filter, class)*](https://docs.spring.io/spring-security/site/docs/5.0.0.M5/api/org/springframework/security/config/annotation/web/builders/HttpSecurity.html) – adds a *filter* at the location of the specified filter *class*
> - [*addFilter(filter)*](https://docs.spring.io/spring-security/site/docs/5.0.0.M5/api/org/springframework/security/config/annotation/web/builders/HttpSecurity.html#addFilter(javax.servlet.Filter)) – adds a *filter* that must be an instance of or extend one of the filters provided by Spring Security

W wyniku tej operacji możemy w kontrolerze odwołać się do wartości.

```java
@Controller
public class IndexController {
    @GetMapping(value = "/")
    public String get(WebRequest request, Model model) {

        model.addAttribute("valueFromFilter", request.getAttribute("valueFromFilter", 0));

        return "home";
    }
}
```

Oczywiście jest to prosty przypadek.

**Spring posiada wbudowane filtry które pozwalają np. na wyciągnięcie danych autoryzacyjnych i przetwarzanie zgłoszenia i odpowiedzi.**
#### Autentykacja
![1571262615327](../../../.files/1a5594bc-d708-46d9-a499-67a142bd0d13.gif)
##### Analiza
W Springu na proces autentykacji skalda się kilka procesów.

W pierwszym etapie uruchamiany jest `UsernamePasswordAuthenticationFilter` jest to rozszerzenie ogólnego filtru `AbstractAuthenticationProcessingFilter`.

`AbstractAuthenticationProcessingFilter` jest to podstawowa implementacja filtru do definiowania danych autoryzacyjnych.

W metodzie `doFilter` mamy:

```java
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest)req;
    HttpServletResponse response = (HttpServletResponse)res;

    if (!this.requiresAuthentication(request, response)) {
        chain.doFilter(request, response);
    } else {
        // ...

        Authentication authResult;

        try {
            authResult = this.attemptAuthentication(request, response);

            if (authResult == null) {
                return;
            }

            // ...
        } catch (InternalAuthenticationServiceException var8) {
            // ...
        } catch (AuthenticationException var9) {
            // ...
        }

        // B
        this.successfulAuthentication(request, response, chain, authResult);
    }
}
```

Metoda `attemptAuthentication` deleguje proces do konkretnej implementacji np. `UsernamePasswordAuthenticationFilter` którego zadaniem jest odczytanie nazwy i hasła.

```java
public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
    if (this.postOnly && !request.getMethod().equals("POST")) {
        throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());
    } else {
        String username = this.obtainUsername(request);
        String password = this.obtainPassword(request);

        if (username == null) {
            username = "";
        }

        if (password == null) {
            password = "";
        }

        username = username.trim();

        // A
        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);

        this.setDetails(request, authRequest);

        return this.getAuthenticationManager().authenticate(authRequest);
    }
}
```

W linijce `A` tworzony jest konkretny obiekt `Authentication` . Ten obiekt jest przekazywany dalej do obiektu `AuthenticationManger` jest to obiekt zawierający wszystkie usługi autentykujące które na podstawie obiektu `Authentication` sprawdzają czy dane są poprawne.

Jeśli autentykacja się powiodła to obiekt `Authenticate` jest przenoszony do `SecurityContext`. Po wykonaniu metody `B`.

```
SecurityContextHolder.getContext().setAuthentication(authResult);
```
### Apache Shiro
Jest to alternatywne rozwiązane dla Spring Security. Dostarcza mechanizmów do autentykacji i autoryzacji, zarządzania sesją i rozwiązań kryptograficznych.

https://shiro.apache.org
## Session
Ogólnie protokół HTTP jest protokołem bez stanowym. Oznacza to, że poszczególne żądania są od siebie niezależne. Mechanizm sesji można zaimplementować za pomocą kilku mechanizmów:

- Cookies
- Hidden form field
- URL Rewriting
- HttpSession.

Podstawowa implementacja sesji przechowuje dane w pamięci.

![1570478613108](../../../.files/1a5594bc-d708-46d9-a199-67a142bd0d13.gif)

Dane z sesji można pobrać za pocą `HttpSession`. Instancja może zostać pobrana przez wstrzykniecie do kontrolera przez metodę lub pole.

```java
@RestController
public class Meetings {
    @Autowired
    TkMeetingRepo tkMeetingRepo;

    @Autowired
    Counter counter;

    @Autowired
    HttpSession httpSession;

    // @RequestMapping(value = "/logs", method= RequestMethod.POST)
    @PostMapping(value = "/meetings")
    public Meeting post(
        @RequestParam(value="typeId",  required = false) String typeId,
        @RequestParam(value="latitude", required = false) String latitude,
        @RequestParam(value="longitude", required = false) String longitude
    ) {
		// ...

        if (httpSession.getAttribute("test") == null) {
            httpSession.setAttribute("test", "123");
        }
		// ...
    }
}
```

Spring generuje nagłówek `Set-Cookie` .

```http
Transfer-Encoding: chunked
Set-Cookie: JSESSIONID=F6D1B54EA0175FED2F779E6E7500504F; Path=/; HttpOnly
Date: Mon, 07 Oct 2019 20:21:50 GMT
Content-Type: application/json;charset=UTF-8

```
### Moduły
- **Spring Session Core -** podstawowe API,
- **Spring Session Data Redis -** provides SessionRepository and ReactiveSessionRepository implementation backed by Redis and configuration support
- **Spring Session JDBC -** provides SessionRepository implementation backed by a relational database and configuration support
- **Spring Session Hazelcast -** provides SessionRepository implementation backed by Hazelcast and configuration support.
### Sesja za pomocą JDBC
Dane z sesji są przetrzymywane w bazie danych.
## SpEL
Spring Expression Language to język wyrażeń, który obsługuje zapytania i manipulowanie grafem obiektowym w czasie wykonywania. Można go używać z konfiguracjami opartymi na XML lub adnotacjach.

Wspiera operacje:

| **Type**    | **Operators**                                |
| ----------- | -------------------------------------------- |
| Arithmetic  | +, -, *, /, %, ^, div, mod                   |
| Relational  | <, >, ==, !=, <=, >=, lt, gt, eq, ne, le, ge |
| Logical     | and, or, not, &&, \|\|, !                    |
| Conditional | ?:                                           |
| Regex       | matches                                      |

Wyrażenie powinno być umieszczone w `#{...}`, w ramach wyrażenie możemy odwoływać się do innych wartości przez składnię `${...}`.

Np. jeśli chcemy zsumować wartość właściwości oraz liczy 2.

```
##{${someProperty} + 2}
```
### Różne operacje arytmetyczne
```
##{19 + 1}
##{'String1 ' + 'string2'}
##{20 - 1}
##{10 * 2}
##{36 / 2}
##{36 div 2}
##{37 % 10}
##{37 mod 10}
##{2 ^ 9}
```
### Operacje logiczne
```
##{1 == 1}
##{1 eq 1}
##{1 != 1}
##{1 ne 1}
##{1 < 1}
##{1 lt 1}
##{1 <= 1}
##{1 le 1}
##{1 > 1}
##{1 gt 1}
##{1 >= 1}
##{250 > 200 && 200 < 4000}
##{250 > 200 and 200 < 4000}
##{400 > 300 || 150 < 100}
##{400 > 300 or 150 < 100}
##{!true}
```
### Operacje warunkowe
```
// Warunek logiczny
##{2 > 1 ? 'a' : 'b'}

// Odwołanie się do właściwości komponentu
##{someBean.someProperty != null ? someBean.someProperty : 'default'}

// Elvis operator
##{someBean.someProperty ?: 'default'}
```
### Wyrażenia regularne
```
##{'100' matches '\\d+' }
##{'100fghdjf' matches '\\d+' }
##{'valid alphabetic string' matches '[a-zA-Z\\s]+' }
##{'invalid alphabetic string #$1' matches '[a-zA-Z\\s]+' }
##{someBean.someValue matches '\d+'}
```
### Operacje na listach
SpEL, umożliwia również odczytywanie elementów `List` i `Map`.

Jeśli mamy zdefiniowany komponent.

```java
@Component("workersHolder")
public class WorkersHolder {
    private List<String> workers = new LinkedList<>();
    private Map<String, Integer> salaryByWorkers = new HashMap<>();

    public WorkersHolder() {
        workers.add("John");
        workers.add("Susie");
        workers.add("Alex");
        workers.add("George");

        salaryByWorkers.put("John", 35000);
        salaryByWorkers.put("Susie", 47000);
        salaryByWorkers.put("Alex", 12000);
        salaryByWorkers.put("George", 14000);
    }

    // Getters and setters
}
```

Odebranie tych elementów

```
##{workersHolder.salaryByWorkers['John']}
##{workersHolder.salaryByWorkers['George']}
##{workersHolder.salaryByWorkers['Susie']}
##{workersHolder.workers[0]}
##{workersHolder.workers[3]}
##{workersHolder.workers.size()}
```
### ExpressionParser
 https://www.baeldung.com/spring-expression-language#1-using-expressionparser

```java
ExpressionParser expressionParser = new SpelExpressionParser();
Expression expression = expressionParser.parseExpression("'Any string'");
String result = (String) expression.getValue();

//
Expression expression = expressionParser.parseExpression("'Any string'.length()");
Integer result = (Integer) expression.getValue();

//
Expression expression = expressionParser.parseExpression("new String('Any string').length()");

//
Expression expression = expressionParser.parseExpression("'Any string'.bytes");
byte[] result = (byte[]) expression.getValue();

//
Expression expression = expressionParser.parseExpression("'Any string'.replace(\" \", \"\").length()");
Integer result = (Integer) expression.getValue();

//
Integer result = expression.getValue(Integer.class);

//
Car car = new Car();
car.setMake("Good manufacturer");
car.setModel("Model 3");
car.setYearOfProduction(2014);

ExpressionParser expressionParser = new SpelExpressionParser();
Expression expression = expressionParser.parseExpression("model");

EvaluationContext context = new StandardEvaluationContext(car);
String result = (String) expression.getValue(context);

//
Expression expression = expressionParser.parseExpression("model");
String result = (String) expression.getValue(car);

//
Expression expression = expressionParser.parseExpression("yearOfProduction > 2005");
boolean result = expression.getValue(car, Boolean.class);
```
## Dependence Injection - DI
Wstrzykiwanie zależności jest jednym z podstawowych mechanizmów w Springu.

W rozdziale w którym opisywałem architekturę zwróciłem uwagę, że podstawowym elementem są komponenty czyli tgzn. Beans.

DI głównie operuje na tego typu obiektach, tworzy je, przekazuje do innych komponentów.

Jeśli korzystamy z Spring Boota wymagane jest oznaczenie komponentów adnotacja `@Component`  lub którąś z rozszerzających (`Service, Controller, RestController, Repository ...`) do tego aby klasy zostały zarejestrowane jako komponenty i mogłby być wstrzyknięcie.

Adnotacja `@Component` jest ogólna adnotacją. Istnieją również `@Service`, `@Repository` i `@Controller` które są specyficznymi typami komponentów.

Istnieje również adnotacja `@ComponentScan`, uruchamia ona mechanizm skanowania komponentów. Jest ona dodawana razem z adnotacją `@SpringBootApplication`.

W konfiguracji bez wykorzystania Spring Boota (np. gdy sami tworzymy SpringApplicationContext) konfiguracja jest zdefiniowana w pliku np. `beans.xml`.
### Wstrzykiwanie zależności `@Autowired`
Spring umożliwia wstrzykiwanie zależności przez konstruktor, metodę lub pole. Adnotacja `@Autowired` umożliwia na oznaczenie w jaki sposób zależność ma być dostarczona.

```java
public class UserEntity {
    private ServiceA serviceA;
    private ServiceB serviceB;

    @Autowired
    public ServiceC serviceC;

    public UserEntity(ServiceA serviceA) {
        this.serviceA = serviceA;
    }

    @Autowired
    public void setServiceB(ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}
```

Powyżej mamy przykład wstrzyknięcia przez konstruktor, metodę, pole. Jeśli chcemy aby obiekt został wstrzyknięty przez pole lub metodę to musi zostać znaczony adnotacją `@Autowired`. W przypadku konstruktora nie jest to konieczne.

Zależność możemy oznaczyć jako opcjonalną, wtedy `@Autowired(required = false)`.
### Kwalfikator `@Qualifier`
Ogólnie Spring bez problemu wstrzykuje zależności na podstawie typu obiektu. Problem powstaje w momencie gdy chcemy wstrzyknąć komponent na postawie interfejsu, a ten interfejs jest implementowany przez kilka komponentów. Wtedy kontener zależności nie wie do której się ma odwołać.

```java
@Component
public class FilesLogger implements Logger {}

@Component
public class SimpleLogger implements Logger {}
```

W takiej sytuacji nie można odwołać się do komponentu ponieważ `Logger` jest niejednoznaczny. Aby to naprawić musimy w trakcie odwoływania się do metody zdefiniować kwalfikator.

```java
@Autowired
public void setLogger(@Qualifier("simpleLogger") Logger logger) {
    this.logger = logger;
}
```

Standardowa nazwa to nazwa klasy z małej litery. Kwalifikator można zdefiniować przy definiowaniu komponentu lub przy konfiguracji.

```java
@Component("logger")
public class SimpleLogger implements Logger {
}

// Lub w konfiguracji
@Configuration
public class LoggingConfiguration {

    @Bean(name = "logger")
    public Logger logger() {
        return new SimpleLogger();
    }
}
```
Spring pozwala na stworzenie własnego kwalifikatora.

```java
@Qualifier
@Target({
  ElementType.FIELD, ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface FormatterType {
    String value();
}

@FormatterType("Foo")
@Component
public class FooFormatter implements Formatter {

    public String format() {
        return "foo";
    }
}

@FormatterType("Bar")
@Component
public class BarFormatter implements Formatter {

    public String format() {
        return "bar";
    }
}

@Component
public class FooService {

    @Autowired
    @FormatterType("Foo")
    private Formatter formatter;

}
```

**Jeśli kwalifikator jest niezdefiniowany to podstawowym kwalifikatorem jest nazwa pola/parametru.**

```java
public class FooService {

    @Autowired
    private Formatter fooFormatter;

}
```

W powyższym przykładzie kwalifikatorem jest `fooFormatter`. Czyli jest to jednoznaczne z napisaniem `@Qualifier("fooFormatter")`.
### Komponent podstawowy `@Primary`
W przypadku gdy dany komponent (Beans) jest  implementowany przez kilka klas (pobieramy przez interfejs) to możliwe jest zdefiniowanie podstawowe komponentu które zostanie użyty. Służy do tego adnotacja `@Primary`.

```java
@Component
@Primary
public class FilesLogger implements Logger { }

@Component
public class SimpleLogger implements Logger { }
```

Więc jeśli odwołujemy się do komponentu przez niejednoznaczny identyfikator np. interfejs.

```java
@Autowired
public void setLogger(Logger logger) {
    this.logger = logger;
}
```

To możemy oznaczyć komponent adnotacją `@Primary` wtedy zostanie on wybrany jako podstawowy. W innym przypadku mieliśmy konflikt i musielibyśmy użyć kwalifikatora aby wskazać który konkretnie chcemy komponent.

Adnotacja `@Primary` jest użyteczna, jednak lepiej używać `Qualifier` ponieważ jasno pokazuje jakie są intencję.
### Profile `@Profile`
Kontener zależności umożliwia definiowanie komponentów  w ramach określonego profilu. Jeśli np. mamy kilka komponentów to możemy zdefiniować aby określone komponenty były widoczne tylko gdy jest aktywny określony profil.

```java
@Component
@Profile("production")
public class DatabaseLogger implements Logger {
    @Override
    public String toString() {
        return "DatabaseLogger";
    }
}

@Component
@Profile("testing")
public class FilesLogger implements Logger {
    @Override
    public String toString() {
        return "FilesLogger";
    }
}

@Component
@Profile("development")
public class SimpleLogger implements Logger {
    @Override
    public String toString() {
        return "SimpleLogger";
    }
}
```

Profil jest ustawiany za pomocą adnotacji `@Profile(...)`. Z którym profile ma się uruchomić aplikacja ustawiamy w `application.properties` opcją `spring.profiles.active=production`.

Możliwe jest również zdefiniowanie kilu profili. Wtedy w adnotacji ustawiamy parametry w nawiasach `{}`.

```java
@Component
@Profile({"production", "default"})
public class DatabaseLogger implements Logger {
    @Override
    public String toString() {
        return "DatabaseLogger";
    }
}
```
## AOP
Spring wspiera tgz. paradygmat programowania aspektowego. To podejście polega na tym, że pewne zagadnienia (aspekty) wspólne dla wszystkich komponentów systemu. Takie procesy nazywane są crosscutting i są to np.:

- mechanizm logów,
- profilowania,
- transakcji,
- uprawnień.

W Springu aspekty są realizowane za pomocą pośrednictwem obiekty proxy używane przy wstrzykiwaniu zależności. 

**Uwaga, istnieje również implementacja AspectJ która może mieć inne adnotacje, ale koncept jest podobny.**
### Zależności
```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.4.0</version>
</parent>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
</dependencies>
```
### Pojęcia
| Pojęcie      | Opis                                                         |
| ------------ | ------------------------------------------------------------ |
| Aspect       | Wspomniana na początku modularyzacja problemu obejmującego (przecinającego) wiele klas.<br />**Spring AOP**: Realizacja przez użycie regularnych klas, bądź klas adnotowanych @AspectJ. |
| JoinPoint    | Punkt podczas wykonywania programu, w którym następuje wykonanie metody lub obsługa wyjątku.<br />**Spring AOP**: Realizacja przez wyznaczenie punktu na wykonaniu metody (zawsze). |
| Advice       | Moment działania aspektu (określony przez punkt połączenia), taki jak: dookoła (around), przed (before), po (after).<br/>Na przykład: dookoła wywołania metody, przed wykonaniem metody, po wykonaniu metody.<br />**Spring AOP**: Realizacja przez przechwycenie (interception) właściwego momentu działania wraz<br/>z utrzymaniem łancucha interceptorów zgromaczonych wokół punku złączenia. |
| Pointcut     | Warunek określający wystąpienie punktu złączenia, w którym należy uruchomić odpowiednią poradę.<br />**Spring AOP**: Realizacja przez użycie wyrażeń punktów języka AspectJ. |
| Introduction | Deklarowanie dodatkowych metod lub pól w imieniu typu, które mogą być pomocne podczas stosowania porady.<br />**Spring AOP**: Realizacja pojęcia umowy między typami w ramach AspectJ. |
| TargetObject | Obiekt, któremu "doradza" przynajmniej jeden obiekt (posiada przynajmniej jedną poradę).<br />**Spring AOP**: Realizacja poprzez użycie proxy (wspomniany obiekt jest zawsze obiektem proxy). |
| AOP proxy    | Obiekt stworzony w celu implementacji umów aspektu (sposobów doradzania w kontekście wykonywania metody)<br />**Spring AOP**: Realizacja poprzez dynamiczne proxy JDK lub proxy CGLIB. |
| Weaving      | Łączenie aspektów w określonym czasie z obiektami w celu utworzenia obiektu posiadającego poradę.<br />**Spring AOP**: Realizacja wsytępuje w czasie wykonywania kodu (runtime). |
### Adnotacje
| Adnotacja         | Działanie                                                    |
| ----------------- | ------------------------------------------------------------ |
| `@Before`         | Aspekt jest uruchamiany przed wywołaniem metody tgz. `JoinPoint`. |
| `@After`          | Aspekt jest uruchamiany po wykonaniu w trybie normalnym lub z wyjątkiem. |
| `@AfterReturning` | Aspekt jest uruchamiany po wykonaniu w trybie normalnym lub z wyjątkiem. |
| `@AfterThrowing`  | Aspekt jest uruchamiany po wykonaniu z wyjątkiem.            |
| `@Around`         | Pozwala na wykonanie aspektu w kontekście całego wykonania metody. Przed i po jest to w pewnym sensie połączenie `@Before` i `@After` |
### Przypadek użycia XML
Jest to mniej popularny sposób podpinania aspektów opierający się na konfiguracji XML.

```xml
<bean id="sampleAdder" class="org.baeldung.logger.SampleAdder" />
<bean id="doAfterReturningAspect" 
  class="org.baeldung.logger.AdderAfterReturnAspect" />
<aop:config>
    <aop:aspect id="aspects" ref="doAfterReturningAspect">
       <aop:pointcut id="pointCutAfterReturning" expression=
         "execution(* org.baeldung.logger.SampleAdder+.*(..))"/>
       <aop:after-returning method="afterReturn"
         returning="returnValue" pointcut-ref="pointCutAfterReturning"/>
    </aop:aspect>
</aop:config>
```
### Przypadek użycia adnotacje
Aspekt możemy przyłączyć np. do metody która jest oznaczona odpowiednią adnotacją. 

```java
package spring5aop.aspects;

@Aspect
@Component
@Slf4j
public class MeasureTimeAspect {

    @Around("@annotation(MeasureTime)")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        // ...
    }
}
```

Wtedy do metody dodajemy adnotację:

```java
// ...

@Service
public class UserServiceImpl implements UserService {
	// ...

    @Override
    @MeasureTime
    public User findById(String id) {
		// ...
    }
}
```

Wywołanie aspekty możemy zdefiniować odpowiednim wyrażeniem.

```java
package pl.aspect; 
 
@Aspect
@Component
public class LoggingAspect {
    @Around("execution(* pl.nullpointerexception.aspect..*(..))") // 2
    public Object doSomethingAdvice(ProceedingJoinPoint joinPoint) throws Throwable { // 3
        System.out.println(":: start ::"); // 4
        Object proceed = joinPoint.proceed(); // 5
        System.out.println(":: end ::"); // 6
        return proceed; // 7
    }
}
```

## Moduły
### Spring Metrics
Spring udostępnia komponent Spring Metrics

https://docs.spring.io/spring-metrics/docs/current/public/prometheus#quickstart

## Messages
Jest to moduł Springa służący do zażądania komunikatami. Wspiera parametryzacja i komunikaty w wielu językach (**i18n**). Podstawowym komponentem który zwraca treści wiadomości jest `MessageSource`, ma on dwie podstawowe implementacje:

- `ResourceBundleMessageSource` (wymaga rekompilacji),
- `ReloadableResourceBundleMessageSource` (nie wymaga rekompilacji).

Standardowo komunikaty są przechowywane w zasobach. Podstawowy plik za komunikatami to `src/main/resources/messages.properties`, następnie w zależności od języka jest wczytywany plik `messages{kod-jezyka}.properties`. Kodem może być: `_en_US`, lub `en`. W zależności od tego jakie parametry zostana ustawione.

> 1. For this `messageSource` definition, if you look up a text message for the United States locale, whose preferred language is English, the resource bundle `messages_en_US.properties`, which matches both the language and country, will be considered first.
> 2. If there’s no such resource bundle or the message can’t be found, the one `messages_en.properties` that matches the language only will be considered.
> 3. If this resource bundle still can’t be found, the default `messages.properties` for all locales will be chosen finally.

Komunikat można odczytać bezpośrednio z `MessageSource`.

```java
@Controller
@RequestMapping("/learning/messages")
@Component("learningMessagesIndexController")
public class IndexController {
    private MessageSource messageSource;

    public IndexController(MessageSource messageSource) {
        this.messageSource = messageSource;
    }

    @RequestMapping("")
    @ResponseBody
    public String index(ServletRequest servletRequest) {
        System.out.println("-- Learning messages --");

        System.out.println(messageSource.getMessage("common.hello-world", null, Locale.forLanguageTag("de")));
        System.out.println(messageSource.getMessage("common.hello-world", null, Locale.forLanguageTag("pl")));
        System.out.println(messageSource.getMessage("common.hello-world", null, Locale.forLanguageTag("en")));

        return "end";
    }
}
```

Komponent możemy również uzuskać za pomocą interfejsu `MessageSourceAware`.

W komunikatach możemy również osadzić miejsca na dynaczmine wartości (placeholdery).

```
common.hello-world=Hello, {0}!
```

Następnie przy pobieraniu

```java
return messageSource.getMessage("common.hello-world", new Object[]{"Paweł"}, Locale.forLanguageTag("de"));
```
### Konfiguracja
Standardowo pliki komunikatów są przeszukiwane w `classpath`. Stąd w podstawowej konfiguracji pliki są umieszczone bezpośrednio w zasobach (resources są przenoszone bezpośrednio w classes).

Istnieją opcje które pozwalają na zmianę tego zachowania `spring.messages.basename`:

```properties
## INTERNATIONALIZATION (MessageSourceAutoConfiguration)
## Comma-separated list of basenames, each following the ResourceBundle convention.
spring.messages.basename=messages
## Loaded resource bundle files cache expiration, in seconds. When set to -1, bundles are cached forever.
spring.messages.cache-seconds=-1
## Message bundles encoding.
spring.messages.encoding=UTF-8
## Set whether to fall back to the system Locale if no files for a specific Locale have been found.
spring.messages.fallback-to-system-locale=true
```
### Konfigurowanie `ReloadableResourceBundleMessageSource`
```java
@Bean
public MessageSource messageSource() {
    ReloadableResourceBundleMessageSource messageSource
      = new ReloadableResourceBundleMessageSource();

    messageSource.setBasename("classpath:messages");
    messageSource.setDefaultEncoding("UTF-8");
    return messageSource;
}
```
### Podpiecie pod komunikaty walidacyjne
```java
@Bean
public LocalValidatorFactoryBean getValidator() {
    LocalValidatorFactoryBean bean = new LocalValidatorFactoryBean();
    bean.setValidationMessageSource(messageSource());
    return bean;
}
```
## Data
### Inicjowanie danych
SpringBoot posiada mechanizm który pozwala na zainicjowanie danych. Baza danych jest inicjowana na podstawie plików `schema.sql, data.sql` znajdujące się w classpath.

SpringBoot również wczytuje `schema-${platform}.sql, data-${platform}.sql`. Platforma jest ustawiona `spring.datasource.platform`
### Hibernate
Hibernate jest podstawowe źródło danych wykorzystuje bibliotekę Hibernate. Spring w podstawowej konfiguracji obsługuje bazę `H2`. Jest to baza relacyjna. Jeśli chcemy skorzystać z bazy `MySQL` musimy zdefiniować konfigurację.
### Konfiguracja
W pliku `src/main/resources/application.properties` wprowadzamy ustawienia do bazy danych.

```java
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:3306/db_example
spring.datasource.username=springuser
spring.datasource.password=ThePassword
```

`spring.jpa.hibernate.ddl-auto` - określa poziom uprawnień frameworka `Hibernate` do wykonywania poleceń `DDL`. Są to wartości `none, update, create, create-drop, validate`. W środowisku produkcyjnym powinno się używać `validate`.

Spring w podstawowej konfiguracji używa `create-drop` dla takich baz jak `hsql, h2, derby`.
### H2
Jest to baza relacyjna napisana w Javie. Może działać w pamięci.
#### Konfiguracja
Aby uruchomić konsolę ustawiamy właściwości:

```properties
spring.h2.console.enabled=true

spring.datasource.initialize=true
spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=- 1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
    
## Inna przykładowa konfiguracja
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.initialize=true
spring.datasource.password=
spring.datasource.url=jdbc:h2:file:~/test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;AUTO_SERVER=TRUE spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=- 1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.username=sa
spring.h2.console.enabled=true

```

Następnie pod adresem `http://localhost:8080/h2-console` wyświetla mi się panel logowania.

![1573930834032](../../../.files/1a5494bc-d708-46d9-a199-57a142bd0d3f.gif)
### Repozytoria danych
Repozytoria danych w springu wywodzą się z koncepcji repozytoriów z DDD. Repozytorium danych dostarcza podstawowe metody działania na obiektach danych (encjach).

Sama koncepcja repozytorium wywodzi się z metodologii Domain Driven Design. Mówi ona o tym, że repozytorium jest usługą (miejscem) z którego można pobrać różnego rodzaju encję (obiekty domenowe).

Repozytorium jako koncepcja jest niezależne od źródła danych. Oznacza to, że na poziomie repozytorium nie uwzględniamy czy jest to baza relacyjna czy baza obiektowa.

> The central interface in Spring Data repository abstraction is `Repository` (probably not that much of a surprise). It takes the the domain class to manage as well as the id type of the domain class as type arguments. This interface acts primarily as a marker interface to capture the types to work with and to help you to discover interfaces that extend this one. The `CrudRepository` provides sophisticated CRUD functionality for the entity class that is being managed.

Podstawowym elementem jest interfejs `Repository` . Reprezentuje on repozytorium.

```java
public interface Repository<T, ID> {}
```

- `T` jest to obiekt domeny,
- `ID` jest to podstawowy typ danych których posługuje się repozytorium.

Należy zwrócić uwagę, że repozytorium nie ma implementacji - jest interfejsem. Implementacja metod jest dostarczana w trakcie działania (at run time) na podstawie sygnatury metody zdefiniowanych w repozytorium.

Podstawowe repozytorium nie zawiera żadnych metod. Istnieje kilka przedefiniowanych typów repozytoriów.


- CrudRepository - zawiera podstawowe metody do pobierania i usuwania rekordów,
- PagingAndSortingRepository - zawiera podstawowe metody do pobierania ze stronicowanych i posortowanych,
- ReactiveCrudRepository,
- ReactiveSortingRepository,
- RevisionRepository,
- RxJava2CrudRepository,
- RxJava2SortingRepository.

Standardowo dane są pobierane na podstawie definicji metod umieszczonych w repozytorium (interfejsie repozytorium). Spring odczytuje jakie metody zostały zdefiniowane i na postawie tych definicji wykonywane odpowiednie pobieranie danych.

Poniższa definicja zawiera jedną metodę oraz dziedziczy metody z CRUDA.

```java
public interface MeetingBaseRepository extends CrudRepository<MeetingBase, String> {
    List<MeetingBase> findByTypeId(String typeId);
}
```

Mechanizmu w repozytorium parsują nazwy metod. Jeśli metoda ma określony schemat to pod metodę implementowane jest odpowiednie polecenie np. wyszukiwanie.

Przykłady metod wyszukujących:

```java
public interface PersonRepository extends Repository<User, Long> {

  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

  // Enables the distinct flag for the query
  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

  // Enabling ignoring case for an individual property
  List<Person> findByLastnameIgnoreCase(String lastname);
  // Enabling ignoring case for all suitable properties
  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

  // Enabling static ORDER BY for a query
  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);
  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);
}
```

Definicja metody `findByEmailAddressAndLastname` jest interpretowana jako `address = ? and last_name = ?`.

Do definicji możemy dodawać: `Distinc,IgnoreCase,OrderByFirstnameAsc  `.

W przypadku źródeł danych gdzie dane są zagnieżdżone jedna w drugiej np. MongoDB aby odwołać się do podzbiorów `user.name` można stosować znak `_` aby wskazać, że odwołujemy się do obiektu w obiekcie.

```
List<Person> findByAddress_ZipCode(ZipCode zipCode); address.zip_code
List<Person> findByAddressZipCode(ZipCode zipCode); address_zip_code
```

 Można również dodawać dodatkowe parametry które np. posortują dane lub postronicują .

```java
Page<User> findByLastname(String lastname, Pageable pageable);
List<User> findByLastname(String lastname, Sort sort);
List<User> findByLastname(String lastname, Pageable pageable);
```
#### Użycie repozytoriów poza kontenerem Springa
Możliwe jest również wykorzystanie kontenerów poza kontenerem Springa np. w aplikacji HTTPIO jako warstwa do komunikacji z bazą danych.

```java
RepositoryFactorySupport factory = … // Instantiate factory here
UserRepository repository = factory.getRepository(UserRepository.class);
```
#### Implementacja własnych metod do pobierania danych
Tworzymy interfejs który będzie definiował metody do pobierania danych.

```java
public interface MeetingBaseRepositoryRepository {
    MeetingBase findLastMeetingWithCoffee();
}
```

Następnie implementujemy interfejs.

```java
public class MeetingBaseRepositoryRepositoryImpl implements MeetingBaseRepositoryRepository {
    @Autowired
    EntityManager entityManager;

    @Override
    public MeetingBase findLastMeetingWithCoffee() {
        Query query = entityManager.createNativeQuery(
                "select * from meeting where type_id = \"925dea95-b676-4362-a6f5-3c3be049e4f8\" limit 1",
                MeetingBase.class
        );

        return (MeetingBase) query.getSingleResult();
    }
}
```

Musimy jeszcze zdefiniować, że nasze repozytorium implementuje interfejs **MeetingBaseRepositoryRepository**.

```java
public interface MeetingBaseRepository extends CrudRepository<MeetingBase, String>, MeetingBaseRepositoryRepository {
    List<MeetingBase> findByTypeId(String typeId);
}
```

W implementacji należy zwrócić uwagę na to aby nazwa klasy kończyła się słowem `Impl`. Jest to wymagane aby Spring znalazł implementacje.

> If you use namespace configuration, the repository infrastructure tries to autodetect custom implementation fragments by scanning for classes below the package in which it found a repository. These classes need to follow the naming convention of appending the namespace element’s `repository-impl-postfix` attribute to the fragment interface name. This postfix defaults to `Impl`. The following example shows a repository that uses the default postfix and a repository that sets a custom value for the postfix:
### Transakcje
Spring posiada wbudowany mechanizm tworzenia transakcji na poziomie aplikacji. Transakcją jest objęte wywołanie metody.

Transakcję są zaimplementowane na poziomie przetwarzania żądań przez obiekty Proxy. Wszystko jest oparte na mechanizmach AOP (Aspect-Oriented Programming).

Jeśli metoda jest oznaczona adnotacją `@Transactional` to dla wywołania zostanie utworzona transakcja. **Ważne jest to, że w ramach jednej metody transakcyjnej wszystkie wewnętrzne wywołania zostaną objęte tą samą transakcją.**

Więc taki ciąg wywołania metod. W nawiasach oznaczyłem jaka następna metoda jest wołana. Każda z tych metod jest w ramach jednej transakcji, która jest inicjowana na poziomie metody `TransactionA#run`.

```java
TransactionA#run (TransactionB#findById)
TransactionB#findById (UserService#findById)
UserService#findById (CrudRepository#findById)
CrudRepository#findById
```

Jeśli metoda `..TransactionA#run` jest transakcyjna to wszystkie kolejne wywołania będą w ramach tej jednej transakcji!

Jeśli np. metoda `TransactionA#run ` nie była by transakcyjna to dla metody `TransactionB#findById` zostanie utworzona nowa transakcja, ale będzie ona wykorzystana również dla `UserService#findById, CrudRepository#findById`.

Transakcje są tworzone w ramach wywołania metody. Transakcja utworzona dla pierwszego wywołania będzie wykorzystana w ramach wszystkich kolejnych wywołania wewnątrz metody.

Poniżej przykład metody transakcyjnej. Wszystkie wywołania będą w ramach transakcji zainicjowanej w trakcie wywołania metody `run`.

```java
@Transactional
public void run() {
    Optional<User> user = transactionB.findById("24269ed1-d4fd-4235-b77a-5bdabda1b307");
    Optional<User> userA = transactionB.findById("24269ed1-d4fd-4235-b77a-5bdabda1b307");
}
```

W takim przypadku:

```java
public void run() {
    Optional<User> user = transactionB.findById("24269ed1-d4fd-4235-b77a-5bdabda1b307");

    Optional<User> userA = transactionB.findById("24269ed1-d4fd-4235-b77a-5bdabda1b307");
}
```

Będą zainicjowane dwie transakcje, dla jednego wywołania i dla drugiego.

Po wyjściu powoduje, że transakcja jest zatwierdzana.
#### Analiza implementacji
Istnieje taka klasa jak `AbstractPlatformTransactionManager` jest to bazowa klasa która jest rozszerzana przez różne mechanizmy do zarządzania transakcją.

Implementuje ona takie typy jak `PlatformTransactionManager, TransactionManager`.

Obiekt `TransactionSynchronizationManager` pozwala na pobrać informacje na temat aktualnej tranzakcji.

```java
// Zwraca nazwę aktualnej tranzakcji.
TransactionSynchronizationManager.getCurrentTransactionName()
```

Obiekt ten (Singleton) pełni również role kontenera który przechowuje informacje o tranzakcjach powiązanych z danym wątkiem.

W deklaracji klasy mamy dane powiązane z aktywnym wątkiem za pośrednictwem ThreadLocal.

```java
private static final ThreadLocal<Map<Object, Object>> resources =
    new NamedThreadLocal<>("Transactional resources");

private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =
    new NamedThreadLocal<>("Transaction synchronizations");

private static final ThreadLocal<String> currentTransactionName =
    new NamedThreadLocal<>("Current transaction name");

private static final ThreadLocal<Boolean> currentTransactionReadOnly =
    new NamedThreadLocal<>("Current transaction read-only status");

private static final ThreadLocal<Integer> currentTransactionIsolationLevel =
    new NamedThreadLocal<>("Current transaction isolation level");

private static final ThreadLocal<Boolean> actualTransactionActive =
    new NamedThreadLocal<>("Actual transaction active");

```
### EntityManager
Jest to komponent odpowiedzialny za zarządzanie/przechowywanie i udostępnianie encji.

Typ obiektu jest cześcią standardu JPA. Zgodnie ze standardem jest to obiekt odpowiedzialny za zarządzanie/przechowywanie oraz udostępnianie obiektów encji.

Biblioteka Hibernate nazywa ten obiekt Session. Jest to pewna implementacja tej koncepcji.

W komponencie Springa możliwe jest wstrzyknięcie tego typu obiektu tak jak każdego innego.

```java
@Service
public class TransactionC {
    private final EntityManager entityManager;

    public TransactionC(EntityManager entityManager) {
        this.entityManager = entityManager;

        Engine engine = entityManager.find(Engine.class, "123");
    }
}
```
#### Kontekst
Komponent EntityMenager zarządza instancjami encji w ramach pewnego kontekstu. Ogólnie może istnieć wiele kontekstów np. kontekst może być powiązany z aktualną tranzakcją lub z dowolną nazwą.

**Adnotacja `@PersistenceContext`**

Pozwala na zdefniowanie który kontekst powinien zostać użyty przez menadżera kontekstu.

Utworzyłem test w którym sprawdzam który kontekst został użyty. W klasach `TransactionA, TransactionB` wstrzykuje obiekt EM w wariantach:

- PersistenceContextType.TRANSACTION,
- PersistenceContextType.EXTENDED,
- @Autowire

```java
@PersistenceContext(type = PersistenceContextType.TRANSACTION)
private final EntityManager entityManagerTransaction;

@PersistenceContext(type = PersistenceContextType.EXTENDED)
private final EntityManager entityManagerExtended;

@Autowire
private final EntityManager entityManagerInject;
```

Nastepnie w klasie TransactionA utworzylem metodę w której za pomocą tych trzech EM pobieram tę samą encję. Następnie instancje tych encji przekazuje do obiekty typu TransactionB w której robie to samo i porównuje czy instancje sa takiego same.

```java
public void run() {
    String id = "c420c8fd-6223-40a3-91a1-dd2b2a773941";

    Engine engineTransaction = entityManagerTransaction.find(Engine.class, id);
    Engine engineExtended = entityManagerExtended.find(Engine.class, id);
    Engine engineInject = entityManagerInject.find(Engine.class, id);

    transactionB.checkEntityManager(id, engineTransaction, engineExtended, engineInject);
}
```

W obiekcie typu TransactionB

```java
public void checkEntityManager(
    String id,
    Engine engineTransactionOuter,
    Engine engineExtendedOuter, Engine engineInjectOuter
) {
    Engine engineTransaction = entityManagerTransaction.find(Engine.class, id);
    Engine engineExtended = entityManagerExtended.find(Engine.class, id);
    Engine engineInject = entityManagerInject.find(Engine.class, id);

    println("engineTransaction == engineTransactionOuter: " + (engineTransaction == engineTransactionOuter));
    println("engineExtended == engineExtendedOuter: " + (engineExtended == engineExtendedOuter));
    println("engineInject == engineInjectOuter: " + (engineInject == engineInjectOuter));
}
```

Wynik działania:

```
engineTransaction == engineTransactionOuter: false
engineExtended == engineExtendedOuter: false
engineInject == engineInjectOuter: false
```

Oznacza to, że wszystkie EM (6) korzysta z różnych kontekstów.

Jeśli ustawimy aby metoda `run` była tranzakcyjna.

```java
@Transactional
public void run() {
    // ...
}
```

Wtedy:

```
engineTransaction == engineTransactionOuter: true
engineExtended == engineExtendedOuter: false
engineInject == engineInjectOuter: true
```

Oznacza to, że EM oznaczony przez @Autowire jak i przez PersistenceContextType.TRANSACTION korzysta z tego samego tranzakcyjnego kontekstu.

EM oznaczany przez PersistenceContextType.EXTENDED korzysta z innego kontekstu na poziomie obiektu typu TransactionA jak i TransactionB.

Mechanizm tranzakcji opisywałem w poprzednim wątku.
#### Zapisywanie danych
Za zapis encji odpowiedzialne jest repozytorium danych. Poniżej przykład  w którym tworzone są encję i zapisywane do źródła danych.

```java
@Component
public class DevBootstrap {

    private AuthorRepository authorRepository;
    private BookRepository bookRepository;

    public DevBootstrap(AuthorRepository authorRepository, BookRepository bookRepository) {
        this.authorRepository = authorRepository;
        this.bookRepository = bookRepository;
    }

    @EventListener()
    public void handleContextStartedEvent(ContextRefreshedEvent event) {
        // Eric
        Author eric = new Author("Eric", "Evans");

        Book ddd = new Book("Domain-Driven Design", "9788328305250", "HELION");

        eric.getBooks().add(ddd);
        ddd.getAuthors().add(eric);

        Author john = new Author("John", "Lakos");

        Book b1 = new Book("Large-Scale C++", "0201717069", "HELION");
        Book b2 = new Book("Cabin by the Creek", "1420888773", "HELION");

        john.getBooks().add(b1);
        john.getBooks().add(b2);

        b1.getAuthors().add(john);
        b2.getAuthors().add(john);

        authorRepository.save(eric);
        authorRepository.save(john);

        bookRepository.save(b1);
        bookRepository.save(b2);
        bookRepository.save(ddd);
    }
}
```
## Batch

![image-20211117161315704](../../../.files/image-20211117161315704.png)

Jest to sposób uporządkowanego przetwarzania procesów. Spring udostępnia biblioteki które to upraszczają.

https://spring.io/projects/spring-batch 

## Actuator
Jest to moduł dostarczający mechanizmy monitorowania parametrów instancji Springa. Wystarczy, że dodamy zależność:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
    <version>2.4.1</version>
</dependency>
```

Spowoduje to, że pojawią się endpointy `/health`, `/metrics`, `/beans`  itp. Endpointy można zabezpieczyć za pomocą moduły Spring Security ustawiająć, że aby móc pobrać informacje użytkownik musi być zalogowany.

Poniżej przykładowa implementacja własnego wskaźnika.

```java
@Component
public class RandomHealthIndicator implements HealthIndicator {

    @Override
    public Health health() {
        double chance = ThreadLocalRandom.current().nextDouble();
        Health.Builder status = Health.up();
        if (chance > 0.9) {
            status = Health.down();
        }
        return status.build();
    }
}
```

Więcej na temat usługi w artykule **Health Indicators in Spring Boot**.
### Wskazówki
#### Udostępnianie zasobów
```properties
management.endpoints.web.exposure.include=*

management.endpoints.web.exposure.include=*
management.endpoints.web.exposure.exclude=threaddump

management.endpoints.enabled-by-default=false

management.endpoint.health.enabled=true
management.endpoints.web.exposure.include=health
```
#### Zamknięcie usługi
```
management.endpoint.shutdown.enabled=true
curl -X POST http://localhost:8080/actuator/shutdown
```
## Cache
Spring dostarcza moduł który tworzy generyczny mechanizm pamięci podręcznej. Użycie zostało opisane artykule **A Guide To Caching in Spring**.

## Metryki

Spring udostępnia moduł za pomocą które możemy w dość prosty sposób eksportować metryki.

https://docs.spring.io/spring-metrics/docs/current/public/prometheus

## Pozostałe

### Logowanie żądań i identyfikator transakcji

Do zapisywana ID tranzakcji możemy użyć MDC z Sf4j. Jest to skrót od **Mapped Diagnostic Context** pozwala na zdefiniowanie zmiennych do których następnie można odwołać się w logach. Z mojej analizy wynika, że klasa korzysta z ThreadLocal czyli ze zmiennych przypisanych do wątku. Wiec to rozwiązanie zadziała jeśli żądanie od początku do końca jest przetwarzane przez ten sam wątek. 

Logowanie żądania można zrealizować przez filtry z Springu. Dobrze nadaje się do tego filtr który rozszerza `OncePerRequestFilter`. 

Przykładowa implementacja z repozytorium w katalogu `repository:spring-request-transaction-logger`.

### Zwrócenie pliku przez `ByteArrayOutputStream`.

```java
@RequestMapping(value = "/cpa-account-file/download/{mccpaVersionId}", method = RequestMethod.GET)
public ResponseEntity<byte[]> downloadCpaAccountFile(@PathVariable Long mccpaVersionId) {
    ByteArrayOutputStream output = new ByteArrayOutputStream();

    cpaAccountFileService.prepareCpaAccountFile(mccpaVersionId, output);

    ContentDisposition contentDisposition = ContentDisposition.attachment()
        .filename("Cpa and Accounts.xlsx")
        .build();

    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"));
    headers.set(HttpHeaders.CONTENT_DISPOSITION, contentDisposition.toString());
    headers.setContentLength(output.toByteArray().length);

    return new ResponseEntity<>(output.toByteArray(), headers, HttpStatus.OK);
}
```

### Zwrócenie pliku

```java
@GetMapping(
  value = "/get-file",
  produces = MediaType.APPLICATION_OCTET_STREAM_VALUE
)
public @ResponseBody byte[] getFile() throws IOException {
    InputStream in = getClass().getResourceAsStream("/com/baeldung/produceimage/data.txt");
    return IOUtils.toByteArray(in);
}
```

### Pobranie komponentu globalnie
```java
NotificationCacheServiceInterface notificationCacheService = (NotificationCacheServiceInterface) SpringApplicationContext.getBean(NotificationCacheService.class.getSimpleName());
```

### Tranzakcje `readOnly`
W P1 spotkałem się z takim przypadkiem, że wszystkie metody z repozytorium były oznaczone jako transakcyjne z opcją `readOnly`. Zaciekawiło mnie to ponieważ sądziłem, że dla metody nieoznaczonej tą adnotacją nie zostanie założona transakcja więc Spring powinien obsłużyć ją szybciej. W dwóch rzeczach się pomyliłem. Po pierwsze każda metoda z repozytorium np. JPA jest oznaczona jako transakcyjna więc moja adnotacja zwiększała tylko zakres tej transakcji ale jej brak nie powodował, że w ogóle nie było by transakcji. Druga rzecz to, to, że transakcja `readOnly` będzie działała szybciej (pewnie to zleży też od implementacji innych mechanizmów) np. dla Hibernate spowoduje, że Hibernate tego typu żądania będzie obsługiwał inaczej niż transakcję `readWrite`.

**Warto o tym pamiętać.**
### błąd `not eligible for auto-proxying`
Ten błąd pojawia się wtedy gdy do BeanPostProcessors wstrzykujemy inny komponent. Dzieje się tak dlatego, że komponenty typu BeanPostProcessors są inicjowane jako pierwsze przed innymi komponentami. Ich zadaniem jest między innymi procesowanie pozostałych komponentów. Dlatego wstrzyknięcie do innego komponentu do BeanPostProcessors jest trochę niepoprawne. Jeśli już potrzebujemy wstrzyknąć innego inny komponent to powinien być on wstrzykiwany leniwie. 

Można rozumieć to tak, że jeśli BeanPostProcessor wymaga innego komponentu do zainicjowania to ten wymagany komponent nie będzie mógł być przetworzony przez ten BeanPostProcessor. W zasadzie może to być cała ścieżka zależności. Jeśli np. BeanPostProcessor wymaga A, a A wymaga B a B wymaga C itp. to każdy z nich A, B, C, D nie zostanie przetworzony poprawnie ponieważ nie zadziała na nich BeanPostProcessor ponieważ nie zostanie zainicjowany zanim komponenty zależne się zainicjują. Dlatego te komponenty zależne powinny być wstrzykiwane leniwie co pozwala na ich zainicjowanie dopiero wtedy gdy BeanPostProcessor  będzie ich wymagał.

Czyli np. w taki sposób za pomocą adnotacji `@Lazy`.

```java
public class RandomIntProcessor implements BeanPostProcessor {
    private final RandomIntGenerator randomIntGenerator;

    @Lazy
    public RandomIntProcessor(RandomIntGenerator randomIntGenerator) {
        this.randomIntGenerator = randomIntGenerator;
    }

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		// ...
    }
}
```
### RestTemplate
RestTemplate dostarcza mechanizmów do wykonywania żądań Rest. Najprostsza konfiguracja jest poniżej, taka konfiguracja tworzy komponent. 

```java
@Configuration
public class RestTemplateConfiguration {
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder.build();
    }
}
```

Następnie w dowolnym miejscu wstrzyknąć komponent i z niego skorzystać.

```java
@Service
public class JpApiServiceImpl implements JpApiService {
    private final RestTemplate restTemplate;
    private final String jpApiUrl;

    public JpApiServiceImpl(RestTemplate restTemplate, @Value("${jpapi.url}") String jpApiUrl) {
        this.restTemplate = restTemplate;

        this.jpApiUrl = jpApiUrl;
    }

    @Override
    public UserDto[] getUsers() {
        UriComponentsBuilder uriComponentsBuilder = UriComponentsBuilder.fromUriString(jpApiUrl);

        // uriComponentsBuilder.queryParam("limit", 10);

        // restTemplate.patchForObject();
        // restTemplate.postForEntity()
        // Jest taki generyczny element JsonNode jsonNode

        return restTemplate.getForEntity(uriComponentsBuilder.toUriString(), UserDto[].class).getBody();
    }
}
```
#### Zdefiniowanie bazowego adresu
```java
@Component
public class RestTemplate {
    private static final String URL_BOARD_PUBLISHNOTICECOMMAND = "/board/command";

    @Value("${bzp.api.baseUrl}")
    private String baseUrl;

    private RestTemplate restTemplate;

	// ...

    @PostConstruct
    public void handlePostConstruct() {
        DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);

        restTemplate.setUriTemplateHandler(uriBuilderFactory);
    }

    public void postOnBoardPublishNoticeCommand(PublishNoticeCommand body) {
        restTemplate.exchange(URL_BOARD_PUBLISHNOTICECOMMAND, HttpMethod.POST, createHttpEntity(body), String.class);
    }
}
```
#### Dodawanie nagłówków
```java
@Component
public class BZPRestTemplate {
	// ...

    private <T> HttpEntity<T> createHttpEntity(T body) {
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);

        HttpEntity<T> httpEntity = new HttpEntity<>(body, httpHeaders);

        return httpEntity;
    }
    
    public void postOnBoardPublishNoticeCommand(PublishNoticeCommand body) {
        restTemplate.exchange(URL_BOARD_PUBLISHNOTICECOMMAND, HttpMethod.POST, createHttpEntity(body), String.class);
    }

  	// ...
}

```

W powyższym przykładzie wykorzystuje wspólną metodę do tworzenie HttpEntity. Można to użyć interceptorów. Ale wymaga to inne użycia RestTemplatu.
### Pobranie danych za pomocą WebClient
Spring dostarcza mechanizmy programowania reaktywnego czyli tgz. WebFlux. Razem za poniższymi zależnościami dostarczany jest klient Http za pomocą które możemy realizować nieblokujące się żądania Http.

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
<dependency>
    <groupId>org.projectreactor</groupId>
    <artifactId>reactor-spring</artifactId>
    <version>1.0.1.RELEASE</version>
</dependency>
```

Przykład

```java
public class Reader {
    private int id;
    private String name;
    private Book favouriteBook;

    // getters and setters..
}

public class Book {
    private final String author;
    private final String title;

   // getters and setters..
}

public class ReaderConsumerServiceImpl implements ReaderConsumerService {

    private final WebClient webClient;

    public ReaderConsumerServiceImpl(WebClient webclient) {
        this.webclient = webclient;
    }

    // ...
}

Mono<Object[]> response = webClient.get()
  .accept(MediaType.APPLICATION_JSON)
  .retrieve()
  .bodyToMono(Object[].class).log();

Object[] objects = response.block();

ObjectMapper mapper = new ObjectMapper();

return Arrays.stream(objects)
  .map(object -> mapper.convertValue(object, Reader.class))
  .map(Reader::getFavouriteBook)
  .collect(Collectors.toList());
```
### JsonNullableModule
W przypadku gdy definicje OpenApi zawierają kluczę `nullable:true` to modele 

```java
@ApiModelProperty("")
public JsonNullable<String> getId() {
    return this.id;
```
Ta wartość `JsonNullable` powoduje, że dane w momencie kodowania wyglądają tak:

```
  "clientType": {
    "present": true
  },
  "orderType": {
    "present": true
  },
  "orderMode": {
    "present": true
  },
```

Ogólnie się nie kodują. Aby ten problem naprawić musimy załączyć moduł Jacksona `JsonNullableModule` w którymś z plików konfiguracyjnych.

```java
@Bean
public JsonNullableModule jsonNullableModule() {
    return new JsonNullableModule();
}

// Alternatywnie możemy zbudować inaczej komponent ObjectMapper
@Bean
@Primary
public ObjectMapper objectMapper() {
    ObjectMapper objectMapper = new ObjectMapper();
    objectMapper.registerModule(new JsonNullableModule());

    return objectMapper;
}
```
### MultiValueMap
Jest to struktura przechowująca mapę list o określonym typie. Rozszerza ona interfejs `Map<K, List<V>>`.

Przykładowa implementacja `org.springframework.util.LinkedMultiValueMap`.

```java
MultiValueMap<String, Object> parameters = new LinkedMultiValueMap<>();
parameters.add(PARAM_SESSION_INDEX, sessionIndex);
parameters.add(PARAM_NAME_ID, nameId);
parameters.add(PARAM_SENDER_TYPE, senderType.name());
```

Analogicznie jest to taka struktura w JSON:

```
{
	documentId : [{...}, {...}, ...],
}
```
### Konfiguracja logowania
```properties
logging.level.org.springframework=DEBUG
logging.level.com.howtodoinjava=DEBUG

##output to a temp_folder/file
logging.file=${java.io.tmpdir}/application.log

## Logging pattern for the console
logging.pattern.console= %d{yyyy-MM-dd HH:mm:ss} - %msg%n

## Logging pattern for file
logging.pattern.file= %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36	} - %msg%
```

Konfiguracja logów rózna w zależności od profilu.

```properties
## application-dev.properties

logging.level.com.howtodoinjava=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%

## application-prod.properties

logging.level.com.howtodoinjava=ERROR
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
```
### Spring Cloud Sleuth
Sposób uruchomienia został opisany:

https://pater.dev/sledzenie-komunikacji-w-systemach-rozproszonych-z-wykorzystaniem-spring-cloud-sleuth-zipkin/

Jest to biblioteka, która automatycznie dodaje do naszych logów oraz zapytań do zewnętrznych systemów identyfikatory potrzebne do śledzenia procesu.

```
INFO [my-example-app2,f766af10373bcdc1,d2328e44d6047837,true] 9408 --- [nio-8081-exec-1] d.p.d.ExampleController     [...]
```

Gdzie **my-example-app2** to wartość zmiennej:

```
spring.application.name=my-example-app2
```

Natomiast *f766af10373bcdc1* to **traceId**, a *d2328e44d6047837* to **spanId**

Dla przykładu poniżej log z aplikacji, która wywołała tę operację:

```
INFO [my-example-app,f766af10373bcdc1,f766af10373bcdc1,true] 6772 --- [nio-8080-exec-1] d.p.d.ExampleController
```

Widzimy tutaj, że **traceId == spanId**, a więc jest to pierwsze żądanie w ramach tego przepływu procesu.

Identyfikatory są automatycznie dodawane do komunikacji [kanałami](https://spring.io/blog/2016/02/15/distributed-tracing-with-spring-cloud-sleuth-and-spring-cloud-zipkin):

- requests over messaging technologies like [Apache Kafka](https://spring.io/blog/2015/04/15/using-apache-kafka-for-integration-and-data-processing-pipelines-with-spring) or RabbitMQ (or any other [Spring Cloud Stream](https://cloud.spring.io/spring-cloud-stream/) binder
- HTTP headers received at Spring MVC controllers
- requests that pass through a Netflix Zuul microproxy
- requests made with the `RestTemplate`, etc.
### Wgranie pliku/obraska
```java
@PostMapping("recipe/{id}/image")
public String handleImagePost(@PathVariable String id, @RequestParam("imagefile") MultipartFile file){

    imageService.saveImageFile(Long.valueOf(id), file);

    return "redirect:/recipe/" + id + "/show";
}
```
### Odczytanie obraska
```java
@GetMapping("recipe/{id}/recipeimage")
public void renderImageFromDB(@PathVariable String id, HttpServletResponse response) throws IOException {
    RecipeCommand recipeCommand = recipeService.findCommandById(Long.valueOf(id));

    if (recipeCommand.getImage() != null) {
        byte[] byteArray = new byte[recipeCommand.getImage().length];
        int i = 0;

        for (Byte wrappedByte : recipeCommand.getImage()){
            byteArray[i++] = wrappedByte; //auto unboxing
        }

        response.setContentType("image/jpeg");
        InputStream is = new ByteArrayInputStream(byteArray);
        IOUtils.copy(is, response.getOutputStream());
    }
}
```
### Importowanie zasobów Web
W przypadku aplikacji które cześć UI jest tworzona przez Springa istnieja mechanizmu pozwalające na kompilowanie i przetwarzanie zasoów strony internetowych.

Jedenym z takich wtycznek jest WRO4J.
### Ustawienie własnego bannera
Spring umożliwia ustawienie własnego bannera powitalnego który będzie uruchamiany w momencie uruchamiania aplikacji.

Banner powitalny można ustawić za pomocą pliki `banner.txt`. Plik umieszczamy w katalogu `resources`.

Logo możemy ustawić rownież za pomocą obrazka, wtedy w `application.properties` ustawimy opcję:

`spring.banner.image.location`. Spowoduje to, że obrazek zostanie przekonwertowany na znaki ASCII i wyświetlony przy uruchamianiu aplikacji.

![1575146955249](../../../.files/1a5594bc-d708-36d1-2299-57a142bd0d1a.gif)
### Różnica między `@Component, @Service, @Controller, @Repository`
![1573903516309](../../../.files/1a5594bc-d708-46d9-a199-51a142bd0d2f.gif)

`@Component` jest podstawową adnotacje na podstawie której Spring tworzy bean. Dzięki ten adnotacji nie jest konieczne definiowanie pliku konfiguracyjnego.

Adnotacje `@Service, @Controller, @Repository` są pewnymi szczególnymi typami komponentów. Adnotacje tak jak by dodają dodatkowe informacje w jaki sposób określony komponent ma być interpretowany.

Np. `@Controller` lub `@RestController` spowoduje, że klasa będzie traktowana jako kontroler w MVC. Dodatkowo spowoduje to, że zostaną odczytane dodatkowe informacje adnotacje np. `GetMapping` etc.

`@Service` sama adnotacja powoduje, że klasa jest zarejestrowana w przestrzeni usług.

`@Repository`, adnotacja powoduje, ze klasa jest zarejestrowana w warstwie "persidence". Spowoduje to np. że wyrzucone wyjątki z tej warstwy mogą zostać przetworzone przez  `PersistenceExceptionTranslationPostProcessor` .
### Zadania cykliczne
Jest to mechanizm pozwalający na zdefiniowanie cyklicznych zadań.

```java
@Component
public class ScheduledTasks {
    MeetingBaseRepository meetingBaseRepository;

    @Autowired
    public ScheduledTasks(MeetingBaseRepository meetingBaseRepository) {
        this.meetingBaseRepository = meetingBaseRepository;
    }

    @Scheduled(fixedRate = 5000)
    public void reloadMeetings() {
        System.out.println("test " + meetingBaseRepository);
    }
}
```

W powyższym przykładzie mamy metodę udekorowaną adnotacją `@Scheduled` w komponencie ogólnym.

Adnotacja ma parametr z jakim interwałem ma się wywoływać metoda.

Aby mechanizm harmonogramów był aktywny trzeba dodac adnotację `@EnableScheduling` dla aplikacji.

```java
@SpringBootApplication
@EnableScheduling
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

Czas można zdefiniować na kilka sposobów.

**1. cron = “0 0 0 \* \* \*”**
Parametr ten jest [CRON’owym](http://pl.docs.pld-linux.org/uslugi_cron.html) wyrażeniem składającym się z sześciu pól reprezentujących kolejno: sekundy, minuty, godziny, dni miesiąca, miesiące oraz dni tygodnia. Oddzielone są one spacjami. Miesiące i dni tygodnia mogą być podawane jako trzy pierwsze litery ich angielskich nazw lub jako liczby (dni tygodnia liczymy od 1: poniedziałek = 1, wtorek = 2 itd.).

Znak ***** oznacza każdą wartość, a znak **?** oznacza niesprecyzowaną wartość. Użyć możemy jej kiedy np. chcemy wywoływać usługę w każdy piątek miesiąca i nie interesuje nas jakie to będą dni, to na 4 pozycji ustawiamy ?. Tak samo jeśli chcemy wywoływać usługę każdego 5 dnia miesiąca nie zważając na to jaki to będzie dzień tygodnia, to na 6 pozycji ustawiamy ?.

Poniżej parę przykładów:

- `* 9 12 * * *` – co sekundę przez minutę od godz. 12:09:00 każdego dnia
- `0 0 2-4 * * *` – godz.2:00:00, 3:00:00 i 4:00:00 każdego dnia
- `0 * 6,19 * * 2` – 6:00:00 i 19:00:00 w każdy wtorek
- `0 0/30 10 * JAN *` – 10:00:00, 10:30:00 każdego dnia stycznia
- `0 0 12 * * MON-FRI` – 12:00:00 od poniedziałku do piątku
- `0 0 0 3 5 ?` – każdego 3 maja o północy

**2. fixedDelay**
Czas w milisekundach pomiędzy ostatnio zakończonym zadaniem a rozpoczęciem następnego. Poprzednie zadanie musi być zakończone.

**3. fixedDelayString**
Tak samo jak fixedDelay, ale parametr jest typu String, a nie long.

**4. fixedRate**
Czas w milisekundach pomiędzy wywołaniami zadań. Poprzednie zadanie nie musi być zakończone.

**5. fixedRateString**
Tak samo jak fixedRate, ale parametr jest typu String, a nie long.

**6. initialDelay**
Opóźnienie w milisekundach przed wykonaniem pierwszego zadania fixedRate() lub fixedDelay().

**7. initialDelayString**
Tak samo jak initialDelay, ale parametr jest typu String, a nie long.

**8. zone**
Strefa czasowa, dla której zadanie będzie wykonywane.

**Zmiana parametru @Scheduled w trybie runtime:**

Wartość parametru adnotacji @Scheduled można ustawić w trakcie działania programu. Można wykorzystać do tego metodę `configureTasks `z interfejsu `SchedulingConfigurer`. Przyjmuje ona w parametrze obiekt klasy `ScheduledTaskRegistrar`, na którym możemy wywołać metody pozwalające nam zmienić interesujący nas parametr. Do powyższego przykładu dodałam klasę konfiguracyjną, w której po 20 sekundach od uruchomienia programu wartość `fixedRate `zmienia się z 5 sekund na 1. Zamiast wykorzystanej przeze mnie metody `addFixedRateTask` możemy użyć `addFixedDelayTask `lub `addTriggerTask`. Więcej szczegółów [TUTAJ](http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/config/ScheduledTaskRegistrar.html).

```java
@Configuration
@EnableScheduling
public class SchedulerConfig implements SchedulingConfigurer {

    @Bean
    public ScheduledTask scheduledTask() {
        return new ScheduledTask();
    }

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        final LocalDateTime dateChange = LocalDateTime.now().plusSeconds(20);
            taskRegistrar.addFixedRateTask(new Runnable() {
                @Override
                public void run() {
                    if(LocalDateTime.now().isAfter(dateChange)) {
                        scheduledTask().executeTask();
                    }
                }
            }, 1000);
    }
}
```
### Wykonywanie dowolnych zapytań i poleceń SQL
Do komunikacji z bazą relacyjną Spring wykorzystuje klasę `JdbcTemplate`. Implementuje ona metody za pomocą których można pobrać dane, wykonać dowolne polecenie.

JdbcTemplate może być wstrzyknięty (za pomocą adnotacji `@Autowired`).

```java
@SpringBootApplication
@EnableScheduling
public class Application implements CommandLineRunner {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(String... args) throws Exception {

        List<Meeting> result = jdbcTemplate.query("SELECT * FROM meeting", new RowMapper<Meeting>() {
            @Override
            public Meeting mapRow(ResultSet resultSet, int i) throws SQLException {
                TkMeeting tkMeeting = new TkMeeting(resultSet.getString("id"));

                tkMeeting.setName(resultSet.getString("name"));
                // tkMeeting.setTypeId(resultSet.getString("typeId"));
                tkMeeting.setDescription(resultSet.getString("description"));
                tkMeeting.setLatitude(resultSet.getDouble("latitude"));
                tkMeeting.setLongitude(resultSet.getDouble("longitude"));

                return tkMeeting;
            }
        });
    }
}
```

Inny przykład z tworzący:

```java
jdbcTemplate.execute("DROP TABLE customers IF EXISTS");
jdbcTemplate.execute("CREATE TABLE customers(" +
                     "id SERIAL, first_name VARCHAR(255), last_name VARCHAR(255))");

// Split up the array of whole names into an array of first/last names
List<Object[]> splitUpNames = Arrays.asList("John Woo", "Jeff Dean", "Josh Bloch", "Josh Long").stream()
    .map(name -> name.split(" "))
    .collect(Collectors.toList());

// Use a Java 8 stream to print out each tuple of the list
splitUpNames.forEach(name -> log.info(String.format("Inserting customer record for %s %s", name[0], name[1])));

// Uses JdbcTemplate's batchUpdate operation to bulk load data
jdbcTemplate.batchUpdate("INSERT INTO customers(first_name, last_name) VALUES (?,?)", splitUpNames);

log.info("Querying for customer records where first_name = 'Josh':");
jdbcTemplate.query(
    "SELECT id, first_name, last_name FROM customers WHERE first_name = ?", new Object[] { "Josh" },
    (rs, rowNum) -> new Customer(rs.getLong("id"), rs.getString("first_name"), rs.getString("last_name"))
).forEach(customer -> log.info(customer.toString()));
```
### Tworzenie własnych filtrów
Spring wykorzystują mechanizm Servletów (Servlety szczegółowo opisuje w innym rozdziale). W Servlety posiadaja mechanizm filtrów. Spring wykorzystuje ten mechanizm. Filtr z poziomu Springa możemy dodać na trzy sposoby:

- przez adnotację `@Component` implementujący `Fitler`,
- zdefiniowanie komponenty w konfiguracji `@Bean` który implementuje filter,
- zdefiniowanie `FilterRegistrationBean`.

Pierwszy sposób:

```java
package com.tooki.api.filters;

import org.springframework.stereotype.Component;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@Component
public class ReadSessionFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpSession session = ((HttpServletRequest) servletRequest).getSession();

        System.out.println("Pobranie (2) z sesji " + session.getAttribute("test"));

        filterChain.doFilter(servletRequest, servletResponse);
    }
}

```

Drugi sposób:

```java
package com.tooki.api;

import com.tooki.api.services.Counter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;

// @EnableWebMvc
@Configuration
@ComponentScan(basePackages = "com.tooki.api.services")
public class WebConfiguration implements WebMvcConfigurer {
    @Bean
    Filter sessionTest() {
        return new Filter() {
            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                HttpSession session = ((HttpServletRequest) servletRequest).getSession();

                System.out.println("Pobranie (1) z sesji " + session.getAttribute("test"));

                filterChain.doFilter(servletRequest, servletResponse);
            }
        };
    }
}

```

Trzeci sposób.

```java
@Bean
public FilterRegistrationBean someFilterRegistration() {

    FilterRegistrationBean registration = new FilterRegistrationBean();
    registration.setFilter(someFilter());
    registration.addUrlPatterns("/url/*");
    registration.addInitParameter("paramName", "paramValue");
    registration.setName("someFilter");
    registration.setOrder(1);
    return registration;
}

public Filter someFilter() {
    return new SomeFilter();
}
```
### Implementacja `DataLoader`
`DataLoader` jest to obiekt który inicjuje dane do przetwarzania. `DataLoader` można zdefiniować w przypadku pracy w środowisku rozwojowym (developerskim) tak aby nie było potrzeby łączenia się z bazą danych. Poniżej opisuje przykładową implementację takiego mechanizmu.

`DataLoader` jest uruchamiany dla określonych profili.

Pierwszym krokiem jest zaimplementowanie tgz. Mapperów. Są to obiekty imitujące repozytoria danych. Mapery przetrzymują dane w mapach haszujących (`HashMap`).

Implementujemy `AbstractMapService` które dostarcza podstawowe metody do operacji na mapie oraz implementujemy repozytoria danych które rozszerzają tą klasę.

```
AbstractMapService
OwnerServiceMap
PetServiceMap
VetServiceMap
```

Klasa `AbstractMapService` może wyglądać następująco:

```java
public abstract class AbstractMapService<T extends BaseEntity, ID extends Long> {

    protected Map<Long, T> map = new HashMap<>();

    Set<T> findAll() {
        return new HashSet<T>(map.values());
    }

    T findById(ID id) {
        return map.get(id);
    }

    T save(T object) {

        if (Objects.isNull(object)) {
            throw new RuntimeException("Object can not be null.");
        }

        if (Objects.isNull(object.getId())) {
            object.setId(generateNewId());
        }

        map.put(object.getId(), object);

        return object;
    }

    void deleteById(ID id) {
        map.remove(id);
    }

    void delete(T object) {
        map.entrySet().removeIf(new Predicate<Map.Entry<Long, T>>() {
            @Override
            public boolean test(Map.Entry<Long, T> entry) {
                return entry.getValue().equals(object);
            }
        });
    }

    private Long generateNewId() {
        Long nextId = null;

        try {
            nextId = Collections.max(map.keySet()) + 1;
        } catch (NoSuchElementException e) {

            nextId = 1L;
        }

        return nextId;
    }
}
```

Ważne jest również aby repozytoria były zdefiniowane przez interesy.

```
OwnerService
PetService
VetService
```

Poniżej przykładowa implementacja `OwnerServiceMap` jest to implementacja repozytorium.

```java
@Service
public class OwnerServiceMap extends AbstractMapService<Owner, Long> implements OwnerService {

    @Override
    public Set<Owner> findAll() {
        return super.findAll();
    }

    @Override
    public void deleteById(Long id) {
        super.deleteById(id);
    }

    @Override
    public void delete(Owner object) {
        super.delete(object);
    }

    @Override
    public Owner save(Owner object) {
        return super.save(object);
    }

    @Override
    public Owner findById(Long id) {
        return super.findById(id);
    }

    @Override
    public Owner findByLastName(String lastName) {
        return null;
    }
}
```

Ostatnim krokiem jest zaimplementowanie `boostrap/DataLoader.java` który wczyta dane do usług.

```java
@Component
public class DataLoader implements CommandLineRunner {
    private final OwnerService ownerService;
    private final PetService petService;
    private final VetService vetService;

    public DataLoader(OwnerService ownerService, PetService petService, VetService vetService) {
        this.ownerService = ownerService;
        this.petService = petService;
        this.vetService = vetService;
    }

    @Override
    public void run(String... args) throws Exception {
        Owner owner1 = new Owner();

        owner1.setFirstName("Paweł");
        owner1.setLastName("Kowalski");

        ownerService.save(owner1);

        // ...
    }
}
```

Podsumowując, repozytoria danych są zdefiniowane za pomocą interfejsów. Dostarczamy implementację tych repozytoriów opartych na mapach. Następnie definiujemy komponent który wczyta dane.

Komponenty `OwnerServiceMap, PetServiceMap, VetServiceMap` mogą być wpięte np. tylko dla profilu `dev`, podobnie komponent `dataLoader` może być uruchomimy dla profilu `dev`.  Natomiast w środowisku produkcyjnym mogą być uruchomione całkowicie inne komponenty.
# Pytania i odpowiedzi
Apart from quantity, as you can see with a huge number of questions, I have worked hard to maintain quality as well. I have not only shared questions from all important topics but also ensured to include so-called advanced topics which many programmers do not prefer to prepare or just left out because they have not worked on that.

Java NIO and JVM internals questions are best examples of that. You can keep design patterns also on the same list but growing number of an experienced programmer are now well aware of GOF design patterns and when to use them. I have also worked hard to keep this list up-to-date to include what interviewers are asking in 2018 and what will be their core focus on coming years. To give you an idea, this list of Java interview questions includes following topics:

1. Multithreading, concurrency and thread basics
2. Date type conversion and fundamentals
3. Garbage Collection
4. Java Collections Framework
5. Array
6. String
7. GOF Design Patterns
8. SOLID design principles
9. Abstract class and interface
10. Java basics e.g. equals() and hashcode
11. Generics and Enum
12. Java IO and NIO
13. Common Networking protocols
14. Data structure and algorithm in Java
15. Regular expressions
16. JVM internals
17. Java Best Practices
18. JDBC
19. Date, Time, and Calendar
20. XML Processing in Java
21. JUnit
22. Programming
## Multithreading, Concurrency and Thread
### [OK] Can we make array volatile in Java
This is one of the tricky Java multi-threading questions you will see in senior Java developer Interview. Yes, you can make an array volatile in Java but only the reference which is pointing to an array, not the whole array. What I mean, if one thread changes the reference variable to points to another array, that will provide a volatile guarantee, but if multiple threads are changing individual array elements they won't be having happens before guarantee provided by the volatile modifier.
### [OK] Can volatile make a non-atomic operation to atomic
This another good question I love to ask on volatile, mostly as a follow-up of the previous question. This question is also not easy to answer because volatile is not about atomicity, but there are cases where you can use a volatile variable to make the operation atomic.

One example I have seen is having a long field in your class. If you know that a long field is accessed by more than one thread e.g. a counter, a price field or anything, you better make it volatile. Why? because reading to a long variable is not atomic in Java and done in two steps, If one thread is writing or updating long value, it's possible for another thread to see half value (fist 32-bit). While reading/writing a volatile long or double (64 bit) is atomic.
### [OK] What are practical uses of volatile modifier
One of the practical use of the volatile variable is to make reading double and long atomic. Both double and long are 64-bit wide and they are read in two parts, first 32-bit first time and next 32-bit second time, which is non-atomic but volatile double and long read is atomic in Java. Another use of the volatile variable is to provide a memory barrier, just like it is used in Disrupter framework. Basically, Java Memory model inserts a write barrier after you write to a volatile variable and a read barrier before you read it. Which means, if you write to volatile field then it's guaranteed that any thread accessing that variable will see the value you wrote and anything you did before doing that right into the thread is guaranteed to have happened and any updated data values will also be visible to all threads, because the memory barrier flushed all other writes to the cache.
### [OK] What guarantee volatile variable provides
volatile variables provide the guarantee about ordering and visibility e.g. volatile assignment cannot be re-ordered with other statements but in the absence of any synchronization instruction compiler, JVM or JIT are free to reorder statements for better performance. volatile also provides the happens-before guarantee which ensures changes made in one thread is visible to others. In some cases volatile also provide atomicity e.g. reading 64-bit data types like long and double are not atomic but read of volatile double or long is atomic.
### [OK] Which one would be easy to write synchronization code for 10 threads or 2 threads
In terms of writing code, both will be of same complexity because synchronization code is independent of a number of threads. Choice of synchronization though depends upon a number of threads because the number of thread present more contention, so you go for advanced synchronization technique e.g. lock stripping, which requires more complex code and expertise.
### [OK] How do you call wait() method using if block or loop
http://javarevisited.blogspot.sg/2015/07/how-to-use-wait-notify-and-notifyall-in.html

`wait()` method should always be called in loop because it's possible that until thread gets CPU to start running again the condition might not hold, so it's always better to check condition in loop before proceeding. Here is the standard idiom of using wait and notify method in Java:

```
// The standard idiom for using the wait method
synchronized (obj) {
   while (condition does not hold)
      obj.wait(); // (Releases lock, and reacquires on wakeup)
      ... // Perform action appropriate to condition
}
```

See [Effective Java Item 69](http://www.amazon.com/dp/0321356683/?tag=javamysqlanta-20) to learn more about why wait method should call in the loop.

### What is false sharing in the context of multi-threading
false sharing is one of the well-known performance issues on multi-core systems, where each process has its local cache. false sharing occurs when threads on different processor modify variables that reside on same cache line as shown in the following image:



[![Java Interview questions for experienced programmers](../../../.files/False+Sharing+in+Multi-threaded+application.gif)](https://2.bp.blogspot.com/-Tze9foqpb74/VepwCzXHGCI/AAAAAAAADtM/i4KQDaefqk4/s1600/False%2BSharing%2Bin%2BMulti-threaded%2Bapplication.gif)


False sharing is very hard to detect because the thread may be accessing completely different global variables that happen to be relatively close together in memory. Like many concurrency issues, the primary way to avoid false sharing is careful code review and aligning your data structure with the size of a cache line.

### [OK] What is busy spin? Why should you use it
Busy spin is one of the technique to wait for events without releasing CPU. **It's often done to avoid losing data in CPU cached** which is lost if the thread is paused and resumed in some other core. So, if you are working on low latency system where your order processing thread currently doesn't have any order, instead of sleeping or calling wait(), you can just loop and then again check the queue for new messages. It's only beneficial if you need to wait for a very small amount of time e.g. in micro seconds or nanoseconds. LMAX Disrupter framework, a high-performance inter-thread messaging library has a `BusySpinWaitStrategy` which is based on this concept and uses a busy spin loop for `EventProcessors` waiting on the barrier.

### [OK] How do you take thread dump in Java
You can take a thread dump of Java application in Linux by using **kill -3 PID**, where PID is the process id of Java process. In Windows, you can press **Ctrl + Break**. This will instruct JVM to print thread dump in standard out or err and it could go to console or log file depending upon your application configuration. If you have used Tomcat then when
### [OK] Is Swing thread-safe
http://javarevisited.blogspot.sg/2013/08/why-swing-is-not-thread-safe-in-java-Swingworker-Event-thread.html

No, Swing is not thread-safe. You cannot update Swing components e.g. `JTable, JList` or `JPanel` from any thread, in fact, they must be updated from GUI or AWT thread. That's why swings provide `invokeAndWait()` and `invokeLater()` method to request GUI update from any other threads. This methods put update request in AWT threads queue and can wait till update or return immediately for an asynchronous update.

### [OK] What is a thread local variable in Java
http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html

Thread-local variables are variables confined to a thread, its like thread's own copy which is not shared between multiple threads. Java provides a `ThreadLocal` class to support thread-local variables. It's one of the many ways to achieve thread-safety. Though be careful while using thread local variable in manged environment e.g. with web servers where worker thread out lives any application variable. **Any thread local variable which is not removed once its work is done can potentially cause a memory leak in Java application.**

### [OK] Write wait-notify code for producer-consumer problem
http://java67.blogspot.sg/2012/12/producer-consumer-problem-with-wait-and-notify-example.html

Please see the answer for a code example. Just remember to call wait() and notify() method from synchronized block and test waiting for condition on the loop instead of if block.

### [OK] Write code for thread-safe Singleton in Java
http://javarevisited.blogspot.in/2012/12/how-to-create-thread-safe-singleton-in-java-example.html

Please see the answer for a code example and step by step guide to creating thread-safe singleton class in Java. When we say thread-safe, which means Singleton should remain singleton even if initialization occurs in the case of multiple threads. Using Java enum as Singleton class is one of the easiest ways to create a thread-safe singleton in Java.

### [OK] The difference between sleep and wait in Java
> http://java67.blogspot.sg/2012/08/what-are-difference-between-wait-and.html
> Though both are used to pause currently running thread, `sleep()` is actually meant for short pause because it doesn't release lock, while `wait()` is meant for conditional wait and that's why it release lock which can then be acquired by another thread to change the condition on which it is waiting.

`wait` jest metodą obiektu. Służy do synchronizacji wątków i powinna być wykonywana w bloku synchronicznym. Uruchomienia zadania potrzebne jest wykonanie metody `notify` lub `notifyAll`.

`sleep` jest metodą statyczną klasy `Thread`, usypia wątek na określony czas.

Przykład użycia `sleep`.

```java
private static Object LOCK = new Object();

private static void sleepWaitExamples() 
  throws InterruptedException {
 
    Thread.sleep(1000);
    System.out.println(
      "Thread '" + Thread.currentThread().getName() +
      "' is woken after sleeping for 1 second");
 
    synchronized (LOCK) {
        LOCK.wait(1000);
        System.out.println("Object '" + LOCK + "' is woken after" +
          " waiting for 1 second");
    }
}
```

Przykład użycia `wait`.

```java
synchronized (b) {
    while (b.sum == 0) {
        System.out.println("Waiting for ThreadB to complete...");
        b.wait();
    }

    System.out.println("ThreadB has completed. " + 
      "Sum from that thread is: " + b.sum);
}

// Wywołanie
int sum;
 
@Override 
public void run() {
    synchronized (this) {
        int i = 0;
        while (i < 100000) {
            sum += i;
            i++; 
        }
        notify(); 
    } 
}
```
### [OK] What is an immutable object? How do you create an Immutable object in Java
> http://javarevisited.blogspot.sg/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html
> Immutable objects are those whose state cannot be changed once created. Any modification will result in a new object e.g. String, Integer, and other wrapper class. Please see the answer for step by step guide to creating Immutable class in Java.


Typy `Integer, String, Long, Boolean` są przykładami takich typów. Przykładowa implementacja może wyglądać tak, że mamy kontruktor ze wszystkimi parametrami i tylko metody do pobierania wartości.

```java
public final class Contacts {
    private final String name;
    private final String mobile;

    public Contacts(String name, String mobile) {
        this.name = name;
        this.mobile = mobile;
    }
  
    public String getName(){
        return name;
    }
  
    public String getMobile(){
        return mobile;
    }
}
```
### [OK] Can we create an Immutable object, which contains a mutable object
Yes, its possible to create an Immutable object which may contain a mutable object, you just need to be a little bit careful not to share the reference of the mutable component, instead, you should return a copy of it if you have to. Most common example is an Object which contain the reference of `java.util.Date` object.
## Date types and Basic
### [OK] Czy możemy zdefniować pole statyczne i prywatne w interfejsie
Każde pole z interfejsie jest z założenia statyczne. Nie możemy zdefiniować pola prywatnego.

```java
interface Test {
    private String id = "Paweł";// ERROR

    // static String name = "Paweł"; 
    String name = "Paweł"; // OK
}
```
### [OK] What is the right data type to represent a price in Java
http://javarevisited.blogspot.sg/2012/02/java-mistake-1-using-float-and-double.html

BigDecimal if memory is not a concern and Performance is not critical, otherwise double with predefined precision.

### [OK] How do you convert bytes to String
http://javarevisited.blogspot.sg/2014/08/2-examples-to-convert-byte-array-to-String-in-Java.html
you can convert bytes to the string using string constructor which accepts byte[], just make sure that right character encoding otherwise platform's default character encoding will be used which may or may not be same.

Przykonwertowaniu trzeba pamiętać aby uwzględnić kodowanie.

```java
String str = new String(bytes, "UTF-8");
```

### How do you convert bytes to long in Java
This questions if for you to answer :-)
### [OK] Can we cast an int value into byte variable
What will happen if the value of int is larger than byte. Yes, we can cast but int is 32 bit long in java while byte is 8 bit long in java so when you cast an int to byte higher 24 bits are lost and a byte can only hold a value from -128 to 128.
### [OK] Extends A with B with C
> Can we cast B into C czyli  `C = (C) B`.

Kompilator w zasadzie na to pozwoli. 

```java
class A {}
class B extends A {}
class C extends B {}

A a = new A();
C c = (C) a;
```

Ale w trakcie uruchomienia zostanie wygenerowany błąd `ClassCastException`.

### [OK] Which class contains clone method? Cloneable or Object
http://javarevisited.blogspot.sg/2015/01/java-clone-tutorial-part-2-overriding-with-mutable-field-example.html

java.lang.Cloneable is marker interface and doesn't contain any method clone method is defined in the object class. It is also knowing that clone() is a native method means it's implemented in C or C++ or any other native language.

### [OK] Is ++ operator is thread-safe in Java
> No it's not a thread safe operator because its involve multiple instructions like reading a value, incriminating it and storing it back into memory which can be overlapped between multiple threads.

Niby jest to jedna operacja, ale realizowana w kilku krokach. Wartość jest pobierana, zwiększana a następnie zapisywana do pamięci.

### [OK] Różnica między `a = a + b` i `a += b`
Jeśli są to różnego typu zmienne to operator `+=` dokona niejawnego rzutowania a operacja `a + b` zostanie oznaczona jako błąd.

```java
int a = 10;
double b = 20.23;

a = a + b; // ERROR
a += b; // OK
```
### [OK] Can I store a double value in a long variable without casting
http://java67.blogspot.com/2014/11/how-to-convert-double-to-long-in-java-example.html

No, you cannot store a double value into a long variable without casting because the range of double is more  that long and you we need to type cast. It's not dificult to answer this question but many develoepr get it wrong due to confusion on which one is bigger between double and long in Java.

### [OK] What will this return `3 * 0.1 == 0.3 ? true or false`
> This is one of the really tricky questions. Out of 100, only 5 developers answered this question and only of them have explained the concept correctly. The short answer is false because some floating point numbers can not be represented exactly.

Wynika to stąd, że liczby zmienno przecinkowe mają ogarniczoną precysję. KIedyś to sprawdzałem i o ile dobrze pamiętam to wynikało to stąd, że mam określoną długość thg. mantissy która przechowyje informacje o wartości po przecinku.

Jeśli wykonujemy działanie bez określenia precyzji to pomimo, że wartości będą takie same to te 0, 1 nie bedą identyczne.

![image-20210408104622460](../../../.files/image-20210408104622460.png)



### [OK] Which one will take more memory, an `int` or `Integer`
An Integer object will take more memory an Integer is the an object and it  store meta data overhead about the object and int is primitive type so its takes less space.

### [OK] Why is String Immutable in Java
> http://java67.blogspot.sg/2014/01/why-string-class-has-made-immutable-or-final-java.html
> The String is Immutable in java because java designer thought that string will be heavily used and making it immutable allow some optimization easy sharing same String object between multiple clients. See the link for the more detailed answer. This is a great question for Java programmers with less experience as it gives them food for thought, to think about how things works in Java, what Jave designers might have thought when they created String class etc.

Te optymalizację są widoczne np. gdy tworzymy stringa.

```java
String a = new String("Pawel");
String b = "Paweł";
```

W pierwszym przypadku zostanie utworzona nowa instancja. W drugim zostastanie reużyta instancja ze wzpólnej pamięci jeśli wyraz "Paweł" został już zainicjowany.
### [OK] Can we use String in the switch case
http://javarevisited.blogspot.sg/2011/08/string-switch-case-jdk7-example.html
Yes from Java 7 onward we can use String in switch case but it is just syntactic sugar. **Internally string hash code is used for the switch.** 
#### What is constructor chaining in Java
http://java67.blogspot.sg/2012/12/how-constructor-chaining-works-in-java.html

When you call one constructor from other than it's known as constructor chaining in Java. This happens when you have multiple, overloaded constructor in the class.
#### JVM Internals and Garbage Collection Interview Questions
In the year 2018 I have seen increased focus on JVM internal and Garbage collection tuning, monitoring Java application, dealing with Java performance issues on various Java interviews. This is actually become the prime topic for interviewing any experienced Java developer for senior position e.g. technical lead, VP or team lead. If you feel you are short of experience and knowledge in this area then you should read atleast one book mentioned in my list of [Java Performance books](http://javarevisited.blogspot.com/2014/07/top-5-java-performance-tuning-books.html). I vote goes to Java Performance, The Definitive guide by Scott.
#### What is the size of int in 64-bit JVM
The size of an int variable is constant in Java, it's always 32-bit irrespective of platform. Which means the size of primitive int is same in both 32-bit and 64-bit Java virtual machine.
#### The difference between Serial and Parallel Garbage Collector
http://javarevisited.blogspot.sg/2011/04/garbage-collection-in-java.html

Even though both the serial and parallel collectors cause a stop-the-world pause during Garbage collection. The main difference between them is that a serial collector is a default copying collector which uses only one GC thread for garbage collection while a parallel collector uses multiple GC threads for garbage collection.
#### What is the size of an int variable in 32-bit and 64-bit JVM
The size of int is same in both 32-bit and 64-bit JVM, it's always 32 bits or 4 bytes.
#### A difference between WeakReference and SoftReference in Java
http://javarevisited.blogspot.sg/2014/03/difference-between-weakreference-vs-softreference-phantom-strong-reference-java.html

Though both WeakReference and SoftReference helps garbage collector and memory efficient, WeakReference becomes eligible for garbage collection as soon as last strong reference is lost but SoftReference even thought it can not prevent GC, it can delay it until JVM absolutely need memory.
#### How do WeakHashMap works
WeakHashMap works like a normal HashMap but uses WeakReference for keys, which means if the key object doesn't have any reference then both key/value mapping will become eligible for garbage collection.
#### What is -XX:+UseCompressedOops JVM option? Why use it
http://javarevisited.blogspot.com/2012/06/what-is-xxusecompressedoops-in-64-bit.html

When you go migrate your Java application from 32-bit to 64-bit JVM, the heap requirement suddenly increases, almost double, due to increasing size of ordinary object pointer from 32 bit to 64 bit. This also adversely affect how much data you can keep in CPU cache, which is much smaller than memory. Since main motivation for moving to 64-bit JVM is to specify large heap size, you can save some memory by using compressed OOP. By using -XX:+UseCompressedOops, JVM uses 32-bit OOP instead of 64-bit OOP.
#### How do you find if JVM is 32-bit or 64-bit from Java Program
http://javarevisited.blogspot.sg/2012/01/find-jvm-is-32-or-64-bit-java-program.html

You can find that by checking some system properties like `sun.arch.data.model` or `os.arch`
#### What is the maximum heap size of 32-bit and 64-bit JVM
http://javarevisited.blogspot.sg/2013/04/what-is-maximum-heap-size-for-32-bit-64-JVM-Java-memory.html

Theoretically, the maximum heap memory you can assign to a 32-bit JVM is 2^32 which is 4GB but practically the limit is much smaller. It also varies between operating systems e.g. form 1.5GB in Windows to almost 3GB in Solaris. 64-bit JVM allows you to specify larger heap size, theoretically 2^64 which is quite large but practically you can specify heap space up to 100GBs. There are even JVM e.g. Azul where heap space of 1000 gigs is also possible.
#### What is the difference between JRE, JDK, JVM and JIT
http://javarevisited.blogspot.sg/2011/12/jre-jvm-jdk-jit-in-java-programming.html

JRE stands for Java run-time and it's required to run Java application. JDK stands for Java development kit and provides tools to develop Java program e.g. Java compiler. It also contains JRE. The JVM stands for Java virtual machine and it's the process responsible for running Java application. The JIT stands for Just In Time compilation and helps to boost the performance of Java application by converting Java byte code into native code when the crossed certain threshold i.e. mainly hot code is converted into native code.

[<img src="../../../.files/JVM+JRE+JDK.jpg" alt="Java Interview Questions for 3 years experience " style="zoom:150%;" />](https://2.bp.blogspot.com/-ls3yC0U7ouo/VhDqX-3OUbI/AAAAAAAAD40/Zcsc5uCaGq0/s1600/JVM%2BJRE%2BJDK.jpg)
#### Explain Java Heap space and Garbage collection
http://javarevisited.blogspot.sg/2011/05/java-heap-space-memory-size-jvm.html

When a Java process is started using java command, memory is allocated to it. Part of this memory is used to create heap space, which is used to allocate memory to objects whenever they are created in the program. Garbage collection is the process inside JVM which reclaims memory from dead objects for future allocation.

[![JVM Internals Java Interview Questions Answers](../../../.files/java_heaps_memory.jpg)](https://3.bp.blogspot.com/-DqV12_uIeZ4/VhDqtPCVIVI/AAAAAAAAD48/uqWZB0BgZUI/s1600/java_heaps_memory.jpg)
#### Can you guarantee the garbage collection process
No, you cannot guarantee the garbage collection, though you can make a request using System.gc() or Runtime.gc() method.
#### How do you find memory usage from Java program? How much percent of the heap is used
You can use memory related methods from java.lang.Runtime class to get the free memory, total memory and maximum heap memory in Java.  By using these methods, you can find out how many percents of the heap is used and how much heap space is remaining. Runtime.freeMemory() return amount of free memory in bytes, Runtime.totalMemory() returns total memory in bytes and Runtime.maxMemory() returns maximum memory in bytes.
#### What is the difference between stack and heap in Java
http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html

Stack and heap are different memory areas in the JVM and they are used for different purposes. The stack is used to hold method frames and local variables while objects are always allocated memory from the heap. The stack is usually much smaller than heap memory and also didn't shared between multiple threads, but heap is shared among all threads in JVM.

[![Java Interview Questions and Answers on Memory](../../../.files/Difference+between+stack+and+heap+memory+in+Java.gif)](https://1.bp.blogspot.com/-NZeVo83YJAA/VhDrDO0oWtI/AAAAAAAAD5E/mEek8Ll7NfU/s1600/Difference%2Bbetween%2Bstack%2Band%2Bheap%2Bmemory%2Bin%2BJava.gif)
### Basic Java concepts Interview Questions
#### What's the difference between "a == b" and "a.equals(b)"
http://javarevisited.blogspot.sg/2012/12/difference-between-equals-method-and-equality-operator-java.html

The a = b does object reference matching if both a and b are an object and only return true if both are pointing to the same object in the heap space, on the other hand, a.equals(b) is used for logical mapping and its expected from an object to override this method to provide logical equality. For example, String class overrides this equals() method so that you can compare two Strings, which are the different object but contains same letters.
#### What is a.hashCode() used for? How is it related to a.equals(b)
http://javarevisited.blogspot.sg/2011/10/override-hashcode-in-java-example.html

`hashCode()` method returns an int hash value corresponding to an object. It's used in hash based collection classes e.g `Hashtable, HashMap, LinkedHashMap` and so on. It's very tightly related to `equals()` method. According to Java specification, two objects which are equal to each other using `equals()` method must have same hash code.
#### Difference between final, finalize and finally
http://javarevisited.blogspot.sg/2012/11/difference-between-final-finally-and-finalize-java.html

The final is a modifier which you can apply to variable, methods and classes. If you make a variable final it means its value cannot be changed once initialized. finalize is a method, which is called just before an object is a garbage collected, giving it last chance to resurrect itself, but the call to finalize is not guaranteed. finally is a keyword which is used in exception handling along with try and catch. the finally block is always executed irrespective of whether an exception is thrown from try block or not.
#### What is a compile time constant in Java? What is the risk of using it
public static final variables are also known as a compile time constant, the public is optional there. They are replaced with actual values at compile time because compiler know their value up-front and also knows that it cannot be changed during run-time. One of the problem with this is that if you happened to use a public static final variable from some in-house or third party library and their value changed later than your client will still be using old value even after you deploy a new version of JARs. To avoid that, make sure you compile your program when you upgrade dependency JAR files.
### Java Collections Framework Interview Questions
It also contains Data structure and algorithm Interview question in Java, questions on array, linked list, HashMap, ArrayList, Hashtable, Stack, Queue, PriorityQueue, LinkedHashMap and ConcurrentHashMap.
#### The difference between List, Set, Map, and Queue in Java
http://java67.blogspot.sg/2013/01/difference-between-set-list-and-map-in-java.html

The list is an ordered collection which allows duplicate. It also has an implementation which provides constant time index based access, but that is not guaranteed by List interface. Set is unordered collection which
#### Difference between poll() and remove() method
Both poll() and remove() take out the object from the Queue but if poll() fails then it returns null but if remove fails it throws Exception.
#### The difference between LinkedHashMap and PriorityQueue in Java
http://javarevisited.blogspot.sg/2013/10/what-is-priorityqueue-data-structure-java-example-tutorial.html

PriorityQueue guarantees that lowest or highest priority element always remain at the head of the queue, but LinkedHashMap maintains the order on which elements are inserted. When you iterate over a PriorityQueue, iterator doesn't guarantee any order but iterator of LinkedHashMap does guarantee the order on which elements are inserted.
#### Difference between ArrayList and LinkedList in Java
http://java67.blogspot.sg/2012/12/difference-between-arraylist-vs-LinkedList-java.html

The obvious difference between them is that ArrrayList is backed by array data structure, supprots random access and LinkedList is backed by linked list data structure and doesn't supprot random access. Accessing an element with the index is O(1) in ArrayList but its O(n) in LinkedList. See the answer for more detailed discussion.
#### What is a couple of ways that you could sort a collection
http://java67.blogspot.sg/2012/07/sort-list-ascending-descending-order-set-arraylist.html

You can either use the Sorted collection like TreeSet or TreeMap or you can sort using the ordered collection like a list and using Collections.sort() method.
#### How do you print Array in Java
http://java67.blogspot.sg/2014/03/how-to-print-array-in-java-example-tutorial.html

You can print an array by using the Arrays.toString() and Arrays.deepToString() method. Since array doesn't implement toString() by itself, just passing an array to System.out.println() will not print its contents but Arrays.toString() will print each element.
#### LinkedList in Java is doubly or singly linked listwe
It's a doubly linked list, you can check the code in JDK. In Eclipse, you can use the [shortcut](http://javarevisited.blogspot.com/2010/10/eclipse-tutorial-most-useful-eclipse.html), Ctrl + T to directly open this class in Editor.
#### Which kind of tree is used to implement TreeMap in Java
A Red Black tree is used to implement TreeMap in Java.
#### What is the difference between Hashtable and HashMap
http://java67.blogspot.sg/2012/08/5-difference-between-hashtable-hashmap-Java-collection.html

There are many differences between these two classes, some of them are following:

- Hashtable is a legacy class and present from JDK 1, HashMap was added later.
- Hashtable is synchronized and slower but HashMap is not synchronized and faster.
- Hashtable doesn't allow null keys but HashMap allows one null key.
#### How HashSet works internally in Java
http://java67.blogspot.sg/2014/01/how-hashset-is-implemented-or-works-internally-java.html

HashSet is internally implemented using an HashMap. Since a Map needs key and value, a default value is used for all keys. Similar to HashMap, HashSet doesn't allow duplicate keys and only one null key, I mean you can only store one null object in HashSet.
#### Write code to remove elements from ArrayList while iterating
http://javarevisited.blogspot.sg/2014/01/ow-to-remove-objects-from-collection-arraylist-java-iterator-traversing.html

Key here is to check whether candidate uses ArrayList's `remove()` or Iterator's `remove()`. Here is the [sample code](http://java67.blogspot.com/2015/10/how-to-solve-concurrentmodificationexception-in-java-arraylist.html) which uses right way o remove elements from ArrayList while looping over and avoids ConcurrentModificationException.
#### Can I write my own container class and use it in the for-each loop
Yes, you can write your own container class. You need to implement the Iterable interface if you want to loop over advanced for loop in Java, though. If you implement Collection then you by default get that property.
#### What is default size of ArrayList and HashMap in Java
http://javarevisited.blogspot.sg/2014/07/java-optimization-empty-arraylist-and-Hashmap-cost-less-memory-jdk-17040-update.html
As of Java 7 now, default size of ArrayList is 10 and default capacity of HashMap is 16, it must be power of 2. Here is code snippet from ArrayList  and HashMap class :

```
// from ArrayList.java JDK 1.7
private static final int DEFAULT_CAPACITY = 10;

//from HashMap.java JDK 7
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```
#### Is it possible for two unequal objects to have the same hashcode
Yes, two unequal objects can have same hashcode that's why collision happen in a hashmap.
the equal hashcode contract only says that two equal objects must have the same hashcode it doesn't say anything about the unequal object.
#### Can two equal object have the different hash code
No, thats not possible according to hash code contract.
#### Can we use random numbers in the hashcode() method
http://javarevisited.blogspot.sg/2011/10/override-hashcode-in-java-example.html

No, because hashcode of an object should be always same. See the answer to learning more about things to remember while overriding hashCode() method in Java.
#### What is the difference between Comparator and Comparable in Java
http://java67.blogspot.sg/2013/08/difference-between-comparator-and-comparable-in-java-interface-sorting.html

The Comparable interface is used to define the  natural order of object while Comparator is used to define custom order. Comparable can be always one, but we can have multiple comparators to define customized order for objects.
#### Why you need to override hashcode, when you override equals in Java
http://javarevisited.blogspot.sg/2015/01/why-override-equals-hashcode-or-tostring-java.html

 Because equals have code contract mandates to override equals and hashcode together .since many container class like HashMap or HashSet depends on hashcode and equals contract.
#### Java IO and NIO Interview questions
IO is very important from Java interview point of view. You should have a good knowledge of old Java IO, NIO, and NIO2 alsong with some operating system and disk IO fundamentals. Here are some frequently asked questions form Java IO.
#### In my Java program, I have three sockets? How many threads I will need to handle that
#### How do you create ByteBuffer in Java
#### How do you write and read from ByteBuffer in Java
#### Is Java BIG endian or LITTLE endian
#### What is the byte order of ByteBuffer
#### The difference between direct buffer and non-direct buffer in Java
http://javarevisited.blogspot.sg/2015/08/difference-between-direct-non-direct-mapped-bytebuffer-nio-java.html
#### What is the memory mapped buffer in Java
http://javarevisited.blogspot.sg/2012/01/memorymapped-file-and-io-in-java.html
#### What is TCP NO DELAY socket option
...
#### What is the difference between TCP and UDP protocol?
http://javarevisited.blogspot.com/2014/07/9-difference-between-tcp-and-udp-protocol.html
#### The difference between ByteBuffer and StringBuffer in Java
...
#### Java Best Practices Interview question
Contains best practices from different parts of Java programming e.g. Collections, String, IO, Multi-threading, Error and Exception handling, design patterns etc. This section is mostly for experience Java developer, technical lead,  AVP, team lead and coders who are responsible for products. If you want to create quality products you must know and follow the best practices.
#### What best practices you follow while writing multi-threaded code in Java
http://javarevisited.blogspot.com/2015/05/top-10-java-multithreading-and.html

Here are couple of best practices which I follow while writing concurrent code in Java:

- Always name your thread, this will help in debugging.
- minimize the scope of synchronization, instead of making whole method synchronized, only critical section should be synchronized.
- prefer volatile over synchronized if you can can.
- use higher level concurrency utilities instead of waitn() and notify for inter thread communication e.g. BlockingQueue, CountDownLatch and Semeaphore.
- Prefer concurrent collection over synchronized collection in Java. They provide better scalability.
#### Tell me few best practices you apply while using Collections in Java
Here are couple of best practices I follow while using Collectionc classes from Java:

- Always use the right collection e.g. if you need non-synchronized list then use ArrayList and not Vector.
- Prefer concurrent collection over synchronized collection because they are more scalable.
- Always use interface to a represent and access a collection e.g. use List to store ArrayList, Map to store HashMap and so on.
- Use iterator to loop over collection.
- Always use generics with collection.
#### Can you tell us at least 5 best practice you use while using threads in Java
http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html

This is similar to the previous question and you can use the answer given there. Particularly with thread, you should:

- name your thread

- keep your task and thread separate, use Runnable or Callable with thread pool executor.

- use thread pool

- use volatile to indicate compiler about ordering, visibility, and atomicity.

- avoid thread local variable because incorrect use of ThreadLocal class in Java can create a memory leak.


Look there are many best practices and I give extra points to the developer which bring something new, something even I don't know. I make sure to ask this question to Java developers of 8 to 10 years of experience just to gauge his hands on experience and knowledge.
#### Name 5 IO best practices
IO is very important for performance of your Java application. Ideally you should avoid IO in critical path of your application. Here are couple of Java IO best practices you can follow:

- Use buffered IO classes instead of reading individual bytes and char.
- Use classes from NIO and NIO2
- Always close streams in finally block or use try-with-resource statements.
- use memory mapped file for faster IO.
- If a Java candidate doesn't know about IO and NIO, especially if he has at least 2 to 4 years of experience, he needs some reading.
#### Name 5 JDBC best practices your follow
http://javarevisited.blogspot.sg/2012/08/top-10-jdbc-best-practices-for-java.html

Another good Java best practices for experienced Java developer of 7 to 8 years experience. Why it's important? because they are the ones which set the trend in the code and educate junior developers. There are many best practices and you can name as per your confort and conviniece. Here are some of the more common ones:
- use batch statement for inserting and updating data.
- use PreparedStatement to avoid SQL exception and better performance.
- use database connection pool
- access resultset using column name instead of column indexes.
- Don't generate dynamic SQL by concatenating String with user input.

#### Name couple of method overloading best practices in Java
http://javarevisited.blogspot.sg/2013/01/java-best-practices-method-overloading-constructor.html
Here are some best practices you can follow while overloading a method in Java to avoid confusion with auto-boxing:
- Don't overload method where one accepts int and other accepts Integer.
- Don't overload method where number of argument is same and only order of argument is different.
- Use varargs after overloaded methods has more than 5 arguments.
#### Date, Time and Calendar Interview questions in Java
#### Does SimpleDateFormat is safe to use in the multi-threaded program
http://javarevisited.blogspot.sg/2012/03/simpledateformat-in-java-is-not-thread.html
No, unfortunately, DateFormat and all its implementations including SimpleDateFormat is not thread-safe, hence should not be used in the multi-threaded program until external thread-safety measures are applied e.g. confining SimpleDateFormat object into a ThreadLocal variable. If you don't do that, you will get an incorrect result while parsing or formatting dates in Java. Though, for all practical date time purpose, I highly recommend **joda-time** library.

#### How do you format a date in Java? e.g. in the ddMMyyyy format
http://javarevisited.blogspot.com/2011/09/convert-date-to-string-simpledateformat.html
You can either use SimpleDateFormat class or joda-time library to format date in Java. DateFormat class allows you to format date on many popular formats. Please see the answer for code samples to format date into different formats e.g. dd-MM-yyyy or ddMMyyyy.
#### How do you show timezone in formatted date in Java?
http://java67.blogspot.sg/2013/01/how-to-format-date-in-java-simpledateformat-example.html
#### The difference between java.util.Date and java.sql.Date in Java?
http://java67.blogspot.sg/2014/02/how-to-convert-javautildate-to-javasqldate-example.html
#### How to you calculate the difference between two dates in Java? ([program](http://javarevisited.blogspot.sg/2015/07/how-to-find-number-of-days-between-two-dates-in-java.html))
#### How do you convert a String(YYYYMMDD) to date in Java?
http://java67.blogspot.sg/2014/12/string-to-date-example-in-java-multithreading.html
#### Unit testing JUnit Interview questions
89) How do you test static method
You can use PowerMock library to test static methods in Java.

90) How to do you test a method for an exception using JUnit?
http://javarevisited.blogspot.sg/2013/04/JUnit-tutorial-example-test-exception-thrown-by-java-method.html

91) Which unit testing libraries you have used for testing Java programs

92) What is the difference between @Before and @BeforeClass annotation?
http://javarevisited.blogspot.sg/2013/04/JUnit-tutorial-example-test-exception-thrown-by-java-method.html
#### Programming and Coding Questions
#### How to check if a String contains only numeric digits?
http://java67.blogspot.com/2014/01/java-regular-expression-to-check-numbers-in-String.html### How to write LRU cache in Java using Generics
#### Write a Java program to convert bytes to long
#### How to reverse a String in Java without using StringBuffer?
http://java67.blogspot.com/2012/12/how-to-reverse-string-in-java-stringbuffer-stringbuilder.htm### How to find the word with the highest frequency from a file in Java?
http://java67.blogspot.com/2015/10/java-program-to-find-repeated-words-and-count.html### How do you check if two given String are anagrams?
http://javarevisited.blogspot.sg/2013/03/Anagram-how-to-check-if-two-string-are-anagrams-example-tutorial.html### How to print all permutation of a String in Java?
http://javarevisited.blogspot.com/2015/08/how-to-find-all-permutations-of-string-java-example.html### How do you print duplicate elements from an array in Java?
http://javarevisited.blogspot.com/2015/06/3-ways-to-find-duplicate-elements-in-array-java.html### How to convert String to int in Java?
http://java67.blogspot.com/2015/08/2-ways-to-parse-string-to-int-in-java.html### How to swap two integers without using temp variable?
http://java67.blogspot.com/2015/08/how-to-swap-two-integers-without-using.html
#### Java Interview questions from OOP and Design Patterns
It contains Java Interview questions from SOLID design principles, OOP fundamentals e.g. class, object, interface, Inheritance, Polymorphism, Encapsulation, and Abstraction as well as more advanced concepts like Composition, Aggregation, and Association. It also contains questions from GOF design patterns.
#### What is the interface? Why you use it if you cannot write anything concrete on it
The interface is used to define API. It tells about the contract your classes will follow. It also supports abstraction because a client can use interface method to leverage multiple implementations e.g. by using List interface you can take advantage of [random access of ArrayList](http://javarevisited.blogspot.com/2015/07/java-arraylist-tutorial.html) as well as flexible insertion and deletion of LinkedList. The interface doesn't allow you to write code to keep things abstract but from Java 8 you can declare static and default methods inside interface which are concrete.

#### The difference between abstract class and interface in Java
http://javarevisited.blogspot.sg/2013/05/difference-between-abstract-class-vs-interface-java-when-prefer-over-design-oops.html
There are multiple differences between abstract class and interface in Java, but the most important one is Java's restriction on allowing a class to extend just one class but allows it to implement multiple interfaces. An abstract class is good to define default behavior for a family of class, but the interface is good to define Type which is later used to leverage Polymorphism. Please check the answer for a more thorough discussion of this question.

#### Which design pattern have you used in your production code? apart from Singleton
This is something you can answer from your experience. You can generally say about dependency injection, factory pattern, decorator pattern or observer pattern, whichever you have used. Though be prepared to answer follow-up question based upon the pattern you choose.

#### Can you explain Liskov Substitution principle
http://javarevisited.blogspot.com/2012/03/10-object-oriented-design-principles.html
This is one of the toughest questions I have asked in Java interviews. Out of 50 candidates, I have almost asked only 5 have managed to answer it. I am not posting an answer to this question as I like you to do some research, practice and spend some time to understand this confusing principle well.

#### What is Law of Demeter violation? Why it matters
http://javarevisited.blogspot.com/2014/05/law-of-demeter-example-in-java.html
Believe it or not, Java is all about application programming and structuring code. If  you have good knowledge of common coding best practices, patterns and what not to do than only you can write quality code.  Law of Demeter suggests you "talk to friends and not stranger", hence used to reduce coupling between classes.

#### What is Adapter pattern? When to use it
Another frequently asked Java design pattern questions. It provides interface conversion. If your client is using some interface but you have something else, you can write an Adapter to bridge them together. This is good for Java software engineer having 2 to 3 years experience because the question is neither difficult nor tricky but requires knowledge of OOP design patterns.

#### What is "dependency injection" and "inversion of control"? Why would someone use it
http://javarevisited.blogspot.sg/2012/12/inversion-of-control-dependency-injection-design-pattern-spring-example-tutorial.html
#### What is an abstract class? How is it different from an interface? Why would you use it
http://java67.blogspot.sg/2014/06/why-abstract-class-is-important-in-java.html
One more classic question from Programming Job interviews, it is as old as chuck Norris. An abstract class is a class which can have state, code and implementation, but an interface is a contract which is totally abstract. Since I have answered it many times, I am only giving you the gist here but you should read the article linked to answer to learn this useful concept in much more detail.

#### Which one is better constructor injection or setter dependency injection
http://javarevisited.blogspot.sg/2012/11/difference-between-setter-injection-vs-constructor-injection-spring-framework.html
Each has their own advantage and disadvantage. Constructor injection guaranteed that class will be initialized with all its dependency, but setter injection provides flexibility to set an optional dependency. Setter injection is also more readable if you are using an XML file to describe dependency. Rule of thumb is to use constructor injection for mandatory dependency and use setter injection for optional dependency.

#### What is difference between dependency injection and factory design pattern
http://javarevisited.blogspot.sg/2015/06/difference-between-dependency-injection.html
Though both patterns help to take out object creation part from application logic, use of dependency injection results in cleaner code than factory pattern. By using dependency injection, your classes are nothing but POJO which only knows about dependency but doesn't care how they are acquired. In the case of factory pattern, the class also needs to know about factory to acquire dependency. hence, DI results in more testable classes than factory pattern. Please see the answer for a more detailed discussion on this topic.

#### Difference between Adapter and Decorator pattern
http://javarevisited.blogspot.sg/2015/01/adapter-vs-decorator-vs-facade-vs-proxy-pattern-java.html
Though the structure of Adapter and Decorator pattern is similar, the difference comes on the intent of each pattern. The adapter pattern is used to bridge the gap between two interfaces, but Decorator pattern is used to add new functionality into the class without the modifying existing code.

#### Difference between Adapter and Proxy Pattern
http://javarevisited.blogspot.sg/2015/01/adapter-vs-decorator-vs-facade-vs-proxy-pattern-java.html
Similar to the previous question, the difference between Adapter and Proxy patterns is in their intent. Since both Adapter and Proxy pattern encapsulate the class which actually does the job, hence result in the same structure, but Adapter pattern is used for interface conversion while the Proxy pattern is used to add an extra level of indirection to support distribute, controlled or intelligent access.

#### What is Template method pattern
Template pattern provides an outline of an algorithm and lets you configure or customize its steps. For examples, you can view a sorting algorithm as a template to sort object. It defines steps for sorting but let you configure how to compare them using Comparable or something similar in another language. The method which outlines the algorithms is also known as template method.

#### When do you use Visitor design pattern
The visitor pattern is a solution of problem where you need to add operation on a class hierarchy but without touching them. This pattern uses double dispatch to add another level of indirection.
#### When do you use Composite design pattern
Composite design pattern arranges objects into tree structures to represent part-whole hierarchies. It allows clients treat individual objects and container of objects uniformly. Use Composite pattern when you want to represent part-whole hierarchies of objects.

#### The difference between Inheritance and Composition
http://javarevisited.blogspot.sg/2015/06/difference-between-inheritance-and-Composition-in-Java-OOP.html
Though both allows code reuse, Composition is more flexible than Inheritance because it allows you to switch to another implementation at run-time. Code written using Composition is also easier to test than code involving inheritance hierarchies.

#### Describe overloading and overriding in Java
http://java67.blogspot.sg/2012/09/difference-between-overloading-vs-overriding-in-java.html
Both overloading and overriding allow you to write two methods of different functionality but with the same name, but overloading is compile time activity while overriding is run-time activity. Though you can overload a method in the same class, but you can only override a method in child classes. Inheritance is necessary for overriding.

#### The difference between nested public static class and a top level class in Java
http://javarevisited.blogspot.sg/2012/12/inner-class-and-nested-static-class-in-java-difference.html
You can have more than one nested public static class inside one class, but you can only have one top-level public class in a Java source file and its name must be same as the name of Java source file.

#### Difference between Composition, Aggregation and Association in OOP
http://javarevisited.blogspot.sg/2014/02/ifference-between-association-vs-composition-vs-aggregation.html
If two objects are related to each other, they are said to be associated with each other. Composition and Aggregation are two forms of association in object-oriented programming. The composition is stronger association than Aggregation. In Composition, one object is OWNER of another object while in Aggregation one object is just USER of another object. If an object A is composed of object B then B doesn't exist if A ceased to exists, but if object A is just an aggregation of object B then B can exists even if A ceased to exist.

#### Give me an example of design pattern which is based upon open closed principle
http://javarevisited.blogspot.sg/2011/11/great-example-of-open-closed-design.html
This is one of the practical questions I ask experienced Java programmer. I expect them to know about OOP design principles as well as patterns. Open closed design principle asserts that your code should be open for extension but closed for modification. Which means if you want to add new functionality, you can add it easily using the new code but without touching already tried and tested code.  There are several design patterns which are based upon open closed design principle e.g. [Strategy pattern](http://java67.blogspot.com/2014/12/strategy-pattern-in-java-with-sample.html) if you need a new strategy, just implement the interface and configure, no need to modify core logic. One working example is Collections.sort() method which is based on Strategy pattern and follows the open-closed principle, you don't modify sort() method to sort a new object, what you do is just implement Comparator in your own way.

#### Difference between Abstract factory and Prototype design pattern
This is the practice question for you, If you are feeling bored just reading and itching to write something, why not write the answer to this question. I would love to see an example the, which should answer where you should use the Abstract factory pattern and where is the Prototype pattern is more suitable.

#### When do you use Flyweight pattern
This is another popular question from the design pattern. Many Java developers with 4 to 6 years of experience know the definition but failed to give any concrete example. Since many of you might not have used this pattern, it's better to look examples from JDK. You are more likely have used them before and they are easy to remember as well. Now let's see the answer.
Flyweight pattern allows you to share object to support large numbers without actually creating too many objects. In order to use Flyweight pattern, you need to make your object Immutable so that they can be safely shared. String pool and pool of Integer and Long object in JDK are good examples of Flyweight pattern.
#### Miscellaneous Java Interview Questions
It contains XML Processing in Java Interview question, JDBC Interview question, Regular expressions Interview questions, Java Error and Exception Interview Questions, Serialization,
#### The difference between nested static class and top level class
http://java67.blogspot.sg/2012/10/nested-class-java-static-vs-non-static-inner.html
One of the fundamental questions from Java basics. I ask this question only to junior Java developers of 1 to 2 years of experience as it's too easy for an experience Java programmers. The answer is simple, a public top level class must have the same name as the name of the source file, there is no such requirement for nested static class. A nested class is always inside a top level class and you need to use the name of the top-level class to refer nested static class e.g. HashMap.Entry is a nested static class, where HashMap is a top level class and Entry is nested static class.

#### Can you write a regular expression to check if String is a number
http://javarevisited.blogspot.sg/2012/10/regular-expression-example-in-java-to-check-String-number.html
If you are taking Java interviews then you should ask at least one question on the regular expression. This clearly [differentiates an average programmer with a good programmer](http://javarevisited.blogspot.com/2015/05/how-to-differentiate-between-average.html). Since one of the traits of a good developer is to know tools, regex is the best tool for searching something in the log file, preparing reports etc. Anyway, answer to this question is, a numeric String can only contain digits i.e. 0 to 9 and + and - sign that too at start of the String, by using this information you can write following regular expression to check if given String is number or not
#### The difference between checked and unchecked Exception in Java
http://java67.blogspot.sg/2012/12/difference-between-runtimeexception-and-checked-exception.html
checked exception is checked by the compiler at compile time. It's mandatory for a method to either handle the checked exception or declare them in their throws clause. These are the ones which are a sub class of Exception but doesn't descend from RuntimeException. The unchecked exception is the descendant of RuntimeException and not checked by the compiler at compile time. This question is now becoming less popular and you would only find this with interviews with small companies, both investment banks and startups are moved on from this question.

#### The difference between throw and throws in Java
http://javarevisited.blogspot.sg/2012/02/difference-between-throw-and-throws-in.html
the throw is used to actually throw an instance of java.lang.Throwable class, which means you can throw both Error and Exception using throw keyword e.g.

```
throw new IllegalArgumentException("size must be multiple of 2")
```


On the other hand, throws is used as part of method declaration and signals which kind of exceptions are thrown by this method so that its caller can handle them. It's mandatory to declare any unhandled checked exception in **throws** clause in Java. Like the previous question, this is another frequently asked Java interview question from errors and exception topic but too easy to answer.

#### The difference between Serializable and Externalizable in Java
http://javarevisited.blogspot.sg/2012/01/serializable-externalizable-in-java.html
This is one of the frequently asked questions from Java Serialization. The interviewer has been asking this question since the day Serialization was introduced in Java, but yet only a few good candidate can answer this question with some confidence and practical knowledge. Serializable interface is used to make Java classes serializable so that they can be transferred over network or their state can be saved on disk, but it leverages default serialization built-in JVM, which is expensive, fragile and not secure. Externalizable allows you to fully control the Serialization process, specify a custom binary format and add more security measure.

#### The difference between DOM and SAX parser in Java
http://javarevisited.blogspot.sg/2011/12/difference-between-dom-and-sax-parsers.html
Another common Java question but from XML parsing topic. It's rather simple to answer and that's why many interviewers prefers to ask this question on the telephonic round. DOM parser loads the whole XML into memory to create a tree based DOM model which helps it quickly locate nodes and make a change in the structure of XML while SAX parser is an event based parser and doesn't load the whole XML into memory. Due to this reason DOM is faster than SAX but require more memory and not suitable to parse large XML files.

#### Tell me 3 features introduced on JDK 1.7
http://javarevisited.blogspot.sg/2014/04/10-jdk-7-features-to-revisit-before-you.html
This is one of the good questions I ask to check whether the candidate is aware of recent development in Java technology space or not. Even though JDK 7 was not a big bang release like JDK 5 or JDK 8, it still has a lot of good feature to count on e.g. try-with-resource statements, which free you from closing streams and resources when you are done with that, Java automatically closes that. Fork-Join pool to implement something like the Map-reduce pattern in Java. Allowing String variable and literal into switch statements. Diamond operator for improved type inference, no need to declare generic type on the right-hand side of variable declaration anymore, results in more readable and succinct code. Another worth noting feature introduced was improved exception handling e.g. allowing you to catch multiple exceptions in the same catch block.

#### Tell me 5 features introduced in JDK 1.8
http://javarevisited.blogspot.sg/2014/02/10-example-of-lambda-expressions-in-java8.html
This is the follow-up question of the previous one. Java 8 is path breaking release in Java's history, here are the top 5 features from JDK 8 release

- **Lambda expression**, which allows you pass an anonymous function as object.
- **Stream API**, take advantage of multiple cores of modern CPU and allows you to write succinct code.
- **Date and Time API**, finally you have a solid and easy to use date and time library right into JDK
- **Extension methods**, now you can have static and default method into your interface
- **Repeated annotation**, allows you apply the same annotation multiple times on a type

#### What is the difference between Maven and ANT in Java
http://javarevisited.blogspot.sg/2015/01/difference-between-maven-ant-jenkins-and-hudson.html
Another great question to check the all round knowledge of Java developers. It's easy to answer questions from core Java but when you ask about setting things up, building Java artifacts, many Java software engineer struggles. Coming back to the answer of this question, Though both are build tool and used to create Java application build, Maven is much more than that. It provides standard structure for Java project based upon "convention over configuration" concept and automatically manage dependencies (JAR files on which your application is dependent) for Java application. Please see the answer for more differences between Maven and ANT tool.


That's all guys, **lots of Java Interview questions?** isn't it? I am sure if you can answer this list of Java questions you can easily crack any core Java or advanced Java interview. Though I have not included questions from Java EE or J2EE topics e.g. Servlet, JSP, JSF, JPA, JMS, EJB or any other Java EE technology or from major web frameworks like Spring MVC, Struts 2.0, Hibernate or both SOAP and RESTful web services, it's still useful for Java developers preparing for Java web developer position, because every Java interview starts with questions from fundamentals and JDK API. If you think, I have missed any popular Java question here and you think it should be in this list then feel free to suggest me. My goal is to create the best list of Java Interview Questions with latest and greatest question from recent interviews.
## Spring
### [OK] What is IOC or inversion of control
http://javarevisited.blogspot.com/2012/12/inversion-of-control-dependency-injection-design-pattern-spring-example-tutorial.html

**Inversion of the control** means now we have inverted the control of creating the object from our own using new operator to container or framework.

Now it’s the responsibility of the container to create an object as required. We maintain one XML file where we configure our components, services, all the classes, and their property. We just need to mention which service is needed by which component and container will create the object for us.

This concept is known as dependency injection because all object dependency (resources) is injected into it by the framework.
### [OK] Explain the Spring Bean-LifeCycle
Spring framework is based on IoC so we call it as IoC container. Following steps explain their life cycle inside the container:

1. The container will look the bean definition inside the configuration file (e.g. bean.xml).
2. Using reflection container will create the object and if any property is defined inside the bean definition then it will also be set.
3. If the bean implements the `BeanNameAware` interface, the factory calls `setBeanName()` passing the bean’s ID.
4. If the bean implements the `BeanFactoryAware` interface, the factory calls `setBeanFactory()`, passing an instance of itself.
5. If there are any `BeanPostProcessors` associated with the bean, their post- `ProcessBeforeInitialization()` methods will be called before the properties for the Bean are set.
6. If an `init()` method is specified for the bean, it will be called.
7. If the Bean class implements the `DisposableBean` interface, then the destroy() method will be called when the Application no longer needs the bean reference.
8. If the Bean definition in the `Configuration` file contains a 'destroy-method' attribute, then the corresponding method definition in the Bean class will be called.
### [OK] What is Bean Factory, have you used XMLBeanFactory
`BeanFactory` is factory Pattern which is based on IOC design principles. it is used to make a clear separation between application configuration and dependency from actual code. The `XmlBeanFactory` is one of the implementations of Bean Factory which we have used in our project.

```java
BeanFactory factory = new XmlBeanFactory(new FileInputStream("beans.xml"));

// OR 

ClassPathResource resorce = new ClassPathResource("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(resorce);
```
### [OK] What are the difference between `BeanFactory` and `ApplicationContext`
http://javarevisited.blogspot.com/2012/11/difference-between-beanfactory-vs-applicationcontext-spring-framework.html

`ApplicationContext` is the preferred way of using spring because of the functionality provided by it and the interviewer wanted to check whether you are familiar with it or not.

| **ApplicationContext.**                                      | **BeanFactory**                           |
| ------------------------------------------------------------ | ----------------------------------------- |
| Here we can have more than one config files possible         | In this only one config file or .xml file |
| Application contexts can publish events to beans that are registered as listeners | Don't support.                            |
| Support internationalization (I18N) messages                 | It’s not                                  |
| Support application life-cycle events, and validation.       | Doesn’t support.                          |
| Supports many enterprise services such as JNDI access, EJB integration, remoting | Doesn’t support.                          |
### [OK] What is AOP
The core construct of AOP is the aspect, which encapsulates behaviors affecting multiple classes into reusable modules. AOP is a programming technique that allows a developer to modularize crosscutting concerns, that cuts across the typical divisions of responsibility, such as **logging and transaction management.**
### [OK] Explain Advice
It’s an implementation of aspect; advice is inserted into an application at join points. Different types of advice include “around,” “before” and “after” advice
### [OK] What are the JointPoint and point cut
This is not really a spring interview questions I would say an AOP one. Similar to Object-oriented programming, AOP is another popular programming concept which complements OOPS. A join point is an opportunity within the code for which we can apply an aspect. In Spring AOP, a join point always represents a method execution.

**Pointcut** a predicate that matches join points. A pointcut is something that defines what join-points advice should be applied.
### [OK] Difference between the setter and constructor injection in Spring
http://javarevisited.blogspot.com/2012/11/difference-between-setter-injection-vs-constructor-injection-spring-framework.html
Setter injection is more flexible than constructor injection because you must remember the type and order of constructor parameter. Also, constructor injection is generally used to inject the mandatory dependency, while setter can be used to inject the optional dependency.
### [OK] Difference between Factory Pattern and Dependency Injection in Java
http://javarevisited.blogspot.com/2015/06/difference-between-dependency-injection.html

Even though both allow you to reduce coupling in code, dependency injection is much more flexible and easier to test than Factory pattern.
### [OK] Difference between `@Autowired` and `@Inject` annotation in Spring
W zasadzie obie adnotację robią to samo tzn. wstrzykują zależności. Adnotacja `@Autowired` jest specyficzna dla Springa natomiast adnotacja `@Inject` jest ogólnym standardem. Adnotacja `@Inject` jest używana w bibliotece Google Guice.

Adnotacja `@Inject` jest dopiero wspierana przez Springa od wersji 3.0. Adnotacja `@Inject` została wprowadzana razem ze standardem JSR-330.

https://javarevisited.blogspot.com/2017/04/difference-between-autowired-and-inject-annotation-in-spring-framework.html#axzz5nFQiRhkv
### [OK] What are the different modules in spring
Spring has seven core modules

1. The Core container module
2. Application context module
3. AOP module (Aspect Oriented Programming)
4. JDBC abstraction and DAO module
5. O/R mapping integration module (Object/Relational)
6. Web module
7. MVC framework module
### [OK] What is the difference between @Controller and @RestController in Spring MVC
http://javarevisited.blogspot.sg/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html
Even though both are used to indicate that a Spring bean is a Controller in Spring MVC setup, `@RestController` is better when you are developing RESTful web services using Spring MVC framework. It's a combination of `@Controller + @ResponseBody` annotation which allows the controller to directly write the response and bypassing the view resolution process, which is not required for RESTful web service.

It also instructs DispatcherServlet to use different HttpMessageConverters to represent the response in the format client is expecting e.g. HttpMessageJackson2Convert to represent response in JSON format and JAXB based message converts to generate XML response.
### [OK] What is the difference between a singleton and prototype bean
This is another popular *spring interview questions* and an important concept to understand. Basically, a bean has scopes which define their existence on the application.

**Singleton:** means single bean definition to a single object instance per Spring IoC container.

**Prototype**: means a single bean definition to any number of object instances.
### [OK] What is the role of DispatcherServlet in Spring MVC
http://www.java67.com/2017/06/what-is-use-of-dispatcherservlet-in-spring-mvc.html
The DispatcherServlet is very important from Spring MVC perspective, it acts as a FrontController i.e. all requests pass through it. It is responsible for routing the request to the controller and view resolution before sending the response to the client.

When Controller returns a Model or View object, it consults all the view resolvers registered to find the correct type of ViewResolver which can render the response for clients.

In case of RESTful Web Services, the DispatcherServlet is also responsible for using HttpMessageConverter to represent the response in the JSON, XML, or TEXT format, depending on the content negotiation between Client and Server like if client sends request with HTTP accept header as "application/json" then DispatcherServlet will ask the HttpMessageJackson2Converter to convert the response into JSON format.
### How to call the stored procedure from Java using Spring Framework
http://javarevisited.blogspot.com/2013/04/spring-framework-tutorial-call-stored-procedures-from-java.html
### How to Setup JDBC Database connection pool in Spring Web application
http://javarevisited.blogspot.com/2012/06/jdbc-database-connection-pool-in-spring.html
### [OK] Difference between @ReqeustParam and @PathVariable in Spring MVC
https://javarevisited.blogspot.com/2017/10/differences-between-requestparam-and-pathvariable-annotations-spring-mvc.html

`@ReqeustParam` pozwala na pobranie parametrów z zapytania czyli z tgz. query params. Natomiast `@PathVariable` pozwala na wyciągnięcie parametrów ze ścieżki.

```java
@RequestMapping(value="/order/{orderId}/receipts", method = RequestMethod.GET) public List listUsersInvoices( @PathVariable("orderId") int order, @RequestParam(value = "date", required = false) Date dateOrNull) { ... }
```
### [OK] Difference between @Component, @Service, @Controller, and @Repositoring annotation in Spring MVC
https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html
### [OK] What type of transaction Management Spring support
This spring interview question is a little difficult as compared to previous questions just because **transaction management** is a complex concept and not every developer familiar with it. Transaction management is critical in any applications that will interact with the database.

The application has to ensure that the data is consistent and the integrity of the data is maintained.  Following two types of transaction management is supported by spring:

1. Programmatic transaction management
2. Declarative transaction management.
### [OK] How do you control the concurrent Active session using Spring Security
Another Spring interview question which is based on Out of box feature provided by Spring framework. You can easily control How many active session a user can have with a Java application by using Spring Security.

Apart from that Spring Security also provides the "remember me" feature which you can use to provide easier access for your users by remembering their login details on their personal computer. 
### [OK] How do you set up LDAP Authentication using Spring Security
This is a very popular Spring Security interview question as Spring provides out of the box support to connect Windows Active Directory for LDAP authentication and with few configurations in Spring config file you can have this feature enabled.

How to implement Role Based Access Control (RBAC) using Spring Security
Spring Security provides a couple of ways to implement Role based access control like by using GrantedAuthority. See the article to learn more about it.
### [OK] What is Spring Boot? Why should you use it
Spring Boot is another Java framework from Sring umbrella which aims to simplify the use of Spring Framework for Java development. It removes most of the pain associated with dealing with Spring e.g. a lot of configuration and dependencies and a lot of manual setups.

Why should you use it? Well, Spring Boot not only provides a lot of convenience by auto-configuration a lot of things for you but also improves the productivity because it lets you focus only on writing your business logic.

For example, *you don't need to setup a Tomcat server* to run your web application. You can just write code and run it as Java application because it comes with an embedded Tomcat server. You can also create a JAR file or WAR file for deployment based on your convenience.

In short, there are many reasons to use Spring Boot. In fact, it's now the standard way to develop Java application with Spring framework.
### What are some important features of using Spring Boot
This is a good subjective question and used by the interviewer to gauge the experience of a candidate with Spring Boot. Anyway, following are some of the important features of Spring Boot framework:

1. Starter dependency
   This feature aggregates common dependencies together. For example, if you want to develop Spring MVC based [RESTful services](http://www.java67.com/2017/10/how-to-test-restful-web-services-using.html) then instead of including Spring MVC JAR and Jackson JAR file into classpath you can just specify spring-boot-web-starter and it will automatically download both those JAR files. Spring Boot comes with many such starter dependencies to improve productivity.
2. Auto-Configuration
   This is another awesome features of Spring Boot which can configure many things for you. For example, If you are developing Spring web application and Thymeleaf.jar is present on the classpath then it can automatically configure Thymeleaf template resolver, view resolver, and other settings. A good knowledge of auto-configuration is required to become an experienced Spring Boot developers.
3. Spring Initializer
   A web application which can create initial project structure for you. This simplifies initial project setup part
4. Spring Actuator
   This feature provides a lot of insights of a running Spring boot application. For example, you can use Actuator to find out which beans are created in Spring's application context and which request path are mapped to controllers.
5. Spring CLI
   This is another awesome feature of Spring Boot which really takes Spring development into next level. It allows you to use Groovy for writing Spring boot application which means a lot more concise code.
### What is auto-configuration in Spring boot? Why Spring Boot is called opinionated
For example, it can configure JdbcTemplate if its present and a DataSource bean are available in the classpath. It can even do some basic web security stuff if Spring security is present in the classpath.

Anyway, the point is auto-configuration does a lot of work for you with respect to configuring beans, controllers, view resolvers etc, hence it helps a lot in creating a Java application.

Now, the big questions come, why it's considered opinionated? Well because it makes a judgment on its own. Sometimes it imports things which you don't want, but don't worry, Spring Boot also provides ways to override auto-configuration settings.

It's also disabled by default and you need to use either `@SpringBootApplication` or `@EnableAutoConfiguration` annotations on the Main class to enable the auto-configuration feature.
### What is starter dependency in Spring Boot? How does it help
This question is generally asked as a follow-up of the previous question as it's quite similar to auto-configuration and many developers get confused between both of them. As the name suggests, starter dependency deal with dependency management.

After examining several Spring-based projects Spring guys notice that there is always some set of libraries which are used together e.g. Spring MVC with Jackson for creating RESTful web services. Since declaring a dependency in Maven's pom.xml is the pain, they combined many libraries into one based upon functionality and created this starter package.

This not only frees you from declaring many dependencies but also fees you from compatibility and version mismatch issue. Spring Boot starter automatically pulls compatible version of other libraries so that you can use them without worrying about any compatibility issue.
### What is the difference between @SpringBootApplication and @EnableAutoConfiguration annotation
Even though both are essential Spring Boot application and used in the Main class or Bootstrap class there is a subtle difference between them. The @EnableAutoConfiguration is used to enable auto-configuration but @SpringBootApplication does a lot more than that.

It also combines @Configuration and @ComponentScan annotations to enable Java-based configuration and component scanning in your project.

The @SpringBootApplication is in fact combination of @Configuration, @ComponentScan and @EnableAutoConfiguration annotations.
### What is Spring Actuator? What are its advantages
Spring Actuator provides all that information. It provides several endpoints e.g. a REST endpoint to retrieve this kind of information over the web. It also provides a lot of insight and metrics about application health e.g. CPU and memory usage, number of threads etc.

It also comes with a remote shell which you can use to securely go inside Spring Boot application and run some command to expose the same set of data. You can even use JMX to control this behavior at runtime.

it's important to secure your Spring Actuator endpoints because it exposes a lot of confidential information and a potentially dangerous one-two. For example, by using /showdown endpoint you can kill a Spring Boot application.
### What is Spring Boot CLI? What are its benefits
Spring Boot CLI is a command line interface which allows you to create Spring-based Java application using Groovy. Since it's used Groovy, it allows you to create Spring Boot application from the command line without ceremony e.g. you don't need to define getter and setter method, or access modifiers, return statements etc.
### Where do you define properties in Spring Boot application
You can define both application and Spring boot related properties into a file called application.properties. You can create this file manually or you can use Spring Initializer to create this file, albeit empty.
### Can you change the port of Embedded Tomcat server in Spring boot? If Yes, How?
Yes, we can change the port of Embedded Tomcat Server in Spring Boot by adding a property called `server.port` in the `application.properties` file.
### What is the difference between an embedded container and a WAR
The main difference between an embedded container and a WAR file is that you can Spring Boot application as a JAR from the command prompt without setting up a web server. But to run a WAR file, you need to first set up a web server like Tomcat which has Servlet container and then you need to deploy WAR there.
### What embedded containers does Spring Boot support
Spring Boot support three embedded containers: 

1. Tomcat, 
2. Jetty,
3. Undertow. 

By default, it uses Tomcat as embedded containers but you can change it to Jetty or Undertow.

What are some common Spring Boot annotations

1. `@SpringBootApplication`,
2. `@SpringBootTest`,
3. `@EnableAutoConfiguration`,
### Can you name some common Spring Boot Starter POMs?
Some of the most common Spring Boot Start dependencies or POMs are:

1. spring-boot-starter, 

2. spring-boot-starter-web, 

3. spring-boot-starter-test. 

You can use spring-boot-starter-web to enable Spring MVC in Spring Boot application.
### Can you control logging with Spring Boot? How
Yes, we can control logging with Spring Boot by specifying log levels on `application.properties` file. Spring Boot loads this file when it exists in the classpath and it can be used to configure both Spring Boot and application code.

Spring Boot uses Commons Logging for all internal logging and you can change log levels by adding following lines in the application.properties file:

```properties
logging.level.org.springframework=DEBUG
logging.level.com.demo=INFO
```
### What is the concept of AOP
AOP stands for Aspect-Oriented Programming and it helps decouple cross-cutting concerns from the object that they affect. It's similar to [Dependency Injection](https://javarevisited.blogspot.com/2012/12/inversion-of-control-dependency-injection-design-pattern-spring-example-tutorial.html) in the sense that DI helps decouple an application's object from each other.
### Which problem AOP solves
AOP helps in separating cross-cutting concerns from the business logic, which results in cleaner code and also helps developers to focus on building business logic.
### What is a cross-cutting concern
crossing cutting concern is common functionality that is scattered around multiple places. They are common and you aspect they should be structured but they are not, which makes them hard to manage. AOP helps them to manage the cross-cutting concerns.
### Can you name three typical cross-cutting concerns
There are many cross-cutting concerns but the three most common ones are [logging](https://www.java67.com/2020/04/how-to-send-logger-messages-to-syslog-using-log4j-java-linux.html), [security](https://javarevisited.blogspot.com/2017/06/3-best-spring-security-online-training-courses-java-programmers.html), and caching.
### What two problems arise if you don’t solve a cross-cutting concern via AOP
It will make your code clutters as concerns will be spread across your application, which will be hard to manage.
### What is a pointcut, a join point, advice, an aspect, weaving
These are common AOP terms that every programmer needs to know as you just cannot work in AOP without knowing these terms. They are the backbone of AOP but at the same time they are not intuitive and boring and hard to understand, anyway, let's try to learn them.

| Name     | Description                                                  |
| -------- | ------------------------------------------------------------ |
| Aspect   | An aspect is a common feature that's typically scattered across methods, classes, object hierarchies, or even entire object models. |
| Advice   | This is the functionality that is applied using AOP. It defines the "what" and "when" part of the aspect.JoinPoint<br/>These are the places where you can apply your "advice". There can be multiple join points in the flow of a program |
| Pointcut | They are used to find the join points where advice needs to be applied. You can define Pointcut by class name or method name, or you can use regular expressions to find different join points to apply your advice. |
| Weaving  | This is a process of applying aspects to a target object to create a new proxied object. In simple words, it's a process when the AOP library or framework adds dynamic code to alter the behavior of your program. For example, compile-time weaving can add new code at compile time. |
### How does Spring solve (implement) a cross-cutting concern
Spring uses proxy objects to implement the method invocation interception part of Aspect-Oriented Programming. Such proxy objects wrap the original Spring bean and intercept method invocations as specified by the set of pointcuts defined by the cross-cutting concern.

This means when you call a method on a spring bean, the method on a proxy object is called which extends the original spring bean. It then does whatever it has to do as part of implementing cross-cutting concern like logging or security check and then call the original method.
### What are the two proxy-types used in Spring AOP
There are two dynamic proxy techniques used in spring AOP, JDK dynamic proxy and CGLIB proxy

1. JDK dynamic proxy
   In the case of JDK dynamic proxy, Proxies are created at runtime by generating a class that implements all the interfaces that the target object implements. Since standard Java features are used, no additional libraries are required. It's also worth noting that JDK dynamic proxies are the default proxy mechanism used by Spring AOP.
2. CGLIB proxy
   This is another way to generate Proxy objects in Spring, it requires a third-party library called CGLIB which is included in the spring-core JAR. CGLIB proxies are created by generating a subclass of the class implementing the target object.

The CGLIB proxy mechanism will be used by Spring AOP when the Spring bean for which to create a proxy does not implement any interfaces. It is also possible to instruct Spring AOP to use CGLIB proxies by default using annotation `@EnableAspectJAutoProxy(proxyTargetClass = true)`

Another worth noting thing is that Spring Java configuration classes, annotated with `@Configuration`, will always be proxied using CGLIB.
### What are the limitations of the two proxy-types used in Spring AOP
As stated in the last question, Spring AOP uses JDK proxy and CGLIB proxies and both proxy objects have the same limitation: the invocation of advised methods on self.

If a method in the proxy calls another method in the proxy, and both match the pointcut expression of advice, the advice will be executed only for the first method. This is the proxy’s nature: it executes the extra behavior only when the caller calls the target method.


Apart from that here are some more limitation of each proxy types:

JDK Dynamic Proxies Limitations

- your target object must implement an interface.
- only public methods will be proxied.
- any methods found in the target object but not in any interface implemented by the target object cannot be proxied.
- aspects can be applied only to Spring Beans. That means even if Spring AOP is not set to use CGLIB proxies if a Join Point is in a class that does not implement an interface, Spring AOP will try to create a CGLIB proxy.

CGLIB Proxy Limitations

- class and Methods cannot be final
- only public and protected methods can be proxied.
- it takes more time to create a proxy object, although it has better performance

These are some notable differences between JDK proxies and CGLIB proxies.
### What visibility must Spring bean methods have to be proxied using Spring AOP
Only public methods of Spring beans will be proxied Additionally the call to the public method must originate from outside of the Spring bean.
### How many advice types do Spring support? Can you name each one
Spring Aspects can work with five types of advice:

1. `@Before`
   This advice functionality takes place before the advised method is invoked.
2. `@After`
   The advice functionality takes place after the advised method completes

3. `@AfterReturning`
   This advice functionality is implemented after the advised method successfully completes.

4. `@AfterThrowing`
   This advice functionality is implemented after the advised method throws an Exception.

5. `@Around`
   This advice wrap the advised method, provided some functionality before and after the advised method is invoked
### What are they used for
Now that you know different types of advice you can actually think where can they be used, nonetheless here are some points

1. `@Before`
   Since before advice always proceed to the join point unless execution is thrown from within the advice code you can use this for Access control, security, and Statistics

2. `@AfterReturning`
   In this advice functionality takes place after the execution of a join point has completed without throwing any exceptions and you can use this for statistics and Data validation

3. `@AfterThrowing`
   This is invoked after the execution of a join point that resulted in an exception being thrown
   Error handling you can use this to send alerts to your monitoring tools when an error has occurred as well for error recovery.

4. `@After`
   This advice will execute after a join point execution, no matter how the execution ended (even exception happens). You can use this for releasing resources just like the final clause in Java.

5. `@Around`
   This is multi-purpose advice and can be used for all of the use-cases for AOP.
### Which types of advice you can use to try and catch exceptions
You can use both `@Around` and `@AfterThrowing` advice in this case but only `@Around` advice allows you to catch exceptions in the advice that occur during the execution of a join point.
### What is the JoinPoint argument used for
A JoinPoint argument can be used to retrieve additional information about the join point during execution. If used, JoinPoint needs to be the first parameter of Advice, only, in that case, Spring Framework will inject JoinPoint into advice method.

JoinPoint is supported in `@Before, @After, @AfterReturning`, and `@AfterThrowing` advice and you can use JointPoint different kinds of information like:

- The string representation of JoinPoint
- Arguments of JoinPoint (for example Method Arguments)
- Signature of JoinPoint (for example Method Signature)
- Type of JoinPoint
- Target object being proxied
### What is a ProceedingJoinPoint? Which advice type is it used with
The ProceedingJoinPoint class is a parameter to an `@Around` advice. When used it should be the first parameter of a method implementing an around advice. When it’s ready to pass control to the advised method, it will call ProceedingJoinPoint’s proceed() method, which is used to execute the actual method.

Here is an example of using ProceedingJoinPoint advice:

```java
@Aspect
public class Book {
  @Pointcut("execution(** libary.Book.read(..))")
  public void read() {}

  @Around("read()")
  public void sitAndRead(ProceedingJoinPoint jp) {
    try {
      System.out.println("sit down and relax");
      jp.proceed(); //this is important, you must call proceed on ProceedingJoinPoint
     } catch (Throwable e) {
       System.out.println("sorry, other time");
     }
   }
}
```
### Can you name some popular Aspect-oriented programming libraries
Here is a list of some of the popular AOP libraries you can use to implement AOP in your application:

1. AspectJ
2. JBoss AOP
3. Spring AOP
### What are the different types of Weaving which is available in AOP
There are many types of weaving available in different AOP libraries like compile-time weaving, weaving at the time of class loading, or weaving when the method gets called. That's all about the **frequently asked Spring AOP Interview Questions**. While Spring AOP is not a very popular topic on Java and Spring Boot interviews, it's very important for anyone who wants to master the spring framework. AOP plays an important part in the Spring framework and it will help you understand how the Spring framework works behind the scene. If you want to understand the magic of Spring Framework and Spring Boot, learning Spring AOP will be key.
## Współbieżność
### Pytania Ogólne
#### Na czym polega współbieżność
Współbieżność to możliwość wykonywania wielu operacji jednocześnie. Dzięki współbieżności nasz program jest w stanie obsłużyć wielu użytkowników na raz, wykonywać wiele obliczeń w tym samym czasie i działać wydajniej. Z pomocą wątków poprawia się wykorzystanie procesora i dostępnych na maszynie zasobów.

Współbieżność jest jak zakupy w supermarkecie, w którym klienci mogą swobodnie poruszać się po całej powierzchni sklepu i maksymalnie wykorzystywać swój czas. Przeciwieństwem współbieżności są sklepy starego typu, w których wszystkie towary są za ladą, a w jednej chwili może być obsługiwany tylko jeden klient.
#### Jakie są największe benefity współbieżności
Maksymalne wykorzystanie procesora, możliwość obsługi większego ruchu, brak tracenia czasu podczas czekania na operacje wejścia / wyjścia.
#### Jakie są największy wyzwania związane ze współbieżnością
Spójność danych, synchronizacja pracy wątków, zapobieganie zakleszczeniom i wywłaszczeniom wątków. Efektywna koordynacja pracy wątków – tak by zminimalizować fragmenty czasu, w którym muszą bezczynnie czekać lub blokować się w oczekiwaniu na pracę innych wątków.
### Pytania o Wątki
#### 1. Co to jest wątek? Czym się różni od procesu
Część programu wykonywana współbieżnie w obrębie jednego procesu; w jednym procesie może istnieć wiele wątków. (za [Wikipedią](https://pl.wikipedia.org/wiki/Wątek_(informatyka)))

Wątki z jednego procesu współdzielą przestrzeń adresową oraz struktury systemowe (otwarte pliki, sockety). Procesy posiadają niezależne zasoby.

Dzięki współdzielonej przestrzeni adresowej wątki mogą się ze sobą komunikować, ale trzeba uważać jak to robią.

Analogia ze świata realnego: procesy to rodziny żyjące osobno, nie mające ze sobą kontaktu, mające własne zasoby (dom, samochód, sprzęt RTV / AGD). Wątki to członkowie tych rodzin konkurujący ze sobą o wspólne zasoby (łazienka, konsola, itd.).
#### 2. Jak uruchomić wątek w Javie
Najprościej (ale niekoniecznie najlepiej) za pomocą metody `Thread#start`.

```java
Runnable task = ...;
Thread thread = new Thread(task);
thread.start();
```

Można też rozszerzyć klasę `Thread` własną i nadpisać w niej metodę `#run()`, ale to też nie jest najlepsze rozwiązanie.

Najlepiej skorzystać z [pul wątków](https://sztukakodu.pl/wspolbieznosc-pytania-rekrutacyjne/?utm_source=jvm-bloggers.com&utm_medium=link&utm_campaign=jvm-bloggers#pule-watkow) i tam przekazać zadanie do wykonania.
#### 3. Różnica między Runnable i Callable
`Runnable` i `Callable` to interfejsy służące do przekazywania zadań do wątków. Różnią się sygnaturą. `Runnable` posiada metodę `run` zwracającą typ `void`, a `Callable` posiada metodę `call` zwracającą generyczny typ (deklarowany przy tworzeniu instancji).

Aby wystartować `Runnable` wystarczy przekazać go do klasy `Thread`.

```
Runnable job = () -> System.out.println("Just doin my job");
Thread thread0 = new Thread(job);
thread0.start();
```

Aby wystartować `Callable` musimy opakować go w klasę `FutureTask`. Konstruktor `Thread` sam z siebie nie przyjmuje interfejsu `Callable` jako argumentu.

```
Callable<Long> result = () -> 42L;
FutureTask<Long> task = new FutureTask<>(result);
Thread thread = new Thread(task);
thread.start();
task.get();
```

Warto pamiętać, że metoda `Callable#call` może rzucić wyjątkiem, a `Runnable#run` nie.
#### 4. Co się stanie gdy kod w wątku rzuci wyjątkiem
W przypadku `Callable` zostanie on opakowany w wyjątek `ExecutionException` i rzucony w momencie odbioru wyniku (np. `task#get()` pokazany w poprzednim pytaniu).

W przypadku `Runnable` możemy rzucić tylko wyjątkiem *runtimowym*, a pojawienie się takiego wyjątku spowoduje zabicie takiego wątku – plus obsługę `handlerem`.

Zachowanie handlera wyjątku można zdefiniować samodzielnie definiując własny `UncaughtExceptionHandler`.

```java
thread0.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
       // twoja obslgua wyjatku
    }
});
```
#### 5. Co to jest wątek typu Deamon i do czego się przydaje
Aplikacja w Javie uruchamia się na wątku main. Program działa dopóty, dopóki wszystkie wątki w programie nie zakończą swojej pracy.
Wyjątkiem od tej reguły są wątki typu `deamon`. Nawet jeśli nie zakończyły one swojej pracy, to program może zakończyć swoje działanie (jednocześnie zabijając te wątki).
Wątki `deamon` przydają się to zadań pomocniczych potrzebnych podczas działania programu, jak np. oczyszczanie śmieci, obsługa cyklicznych zadań i tak dalej. Kluczowe jest by ich nagłe ubicie nie powodowało problemów w działaniu aplikacji.
#### 6. Co to jest ThreadLocal
`ThreadLocal` to typ w Javie pozwalający na przypisanie jakichś danych wyłącznie dla pojedynczego wątku. Dzięki temu dana klasa może przechowywać informacje tylko dla tego wątku ze 100% pewnością, że nie zostaną one przeczytane przez inny wątek.

Przykładowo jest to wykorzystywane w Springu, podczas obsługi żądań HTTP (powiązanych z wątkami), gdy dane użytkownika są przypisane w jednym miejscu w stosie wywołań, a mogą być potem odczytane w innym.
### Pule Wątków
#### 1. Jak działają pule wątków
Pula wątków składa się z dwóch elementów – wątków obsługujących zadania oraz kolejki na przyjmowanie tych zadań. Jeśli na pule wątków trafia zadanie, to jest ono wykonywane – w sytuacji gdy dostępny jest wolny wątek – lub czeka w kolejce, aż wolny wątek się pojawi.
#### 2. Dlaczego się je stosuje
Aby zapewnić lepszą stabilność aplikacji. Tworzenie wątków to kosztowna operacja, wiążącą się z utworzeniem wątku w samym systemie operacyjnym i mająca swój narzut czasowy.
O wiele lepiej jest zdefiniować liczbę wątków, którą chce się w aplikacji używać i wykorzystywać je do różnych zadań. Takie wątki mogą przez jakiś czas pozostawać bezczynne, ale i tak jest to wydajniejsze, niż ciągłe tworzenie i ubijanie wątków dla poszczególnych zadań.
#### 3. Jakie mamy rodzaje pul wątków w Javie
Zasadniczo mamy dwa rodzaje pul wątków – o stałej, lub zmiennej liczbie wątków. W tej drugiej sytuacji wątki są tworzone, gdy zadań na kolejce przybywa, oraz ubijanie, gdy przez określony czas liczba zadań do wykonania spada. Zazwyczaj jednak maksymalna ilość wątków w takiej puli jest ograniczona.

W Javie możemy wyróżnić w szczególności:

- pule wątków z 1 wątkiem,
- pule wątków ze stałą liczbą wątków (określaną w momencie tworzenia puli),
- pule wątków ze zmienną liczbą wątków (w zależności od liczby zadań przesłanych do puli).
#### 4. Jak tworzy się pule wątków
W Javie za pomocą fabryki `Executors`

```java
ExecutorService executor = Executors.newFixedThreadPool(4);
executor.submit(task);
```

Lub ręcznie wołając konstruktor odpowiedniej klasy, na przykład

```java
return new ThreadPoolExecutor(
    nThreads, nThreads,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<Runnable>()
);
```
#### 5. Ile zadań można wrzucić na pule wątków
Tyle ile przyjmuje kolejka obsługująca daną pulę. Przykładowo, w poniższym kodzie może to być ponad 2 miliardy obiektów (`Integer.MAX_VALUE`), natomiast warto pamiętać, że prawdopodobnie zakończy się to brakiem pamięci dla głównego procesu aplikacji.

```java
return new ThreadPoolExecutor(
    nThreads, nThreads,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<Runnable>()
);
```

Jeśli chcemy ograniczyć długość kolejki wystarczy, że przekażemy ten argument przy konstrukcji `LinkedBlockingQueue` – możemy też przekazać inną implementację kolejki.
#### 6. Co się dzieje, gdy wszystkie wątki są zajęte
Gdy wysyłamy zadanie na pule wątków, której wszystkie wątki są zajęte to czeka ono na kolejce do wykonania, lub w przypadku zapełnienia się całej kolejki, jest odrzucane i wyrzucany jest wyjątek.
### Synchronizacja
#### 1. Co to jest sekcja krytyczna? Jak ją utworzyć w Javie
Sekcja krytyczna to fragment kodu, który chcemy uchronić przed współbieżnym dostępem i zależy nam by mógł go wykonywać jednocześnie tylko jeden wątek na raz. W przeciwnym wypadku groziłoby to niespójnym stanem naszej aplikacji.

Przykładowo, metodę `acceptTransfer` chcielibyśmy objąć taką sekcją krytyczną.

```java
class Account {
    private BigDecimal balance;

    public void acceptTransfer(BigDecimal amount) {
        BigDecimal newBalance = balance.add(amount)
        this.balance = newBalance;
    }
}
```

Jednoczesne wejście do powyższej metody przez wiele wątków mogłoby doprowadzić otrzymania nieprawidłowej wartośći w zmiennej `balance`.
#### 2. Jakie znasz struktury do kontroli dostępu do sekcji krytycznej
1. Słowo kluczowe `synchronized`
2. locki – `ReentrantReadWriteLock`
3. semafory – `Semaphore`
4. bariery cykliczne – `CyclicBarrier`
5. latche – `CountDownLatch`
#### 3. Co to jest race condition (warunki wyścigu)
Sytuacja, w której wskutek niemal jednoczesnego wykonania fragmentu kodu przed dwa wątki (bez odpowiedniej synchronizacji) dochodzi do niepoprawnego stanu aplikacji.

Przykładem jest sytuacja zmiany stanu konta, w której oba wątki jednocześnie odczytują obecny stan – np. 1000 zł, jeden z nich dodaje 100 zł, a drugi odejmuje 500 zł. Bez synchronizacji ostateczny stan konta będzie wynosił 1100 zł lub 500 zł – w zależności, który wątek kiedy skończy swoją pracę, podczas gdy w rzeczywistości powinno to być 600 zł.
#### 4. Co to jest deadlock, livelock i starvation
1. Deadlock – sytuacja, w której dwa wątki wzajemnie czekają na zwolnienie danego warunku przez ten drugi, jednocześnie się blokując. Wątki nie zwalniają trzymanego przez siebie zasobu.
2. Livelock – podobna sytuacja, tylko teraz wątki zwalniają trzymany zasób i uzyskują dostęp do drugiego. Niestety nadal żaden z wątków nie ma dostępu do obu zasobów.
3. Starvation – zagłodzenie. Sytuacja, w której wątki o niższym priorytecie nie uzyskują w ogóle dostępu do danego zasobu.

Przykłady:
\1. Deadlock – dwie osoby w restauracji próbują zjeść obiad jednym kompletem sztućców. Jedna łapie za widelec, druga za nóż. Każda z nich czeka na drugi element by zacząć jeść, w efekcie czego nikt nie zjada posiłku.
\2. Livelock – podoba sytuacja, ale w tej sytuacji osoby odkładają sztućce na stół i łapią za drugi brakujący element. Nadal żadna z nich nie ma kompletu by skonsumować posiłek.
\3. Zagłodzenie – z konsoli do gier w domu ciągle korzysta starszy brat, który nie dopuszcza do zabawy młodszego rodzeństwa.
#### 5. Jak działa słowo kluczowe synchronized
Słowo kluczowe `synchronized` powoduje założenie `locka` na danej instancji obiektu.

```java
class Account {
    private BigDecimal balance;

    public synchronized void acceptTransfer(BigDecimal amount) {
        BigDecimal newBalance = balance.add(amount)
        this.balance = newBalance;
    }
}
```

W tej sytuacji, tylko jeden wątek może korzystać z metody `acceptTransfer` oraz innych metod klasy `Account`, w których słowo `synchronized` jest użyte.

`synchronized` można też użyć w ciele metody `synchronized(this)` lub na innym obiekcie, np. `synchronized(lock)`.

```java
class Account {
    private BigDecimal balance;
    private Object writeLock;

    public void acceptTransfer(BigDecimal amount) {
        synchronized(writeLock) {
            BigDecimal newBalance = balance.add(amount)
            this.balance = newBalance;
        }
    }

}
```
#### 6. Co to jest ReentrantLock
Klasa służąca do synchronizacji dostępu do sekcji krytycznej. Wymaga utworzenia własnej instancji, zachowuje się podobnie do słowa kluczowego `synchronized`, ale daje dodatkowe możliwości.

Przykładem są metody `tryLock` służące do szybkiego powrotu do wykonywania operacji, w momencie gdy `locka` nie uda się uzyskać.
#### 7. Czym się różni ReentrantLock od synchronized
`ReentrantLock` to klasa, wymagająca utworzenia własnej instancji, posiadająca własne metody, które trzeba zawołać aby doprowadzić do ochrony sekcji krytycznej kodu.

`synchronized` to słowo kluczowe języka, które można umieścić w sygnaturze metody, lub stosować jako blok kodu.

`ReentrantLock` daje większą kontrolę nad tym jak powinien zachować się wątek w momencie wchodzenia do sekcji krytycznej.
#### 8. Jak doprowadzić do Deadlocka
Wystarczy, że dwie metody będą próbowały uzyskać ekskluzywny dostęp do dwóch tych samych zasobów w odwrotnej kolejności. Tak jak w tym fragmencie kodu.

```java
class Account {
    private BigDecimal balance;
    private Map<String, BigDecimal> history;

    public void acceptTransfer(BigDecimal amount) {
        synchronized(balance) {
            synchronized(history) {
                BigDecimal newBalance = balance.add(amount)
                this.balance = newBalance;
                this.history.put("new-transfer", amount);
            }
        }
    }

    public void withdrawMoney(BigDecimal amount) {
        synchronized(history) {
            synchronized(balance) {
                BigDecimal newBalance = balance.subtract(amount)
                this.balance = newBalance;
                this.history.put("withdrawal", amount);
            }
        }
    }
}
```

Obie metody – `acceptTransfer` i `withdrawMoney` potrzebują dostęp do `history` oraz `balance` na wyłączność, ale robią to w odwrotnej kolejności.

Gdy wątek w `acceptTransfer` uzyska dostęp do `balance` a wątek w `withdrawMoney` uzyska dostęp do `history` oba będą czekać w nieskończoność na uzyskanie dostępu do drugiego zasobu.
#### 9. Jak sobie poradzić z Deadlockiem
Są dwie opcje:

1. uzyskiwanie locków za pomocą `ReentrantLock`-a i wołanie metody `tryLock`. W przypadku porażki, powrót z metody bez wykonania odpowiedniego kodu.
2. układanie pobierania dostępu do zasobów w takiej samej kolejności. Powyższy fragment kodu pozbędzie się deadlocka, gdy obie metody będą najpierw sięgać po jeden zasób, a potem po drugi.

```java
class Account {
    private BigDecimal balance;
    private Map<String, BigDecimal> history;

    public void acceptTransfer(BigDecimal amount) {
        synchronized(balance) {
            synchronized(history) {
                BigDecimal newBalance = balance.add(amount)
                this.balance = newBalance;
                this.history.put("new-transfer", amount);
            }
        }
    }

    public void withdrawMoney(BigDecimal amount) {
        synchronized(balance) {
            synchronized(history) {
                BigDecimal newBalance = balance.subtract(amount)
                this.balance = newBalance;
                this.history.put("withdrawal", amount);
            }
        }
    }
}
```
#### 10. Co to jest CyclicBarrier
Klasa służąca do cyklicznego uruchamiania wątków w grupach. Przykładowo, chcemy zacząć wykonywać zadanie, gdy pojawi się 5 wątków gotowych do wykonania.

```
CyclicBarrier cyclicBarrier = new CyclicBarrier(5);
```

Może się to przydać, gdy chcemy zsynchronizować moment startu pracy kolejnych grup wątków.
#### 11. Jak działa Atomic Integer
`AtomicInteger` to klasa zapewniająca bezpieczeństwo wielowątkowe w operacjach dotyczących liczb całkowitych. Korzysta z operacji procesora *Compare-And-Swap* (CAS).
#### 12. Do czego służy słowo kluczowe volatile
`volatile` to słowo kluczowe instruujące kompilator, by zawsze sięgał do rejestrów procesora odczytując i zapisując wartość do pola oznaczonego tym słowem. Tym samym kompilator nie będzie w żaden sposób *cache-ował* tej wartości w celach optymalizacyjnych. Dzięki temu mamy pewność, że przy dostępie wielowątkowym wartość / obiekt przypisanych do tej zmiennej jest świeży.
#### 13. Na czym polega relacja Happens-Before
*Happens-Before* jest gwarancją, że dane operacje w kodzie wykonają się w odpowiedniej kolejności i związana jest z barierą pamięci oraz potencjalnymi optymalizacjami kompilatora i procesu.

W momencie, gdy JVM wykonuje instrukcje naszej aplikacji, może zmieniać kolejność tych instrukcji (w bezpieczny, optymalny sposób). Korzystanie jednak z klas, metod związanych z synchronizacją wątków zapewnia nas, że zmiana kolejności instrukcji przez JVM nie przekroczy miejsca, w którym ta synchronizacja się odbywa.

Dlatego tym bardziej istotne jest, byśmy wrażliwe na zniszczenie stanu aplikacji fragmenty kodu odpowiedni synchronizowali.
### Kolekcje
#### 1. Jakie mamy kolekcje w świecie współbieżnym
Najważniejsze to:
\1. kolekcje starego typu – jak np. `Vector`
\2. kolekcje synchronizowane – tworzone za pomocą metod `Collections.synchronizedXXX`
\3. kolekcje współbieżne – jak np. `ConcurrentHashMap`, `CopyOnWriteArrayList`, czy `BlockingQueue`.
#### 2. Jak działają kolekcje synchronized
Kolekcja utworzona przez `Collections.synchronizedXXX` zapewnia jednowątkowy dostęp do wszystkich metod danej kolekcji. Z jednej strony daje to bezpieczeństwo wielowątkowe, ale z drugiej obarczone jest dużym kosztem wydajnościowym.
#### 3. Jak działa ConcurrentHashMap
`ConcurrentHashMap` to odpowiedź na kolekcje synchronizowane. W jej przypadku `lock` zakładany jest na dany klucz. Dzięki temu wiele wątków może jednocześnie korzystać z tej mapy, a do blokady dochodzi dopiero w momencie, gdy na mapie chcą operować wątki korzystające z jednego klucza.
#### 4. Jakie są rodzaje kolejek i do czego się przydają
Kilka implementacji to:
\1. `LinkedBlockingQueue`,
\2. `SynchronousQueue`,
\3. `PriorityQueue`,
\4. `DelayQueue`.

Klasy te świetnie sprawdzają się do rozdzielenia synchronizacji wątków. Zamiast pozwalać wątkom rozmawiać między sobą, mogą one wymieniać zadania / komunikaty poprzez umieszczanie i ściąganie ich z kolejek.
### Zadania, Future, CompletableFuture
#### 1. Co to jest Future? Do czego służy
`Future` to klasa służąca do deklaracji wyniku, który wydarzy się w przyszłości. Przykładowo jest zwracana z metody `ExecutorService#submit`.

```java
Callable<String> task = ...;
ExecutorService executor = Executors.newFixedThreadPool(4);
Future<String> result = executor.submit(task);
result.get();
```

Metoda `get()` zwróci wynik, gdy ten będzie dostępny.
#### 2. Różnice Future vs CompletableFuture
`CompletableFuture` to ulepszona wersja typu `Future` wprowadzona w Javie 1.8.
Pozwala na łańcuchowanie kolejnych operacji wywoływanych na wyniku z wykonania zadania. API jest zbliżone do dobrze znanego StreamAPI służącego do pracy ze strumieniami w Javie.
#### 3. Jakie znasz alternatywy do CompletableFuture
`CompletableFuture` to typ wbudowany w język. Warto zainteresować się też alternatywami jak bardzo popularna `RxJava`, czy nawiązujący do operacji asynchronicznych framework `Akka`.
### Strumienie
#### 1. Jak działa parallel w Stream API? Na jakiej puli wątków się uruchamia? Na co warto uważać
Korzystając z metody `parallel` w Streamach sprawiamy, że operacje na elementach uruchomią się na wielu wątkach.

W tym celu wykorzystana będzie pula wątków `ForkJoinPool#commonPool`. Warto zwrócić uwagę, że nie mamy wtedy kontroli nad kolejnością w jakiej elementy strumienia zostaną ostatecznie przetworzone.

Należy też uważać na nadmierne używanie tej metody. Wołając `parallel` w jednym miejscu na blokujących operacjach (np. wołanie zewnętrznego API) możemy spowolnić wykonanie innych operacji wykorzystujących tylko CPU naszego serwera.
### Testowanie
#### 1. Czy można testować kod współbieżny? Jak
Tak. Należy napisać testy, w których będziemy uruchamiać wiele wątków na raz i sprawdzać czy wyniki są spójne. Przydadzą się też takie biblioteki jak Awaitility czy ConcurrentUnit.
### Najlepsze praktyki
#### 1. Jakich kilka najlepszych rad dałbyś w kontekście pisania kodu współbieżnego
1. Twórz jak najwięcej kodu, który może być bezpiecznie uruchomiony przez wiele wątków
2. Unikaj tworzenia sekcji krytycznych, jeśli problem można rozwiązać w inny sposób
3. Stosuj klasy niemutowalne
4. Korzystaj z pul wątków, kolekcji współbieżnych, kolejek
5. Wykorzystuj operacje asynchroniczne
6. Dziel problemy, algorytmy na mniejsze części, które można bezpiecznie zrównoleglić
#### 2. Jak zaimplementowałbyś problem producenta i konsumenta
Za pomocą kolejki blokującej i dwóch pul wątków. Jedna pula wątków zajmuje się produkowaniem wyników i umieszczaniem ich na kolejce, a druga zajmuje się ich konsumowaniem i ściąganiem z kolejki.
Dzięki temu wątki z dwóch grup nie muszą się ze sobą komunikować, a jedynie wymieniać obiekty na bezpiecznej wielowątkowo kolejce.
#### 3. Jak zaimplementowałbyś licznik odwiedzin podstron WWW
Wykorzystując klasę `ConcurrentHashMap` i kontrakt metody `compute`, która jest wykonywana atomowo. Dzięki temu mam pewność, że przekazana lambda wykona się z zachowaniem bezpiecznego dostępu wielowątkowego. Nie ma konieczności korzystać w tej sytuacji z typu `AtomicLong`.

```java
class VisitsCounter {
    private final ConcurrentHashMap<String, Long> visits = new ConcurrentHashMap<>();

    public void markVisit(String subpage) {
        visits.compute(subpage, (key, currentValue) -> currentValue != null ? currentValue + 1 : 1);
    }
}
```
#### 4. Jak zaimplementować wzorzec Singleton
Najprostsze rozwiązanie – wykorzystując enuma. Wówczas nie musimy się martwić o kwestię współbieżności, gdyż tę załatwi nam sama Java. Nie utworzy więcej niż jednej instancji typu EnumSingleton.

```java
enum EnumSingleton {
    INSTANCE;

    EnumSingleton() {
        System.out.println("Enum constructed...!");
    }

    public static void touchClass() {
        System.out.println("Enum class touched");
    }
}
```

Minusem jest to, że ta instancja jest tworzona w sposób zachłanny.

Co jeśli, chcielibyśmy utworzyć instancje singletona w sposób leniwy?

Wówczas mamy dwie opcje.

Opcja 1 – z wykorzystaniem wykorzystaniem `volatile` i `synchronized`. Wykorzystujemy tutaj tak zwany wzorzec podwójnego sprawdzania blokowania (*double-checked locking*).

```java
final class LazySingleton {

    private static volatile LazySingleton instance;

    private LazySingleton() {
        System.out.println("Lazy constructed...!");
    }

    public static LazySingleton getInstance() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }

    public static void touchClass() {
        System.out.println("Lazy class touched");
    }
}
```

Opcja 2 – z pominięciem słów kluczowych ze świata współbieżności, to ponownie wykorzystanie właściwości języka Java i utworzenie klasy wewnętrznej.

```
final class HolderSingleton {

    private HolderSingleton() {
        System.out.println("Holder constructed...!");
    }

    private static class Holder {
        private static final HolderSingleton INSTANCE = new HolderSingleton();
    }

    public static HolderSingleton getInstance() {
        return Holder.INSTANCE;
    }

    public static void touchClass() {
        System.out.println("Holder class touched");
    }
}
```

To kiedy dane obiekty zostają utworzone możemy sprawdzić uruchamiając poniższy kod.

```
class Scratch {
    public static void main(String[] args) {
        System.out.println("Starting...");
        EnumSingleton.touchClass();
        LazySingleton.touchClass();
        HolderSingleton.touchClass();
        System.out.println("DONE!");
    }
}
```

Który wyprodukuje następujący wynik.

```
Starting...
Enum constructed...!
Enum class touched
Lazy class touched
Holder class touched
DONE!
```

Zauważ, że konstruktor typu `EnumSingleton` został zawołany, podczas gdy pozostałe nie. Zostaną one wywołane dopiero podczas użycia metody `#getInstance()`.

# Pozostałe

## Wczytanie strumienia z katalogu zasobów

```java
private InputStream getFileFromResourceAsStream(String fileName) {
    // The class loader that loaded the class
    ClassLoader classLoader = getClass().getClassLoader();
    InputStream inputStream = classLoader.getResourceAsStream(fileName);

    // the stream holding the file content
    if (inputStream == null) {
        throw new IllegalArgumentException("file not found! " + fileName);
    } else {
        return inputStream;
    }
}
```

## Wczytanie pliku z katalogu zasobów

```java
private File getFileFromResource(String fileName) throws URISyntaxException{
    ClassLoader classLoader = getClass().getClassLoader();
    URL resource = classLoader.getResource(fileName);
    if (resource == null) {
        throw new IllegalArgumentException("file not found! " + fileName);
    } else {

        // failed if files have whitespaces or special characters
        //return new File(resource.getFile());

        return new File(resource.toURI());
    }
}
```

## Ustawienie NPE komunikatu

```shel
XX:+ShowCodeDetailsInExceptionMessages
```

## Ustawienie kodowania plików
[//]: "set-file-encoding"

W wierszu poleceń dodajemy opcję.

```shell
java -jar -Dfile.encoding=UTF-8 ./wiki.jar "$@"
```

Wpływa to na sposób np. przetwarzania nazw plików.

## Przeniesienie plików po zbudowaniu

[//]: "move-file-after-build"

Taki efekt możemy osiągnąć przez zastosowanie wtyczki `maven-antrun-plugin` do Mavena.

```xml
<plugins>
    <plugin>
        <artifactId>maven-antrun-plugin</artifactId>
        <version>1.8</version>
        <executions>
            <execution>
                <phase>install</phase>
                <goals>
                    <goal>run</goal>
                </goals>
                <configuration>
                    <tasks>
                        <copy file="${project.build.directory}/wiki-1.0-SNAPSHOT-exec.jar"
                              toFile="${env.BIN_PATH}/wiki.jar"/>
                        <copy file="${project.basedir}/src/assembly/wiki"
                              toFile="${env.BIN_PATH}/wiki"/>
                    </tasks>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

## Wyświetlenie aktualnego stosu wywołania

[//]: "print-stack"

```java
Thread.dumpStack()
```

Lub jak zajrzysz do tej metody to znajdziesz.

```java
new Exception("Stack trace").printStackTrace();
```

## Mechanizm VarHandle

[//]: "var-handle"

W ramach pakiety mamy takie narzędzie jak VarHandle. Pozwala ona na bezpośredni dostęp do zmiennej w klasie, jej modyfikację i odczyt. Nie ważne czy jest to zmienna prywatna, chroniona czy publiczna.

```java
// Zmienna publiczna
VarHandle USER_FIRST_NAME = MethodHandles.lookup()
    .in(User.class)
    .findVarHandle(User.class, "firstName", String.class);

// Zmienna prywatna
VarHandle USER_AGE = MethodHandles.privateLookupIn(User.class, MethodHandles.lookup())
    .findVarHandle(User.class, "age", int.class);

// Wartość możemy pobrać w taki sposób.
USER_AGE.get(object)

// Wartość możemy ustawić w taki sposób.
USER_FIRST_NAME.set(user, "Paweł");
```

Ogólnie sporo więcej możliwości między innymi odczytanie wartości zmiennych statyczny i ich modyfikację.

Jest jeszcze taka konwencja, że VarHandle powinien być zadeklarowany w ramach bloku stycznego w klasie.

> VarHandles should be declared as static final fields and explicitly initialized in static blocks. By convention

```java
import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;
class Point {
   volatile int x, y;
   private static final VarHandle X;
   static {
     try {
       X = MethodHandles.lookup().findVarHandle(Point.class, "x", int.class);
     } catch (ReflectiveOperationException e) {
       throw new Error(e);
     }
   }
   // ...
}
```
## Interfejs Unsafe

[//]: "unsafe"

Jest to interfejs `sun.misc.Unsafe` za pomocą którego możemy mieć bezpośredni dostęp do obiektu i jego pamięci. Implementacja jest w klasie. 

Aby zainicjować obiekt musimy dodać katalog źródłowy do `bootclasspath`  jeśli tego nie zrobimy to dostaniemy wyjątek związany z bezpieczeństwem. Mechanizm nie pozwala na modyfikacje klas spoza określonej grupy. 

```shell
java -Xbootclasspath:/usr/jdk1.7.0/jre/lib/rt.jar:. com.mishadoff.magic.UnsafeClient
```

Można to zabezpieczenie też ominąć udostępniając prywatne statyczne pole `theUnsafe`  klasy `Unsafe`.

```java
Field f = Unsafe.class.getDeclaredField("theUnsafe");
f.setAccessible(true);
Unsafe unsafe = (Unsafe) f.get(null);
```

Jest to trochę obejście tego mechanizmu. Samo zabezpieczenie wygląda tak jak poniżej. Czyli klasa która wywołuje to `getUnsafe` musi być wczytana przez `SystemDomainLoader` . Najprawdopodobniej `bootclasspath`.

```java
@CallerSensitive
public static Unsafe getUnsafe() {
    Class<?> caller = Reflection.getCallerClass();
    if (!VM.isSystemDomainLoader(caller.getClassLoader()))
        throw new SecurityException("Unsafe");
    return theUnsafe;
}
```

**Uwaga. Od wersji Javy 11 ten mechanizm nie jest wspierany. Aby go użyć należy doczytać moduł w trakcie kompilacji. Następcą tego mechanizmu jest VarHandle.**

```
javac --patch-module=jdk.unsupported=$PROJECT_DIR/src/main/java
```

Tam jest implementacja tej klasy. Dla Mavena możemy zrobić to w taki sposób:

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.8.0</version>
    <configuration>
        <release>11</release>
        <source>11</source>
        <compilerArgs>
            <arg>--patch-module</arg>
            <arg>jdk.unsupported=${project.basedir}/src/main/java</arg>
        </compilerArgs>
    </configuration>
</plugin>
```

Do konfiguracji wtyczki. Przypadku użycia są dobrze opisane w artykule Java Unsafe.
## Obiekty syntetyczne

[//]: "syntetic-objects"

Są to klasy, metody i pola tworzone przez kompilator. Na ogół programista nie ma z nimi styczności. API do refleksji posiada funkcje które pozwalają sprawdzić czy określony elementem jest syntetyczny `isSyntetic`. Elementy syntetyczne są tworzone np. gdy przypisujemy wartość do pola prywatnego  w klasie prywatnej. Innym przykładem jest tworzenie konstruktora w klasie prywatnej.

Java mówi o tym:

*A class member that does not appear in the source code must be marked using a Synthetic attribute, or else it must have its ACC_SYNTHETIC flag set. The only exceptions to this requirement are compiler-generated methods which are not considered implementation artifacts, namely the instance initialization method representing a default constructor of the Java programming language (§2.9), the class initialization method (§2.9), and the Enum.values() and Enum.valueOf() methods.*

## `Observable` i `Observer`

[//]: "observable-observer"

W Javie wzorzec obserwatora jest dość prosto zaimplementowany.

```java
class ObservableEntity extends Observable {
    private ArrayList<Header> headers = new ArrayList<>();

    public void addHeader(Header header) {
        headers.add(header);

        System.out.println("addHeader");

        setChanged();
        notifyObservers();
    }
}

ObservableEntity observableEntity = new ObservableEntity();

Observer observer = new Observer() {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println("observer.update");
        // System.out.println(o);
        // System.out.println(arg);
    }
};

observableEntity.addObserver(observer);
observableEntity.addHeader(new Header("1", "Content-Type", "application/json"));
```

Klasa obserwowana musi wywoływać metodę `notifyObservers` aby poinformować obiekty obserwujące.

Obiekt obserwujący musi implementować metodę `update`która jest wywoływana w monecie wyemitowania zdarzenia.

```
javap -p -c App.class

public class com.learning.App {
  public com.learning.App();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]) throws java.lang.IllegalAccessException, java.lang.InstantiationException;
    Code:
       0: new           #2                  // class com/learning/App$SampleNestedClass
       3: dup
       4: invokespecial #3                  // Method com/learning/App$SampleNestedClass."<init>":()V
       7: astore_1
       8: aload_1
       9: ldc           #4                  // String 123
      11: putfield      #5                  // Field com/learning/App$SampleNestedClass.aPrivateVariable:Ljava/lang/String;
      14: return
}
```
## Klasy zagnieżdżone

[//]: "inner-class"

Java umożliwia deklarowanie klas w ramach klasy.

```java
public class HelloWorld{
    public static void main(String []args){
        System.out.println("Hello World");

        Person person = new Person("Paweł");

        Person.EventsCreate event = new Person.EventsCreate();

        Person.Operator operatorA = person.new Operator();
        operatorA.run();
    }
}

class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public static class EventsCreate {
        public void emmit() {}
    }

    public class Operator {
        public void run() {
            System.out.println(name);
        }
    }
}
```

W powyższym przykładzie mam zadeklarowaną klasę `Person`, w ramach tej klasy mam klasy `EventsCreate` oraz `Operator`.

Klasa `EventsCreate` jest zadeklarowana jako klasa wewnętrzna, nie można jej utworzyć bez wcześniejszej instancji klasy `Person`. Tworzona jest przez instancję klasy `Person`.

Zwróć uwagę, na to, że klasa wewnętrzna ma dostęp do elementów instancji `Person`.

```java
Person.Operator operatorA = person.new Operator();
operatorA.run();
```

Klasa `Operator` jest zdefiniowana jako klasa statyczna, taka klasa może zostać utworzona bezpośrednio. Nie jest tutaj wymagana instancja klasy `Person`.

Dzięki mechanizmowi klasy wewnętrznej w lepszy sposób możemy układać kod. Poniżej przykład metody zwracającej operator jeśli ten jest potrzebny.

```
public Operator getOperator() {
	return this.new Operator();
}

// Wywołanie
person.getOperator().run();
```
## JVM parametry

[//]: "jvm-parameters"

- ***-server***: enables “Server Hotspot VM”; this parameter is used by default in 64 bit JVM
- ***-XX:+UseStringDeduplication***: *Java 8u20* has introduced this JVM parameter for reducing the unnecessary use of memory by creating too many instances of the same *String;* this optimizes the heap memory by reducing duplicate *String* values to a single global char[] array
- ***-XX:+UseLWPSynchronization***: sets *LWP* (*Light Weight Process*) – based synchronization policy instead of thread-based synchronization
- ***-XX:LargePageSizeInBytes\*:** sets the large page size used for the Java heap; it takes the argument in GB/MB/KB; with larger page sizes we can make better use of virtual memory hardware resources; however, this may cause larger space sizes for the *PermGen*, which in turn can force to reduce the size of Java heap space
- ***-XX:MaxHeapFreeRatio***: sets the maximum percentage of heap free after *GC* to avoid shrinking.
- ***-XX:MinHeapFreeRatio***: sets the minimum percentage of heap free after *GC* to avoid expansion; to monitor the heap usage you can use [VisualVM](https://visualvm.github.io/) shipped with JDK.
- ***-XX:SurvivorRatio***: Ratio of *eden*/*survivor space size* – for example, *-XX:SurvivorRatio=6* sets the ratio between each *survivor space* and *eden space* to be 1:6,
- ***-XX:+UseLargePages***: use large page memory if it is supported by the system; please note that *OpenJDK 7* tends to crash if using this JVM parameter**
  **
- ***-XX:+UseStringCache\*:** enables caching of commonly allocated strings available in the *String* pool**
  **
- ***-XX:+UseCompressedStrings***: use a *byte[]* type for *String* objects which can be represented in pure ASCII format
- ***-XX:+OptimizeStringConcat\*:** it optimizes *String* concatenation operations where possible
## Wybór 32/64 bity

[//]: "select-32-64-arch"

Służy do tego parametr `-d<OS bit>`

## Ustawienie wielkości przydzielonej pamięci

[//]: "set-memory-size"

Java ma dość skomplikowany model zarządzania pamięcią. Jest wiele parametrów pozwalających na definiowanie zachowania mechanizmu.

```
-Xms<heap size>[unit] 
-Xmx<heap size>[unit]
-XX:MaxMetaspaceSize=<metaspace size>[unit]
-XX:NewSize=<young size>[unit] 
-XX:MaxNewSize=<young size>[unit]
// ...
```

Jeśli chcemy zwiększyć ilość pamięci nie wchodząc w szczegóły możemy ustawić dwa parametry `-Xms i -Xmx`.

```
-Xms2G -Xmx5G
```
## Włączenie logów GC

[//]: "set-gc-log"

Logi GC mogą pomóc przy analizie działania GC. Takie logi możemy uruchomić w taki sposób przekazując takie parametry.

```
java ... -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=10MB -Xloggc:C:\home\tmp\gc.log
```

Znaczenie poszczególnych parametrów.

| Parametr                                       | Opis                                 |
| ---------------------------------------------- | ------------------------------------ |
| -XX:+UseGCLogFileRotation                      | Włącza odkładanie logów GC do pliku. |
| -XX:NumberOfGCLogFiles=< number of log files > | Maksymalna liczba plików.            |
| -XX:GCLogFileSize=< file size >[ unit ]        | Maksymalna wielkość pliku            |
| -Xloggc:/path/to/gc.log                        | Lokalizacja                          |
| -XX:+PrintGCDetails                            |                                      |
| -XX:+PrintGCDateStamps                         |                                      |
## Metoda `asSubclass`

[//]: "as-subclass"

```java
public class App {
    private static class A {
        public A() {}
        public void print() {System.out.println("Print A");}
    }

    private static class B extends A {
        public B() { super(); }
        public void print() {System.out.println("Print B");}
    }

    private static class C extends B {
        public C() { super(); }
        public void print() {System.out.println("Print C");}
    }

    public static void main(String[] args ) throws IllegalAccessException, InstantiationException {
        Class<B> clsB = B.class;

        // clsA jest skastowaną Class<B> na Class<A>
        Class<? extends A> clsA = clsB.asSubclass(A.class);

        runProcess(clsA);

        System.out.println(clsA.getName());
    }

    public static void runProcess(Class<? extends A> cls) {}
}
```
## Metoda `cast`

[//]: "method-cast"

```java
A objA = A.class.cast(new C());

objA.print();// Print C
​```## Metoda `isPrimitive`
Metoda zwraca informacje czy jest to typ prymitywni.

Typy prymitywne również posiadają swoją implementacje klasy, z tym wyjątkiem, że nie działa to identycznie jak w przypadku innych obiektów. Np. nie możemy utworzyć `Class<int>`.

​```java
Class<Double> doubleClass = Double.class;

System.out.println(int.class.isPrimitive());

Class<Integer> integerClass = int.class;

// Nie możemy stworzyć zmienn typu Class<int>
// Class<int> intClass = int.class; // ERROR

// Natomiast możemy odwołać się do obiektu klasy dla typu primitywnego i pobrać informacje  o nim.
System.out.println(int.class.isPrimitive());
System.out.println(int.class.getName());
```
## `Class<T>`

[//]: "class-t"

Jest to klasa do reprezentowania innej klasy.

W poniższym przykładzie mamy funkcje która zwraca listę wszystkich metod z określonej klasy lub obiektu.

```java
System.out.println(getClassMethods(new Person()));
System.out.println(getClassMethods(Person.class));

private static List<String> getClassMethods(Object cls) {
	return getClassMethods(cls.getClass());
}

private static List<String> getClassMethods(Class<?> cls) {
	ArrayList<String> methods = new ArrayList<>();

    for(Method method: cls.getMethods()) {
        methods.add(method.getName());
    }

    return methods;
}
```

Typ generyczny `Class` jest praktyczny gdy definicję klasy traktujemy jak obiekt (co jest fajnym rozwiązaniem).
## Wywołanie metody

[//]: "call-method"

Wykonanie metody przy pomocy jej nazwy.

```java
try {
    Method setter = item.getClass().getMethod("set" + finalAttr, String.class);

    setter.invoke(textField.getText());
} catch (NoSuchMethodException e) {
    e.printStackTrace();
} catch (IllegalAccessException e) {
    e.printStackTrace();
} catch (InvocationTargetException e) {
    e.printStackTrace();
}
```
## Czytanie pola prywatnego

[//]: "ready-private-field"

Reflection mechanism allows to get value of private fields. 

```java
private void printUserPriveFields(User user) throws NoSuchFieldException, IllegalAccessException {
    Field firstName = user.getClass().getDeclaredField("firstName");
    Field lastName = user.getClass().getDeclaredField("lastName");
    Field age = user.getClass().getDeclaredField("age");
    Field substitute = user.getClass().getDeclaredField("substitute");

    firstName.setAccessible(true);
    lastName.setAccessible(true);
    age.setAccessible(true);
    substitute.setAccessible(true);

    System.out.println("firstName " + firstName.get(user));
    System.out.println("lastName " + lastName.get(user));
    System.out.println("age " + age.getInt(user));
    System.out.println("substitute " + substitute.get(user));
}
```

Generally there is method "get" which returns objects and there is few method "getXXX" for primitive types.

```java
Person person = new Person();

Field ageField = person.getClass().getDeclaredField("age");
ageField.setAccessible(true);

byte age = ageField.getByte(person);
Assertions.assertEquals(30, age);

Field uidNumberField = person.getClass().getDeclaredField("uidNumber");
uidNumberField.setAccessible(true);

short uidNumber = uidNumberField.getShort(person);
Assertions.assertEquals(5555, uidNumber);

Field pinCodeField = person.getClass().getDeclaredField("pinCode");
pinCodeField.setAccessible(true);

int pinCode = pinCodeField.getInt(person);
Assertions.assertEquals(452002, pinCode);

Field contactNumberField = person.getClass().getDeclaredField("contactNumber");
contactNumberField.setAccessible(true);

long contactNumber = contactNumberField.getLong(person);
Assertions.assertEquals(123456789L, contactNumber);
```
## Wybór GC

[//]: "select-gc"

GC oraz sposób zarzadzania pamięcią opisuj w osobnym rozdziale. Natomiast jeśli chcemy zdefiniować jaki GC ma zostać użyty to mamy takie opcje.

```
-XX:+UseSerialGC
-XX:+UseParallelGC
-XX:+USeParNewGC
-XX:+UseG1GC
```

Wtedy mamy np.

```
java ... -XX:+UseSerialGC
```
## Nadpisanie metody w typie wyliczanym

[//]: "enum-method"

Java w typie wyliczeniowym pozwala na zdefiniowanie metod oraz ich nadpisanie.

```java
package repo.java.enumeration;

public enum UserTypeEnum {
    ADMIN("A") {
        @Override
        public String toUniCode() {
            return "ADMIN(" + this.toUniCode() + ")";
        }
    },

    USER("U") {
        @Override
        public String toUniCode() {
            return "USER(" + this.toUniCode() + ")";
        }
    },

    private String code;

    UserTypeEnum(String code) {
        this.code = code;
    }

    public abstract String toUniCode();
}
```
## Bezpośrednie wywołanie

[//]: "interactive-call"

Od Javy 9 możliwe jest bezpośrednie wywołanie kodu źródłowego bez potrzebny wcześniejszej kompilacji. Prze Java 9 konieczna była kompilacja a następnie uruchomienie.

```shell
javac WitajŚwiecie.java
java WitajŚwiecie

## Witaj, Świecie!
```

Od Javy 9 możliwe jest takie wywołanie 

```shell
java WitajŚwiecie.java
```

Program zostanie skompilowany i wykonany. Dzięki temu możliwe jest również bezpośrednie wywołanie polecenia z powłoki.

```java
##!/home/piotrprz/.sdkman/candidates/java/current/bin/java
    
public class WitajJava {
    public static void main(String[] args) {
        System.out.println("Witaj, tu skrypt napisany w Javie!");
    }
}
```

Zwróć uwagę, że jest to plik Javy z shebangiem który mówi powłoce jakiego interpretera ma użyć. Dzięki temu możliwe jest uruchomienie programu w Javie w podobny sposób jak uruchamiane są skrypty.
## Zmienna `CLASSPATH`

[//]: "classpath"

Zmienna przechowuje listę ścieżek do katalogów z klasami oraz zasobami.
## Generowanie randomowych GUID

[//]: "generate-guid"

Aby wygenerować unikalny identyfikator.

```
java.util.UUID.randomUUID();
```
## Entry Point for Jar

[//]: "jar-entry-point"

If you have an application bundled in a JAR file, you need some way to indicate which class within the JAR file is your application's entry point. You provide this information with the `Main-Class` header in the manifest, which has the general form:

```
Main-Class: classname
```

The value *`classname`* is the name of the class that is your application's entry point. Recall that the entry point is a class having a method with signature `public static void main(String[] args)`. After you have set the `Main-Class` header in the manifest, you then run the JAR file using the following form of the `java` command:

```bash
java -jar JAR-name
```

The `main` method of the class specified in the `Main-Class` header is executed. We want to execute the `main` method in the class `MyClass` in the package `MyPackage` when we run the JAR file. We first create a text file named `Manifest.txt` with the following contents:

```
Main-Class: MyPackage.MyClass
```

We then create a JAR file named `MyJar.jar` by entering the following command:

```
jar cfm MyJar.jar Manifest.txt MyPackage/*.class
```

This creates the JAR file with a manifest with the following contents:

```
Manifest-Version: 1.0
Created-By: 1.7.0_06 (Oracle Corporation)
Main-Class: MyPackage.MyClass
```

When you run the JAR file with the following command, the `main` method of `MyClass` executes:

```
java -jar MyJar.jar
```

**Setting an Entry Point with the JAR Tool**

------

The 'e' flag (for 'entrypoint') creates or overrides the manifest's `Main-Class` attribute. It can be used while creating or updating a JAR file. Use it to specify the application entry point without editing or creating the manifest file.
For example, this command creates `app.jar` where the `Main-Class` attribute value in the manifest is set to `MyApp`:

```
jar cfe app.jar MyApp MyApp.class
```

You can directly invoke this application by running the following command:

```
java -jar app.jar
```

If the entrypoint class name is in a package it may use a '.' (dot) character as the delimiter. For example, if `Main.class` is in a package called `foo` the entry point can be specified in the following ways:

```
jar cfe Main.jar foo.Main foo/Main.class
```
## Memory Address of Objects

[//]: "object-memory-address"

To find the memory address of objects in the JVM, we're going to use the Java Object Layout ([JOL](https://openjdk.java.net/projects/code-tools/jol/)) tool. Therefore, we need to add the [*jol-core*](https://search.maven.org/artifact/org.openjdk.jol/jol-core) dependency:

```xml
<dependency> 
    <groupId>org.openjdk.jol</groupId> 
    <artifactId>jol-core</artifactId>    
    <version>0.10</version> 
</dependency>
```

To find the memory address of a particular object in the JVM, we can use the *[addressOf()](https://www.javadoc.io/doc/org.openjdk.jol/jol-core/latest/org/openjdk/jol/vm/VirtualMachine.html#sizeOf-java.lang.Object-)* method:

```java
String answer = "42";
 
System.out.println("The memory address is " + VM.current().addressOf(answer));
```

This will print:

```plaintext
The memory address is 31864981224
```

There are different compressed reference modes in the HotSpot JVM. Because of these modes, this value may not be completely accurate. Therefore, we shouldn't go and perform some native memory manipulations based on this address, as it may cause weird memory corruptions.

Also, memory addresses in most JVM implementations are subject to change as the GC moves the objects around from time to time.

There's a common misconception that the memory addresses of objects in the JVM are represented as part of their default *toString* implementations, such as *java.lang.Object@60addb54*. That is, many think that the *“60addb54”* is the memory address of that particular object.

Let's check this assumption:

```java
Object obj = new Object();
 
System.out.println("Memory address: " + VM.current().addressOf(obj));
System.out.println("toString: " + obj);
System.out.println("hashCode: " + obj.hashCode());
System.out.println("hashCode: " + System.identityHashCode(obj));
```

This will print the following:

```plaintext
Memory address: 31879960584
toString: java.lang.Object@60addb54
hashCode: 1622006612
hashCode: 1622006612
```

Quite interestingly, the *“60addb54”* is the hexadecimal version of the hash code, which is 1622006612. The *[hashCode()](https://www.baeldung.com/java-hashcode)* method is one of the common methods for all Java objects. **When we don't declare a hashCode() method for a class, Java will use the identity hash code for it.** 

As shown above, the identity hash code (that part after *@* in *toString*) and the memory address are different.
## Convert an Array of Primitives to a List

[//]: "convert-array-to-list"

Let's begin with the definition of the problem. **We have an array of primitives** (*int[]*), **and we desire to convert that array to a \*List\*** (*List<Integer>*). An intuitive first attempt could be:

```java
int[] input = new int[]{1,2,3,4};
List<Integer> output = Arrays.asList(input);
```

Unfortunately, this **won't compile due to type incompatibility**. We might expect autoboxing to work with arrays of primitives. However, this instinctive belief isn't true.

**Autoboxing only happens for a single element** (for example from *int* to *Integer*). There is no automatic conversion from an array of primitive types to an array of their boxed reference types (for example from *int[]* to *Integer[]*).

Let's start to implement a few solutions to this problem.

Solutions:

```java
int[] input = new int[]{1,2,3,4};
List<Integer> output = new ArrayList<Integer>();
for (int value : input) {
    output.add(value);
}

int[] input = new int[]{1,2,3,4};
List<Integer> output = Arrays.stream(input).boxed().collect(Collectors.toList());

int[] input = new int[]{1,2,3,4};
List<Integer> output = IntStream.of(input).boxed().collect(Collectors.toList());

// Guava
int[] input = new int[]{1,2,3,4};
List<Integer> output = Ints.asList(input);

// Apache Commons
int[] input = new int[]{1,2,3,4};
Integer[] outputBoxed = ArrayUtils.toObject(input);
List<Integer> output = Arrays.asList(outputBoxed);
```
## Sorting list with NULL value

[//]: "sort-with-null"

When we want to sort list of element where one of element can be null then there is need to take care of that in comparator otherwise the NullpointerException will be throwed. Below I wrote a pice of code which is resolving that problem.

```java
List<String> names = Arrays.asList("Paweł", "Anna", null, "Iwona");

names.sort(new Comparator<String>() {
    @Override
    public int compare(String o1, String o2) {
        if (o1 == null) return -1;
        if (o2 == null) return 1;

        return o1.compareTo(o2);
    }
});

System.out.println(names);

// Short solution
names.sort(Comparator.nullsFirst(String::compareTo));

System.out.println(names);
```
## Wyjątki

[//]: "exceptions"

Wyjątki w Javie możemy podzielić na te które muszą zostać obsłużone oraz na te które nie muszą zostać obsłużone.

1. Wyjątki które muszą zostać obsłużone rozszerzeją klasę Exception. Wyjątki, które nie wymagają obsługi rozszerzeżają klasę RuntimeException. 
2. Wyjątki rozszerzające RuntimeException sa to takie, których programistycznie można unikną np. NullPointerException lub IllegalArgumentException.
3. Wyjątki które muszę zostać obłużone są to takie których programista nie jest w stanie uniknąć np. brak połączenia, niedostępna usługa, plik kórego nie można otworzyć. Czyli programista wykonał wszystko dobrze ale i tak wystąpił błąd.
## Library `rt.jar`

[//]: "rt-jar"

rt.jar stands for runtime JAR and contains the bootstrap classes, I mean all the classes from Core Java API.

You must include rt.jar in your classpath, otherwise you don't have access to core classes e.g. java.lang.String, java.lang.Thread, java.util.ArrayList or java.io.InputStream and all other classes from Java API. You can actually see what is inside rt.jar by opening it by using WinRAR or WinZip client. You can see that it not only contains all Java API but also internal classes specified in com package.

The rt.jar is where all the Java packages reside. For example, if a class file need to refer a class from java.util.concurrent package e.g. [ConcurrentHashMap](http://javarevisited.blogspot.sg/2013/02/concurrenthashmap-in-java-example-tutorial-working.html), then the JVM will look for it inside the rt.jar, thus enabling it to run correctly.

One more question Java programmer ask is, where can I find source code for classes included in rt.jar? well, if you have installed JDK, not JRE then you can find all sources inside $JAVA_HOME/src.zip file.

One of the most important thing to know about rt.jar is that all the classes in this JAR file is known to JVM, which means JVM doesn't do all the checks it does while loading any other JAR from any other location.  This is done due to various performance reason and that's why these classes are loaded by [bootstrap or primodial class loaders](http://javarevisited.blogspot.sg/2012/12/how-classloader-works-in-java.html).

If you are curious about different binary and JAR files used by the Java platform, then look into this diagram. You can see that JDK has three main folders bin, lib and jre. bin directory contains all binary executable e.g. java.exe to run Java program, javac.exe to compile Java program etc. lib contains tools.jar and dt.jar. jre folder again contain bin and lib directory. It's in this lib directory rt.jar reside.

<img src="../.files/Java+JDK+Libary+and+Binary.jpg" alt="basic folders and files in JDK JRE" style="zoom:67%;" />

## Mechanizm `ClassLoader`

[//]: "class-loader"

ClassLoader jest mechanizmem, który ładuje klasy z postaci binarnej do postaci wykonywalnej na wirtualnej maszynie Javy. Klasy te ładowane są dynamicznie co oznacza, iż dostarczone są tylko wtedy, gdy są potrzebne na podstawie nazwy wraz z pakietem/ścieżką. W Javie ClassLoader’y występują w hierarchii.

 Poniższy obrazek prezentuje hierachię ClassLoader’ów

 ![img](../.files/class_loader_hierachy-1024x461-1576760883119.png)

| ClassLoader            | Opis                                                         |
| ---------------------- | ------------------------------------------------------------ |
| Bootstrap Class Loader | Pierwszym ClassLoader w hierarchii jest tak zwany `Bootstrap/Null/Primordial` ClassLoader. Jest to ClassLoader napisany w kodzie natywnym, którego zadaniem jest dostarczenie wszystkich elementów z folderu `$JAVA_HOME/lib/*.jar`. Znajduję się tam między innymi `rt.jar`, które zawiera podstawowe klasy jak `String` czy kolekcje. Ponadto ładowane są Javowe Class Loader’y. |
| Extension Class Loader | Kolejny Class Loader odpowiedzialny jest za dostarczenie dodatkowych narzędzi, które znajdują się w folderze `$JAVA_HOME/lib/ext/*.jar` lub w każdym innym dowolnym folderze zdefiniowanym w zmiennej systemowej `java.ext.dirs`. W folderze `ext` możemy znaleźć między innymi binaria projektu Nashorn (który jest deprecated od Javy 11). |
| System Class Loader    | Ostatnim obowiązkowym **Class Loader’em** jest **System Class Loader**. Ładuje on wszystkie **klasy**, które znajdują się na tak zwanym **class path’ie**. **Class Path** jest to wartość, która zawiera informacje o klasach i ich ścieżkach jakie mają być załadowane do **JVM’a**. **Class Path** można ustawić na kilka sposobów: zmienne środowiskowe, wiersz poleceń, manifest. |

**Zmienna** 

------

Zmienną środowiskową odpowiedzialną za dostarczenie ścieżek do klas jest `CLASSPATH`. W tej zmiennej środowiskowej przechowujemy ścieżki do plików `.class` oraz `.jar`. Ścieżki rozdzielamy znakiem `:` dla systemów **Unix** i `;` dla systemów **Windows**. Przykładowa zmienna środowiskowa `CLASSPATH=path/to/classes;path/to/jars`.

**Wiersz poleceń**

------

Podczas uruchamiania programu z **wiersza** poleceń `java Run` można wskazać własny **class path**. Wykonuje się to poprzez użycie przełączników `-cp` lub `-classpath`. Należy pamiętać o tym, iż tak przekazane wartości zmiennej **class path** nadpisują zmienną globalną `CLASSPATH`. Domyślny `CLASSPATH `to folder, w którym został uruchomiony kod.

**Manifest**

------

Jeśli uruchamiamy aplikację jako archiwum `java -jar` wtedy wartości `-cp`, `-classpath` oraz `CLASSPATH` zostaną zignorowane. W przypadków archiwum informacje o **class path’ie** powinny znajdować się wewnątrz pliku **manifest** (tym razem podajemy ścieżki względne, które rozdzielamy **spacjami**):

- `Main-Class: pl.codecouple.Runner`,
- `Class-Path: lib/code.jar lib/couple.jar`.

ClassLoader w Javie to potężna koncepcja i używana w wielu miejscach. Jednym z popularnych przykładów ClassLoader jest AppletClassLoader, który służy do ładowania klasy przez Applet, ponieważ aplety są w większości ładowane z Internetu, a nie z lokalnego systemu plików.

Używając osobnego ClassLoader, można również ładować tę samą klasę z wielu źródeł i będą one traktowane jak inna klasa w JVM. J2EE używa wielu programów ładujących klasy do ładowania klas z różnych lokalizacji, np. Klasy z pliku WAR będą ładowane przez aplikację ClassLoader aplikacji sieciowej, podczas gdy klasy zawarte w EJB-JAR są ładowane przez inny moduł ładujący klasy. Niektóre serwery WWW obsługują także funkcję *hotdeploy*, która jest implementowana za pomocą ClassLoader. Możesz także użyć ClassLoader, aby załadować klasy z bazy danych lub innego trwałego sklepu.
### Zasada działa
Wywołanie:

```java
B b = new B()
```

Jest tożsame z:

```java
B b = A.class. getClassLoader().loadClass(“B”).newInstance()
```

Jak widać, każda klasa `A.class` jest powiązana z określonym ClassLoaderem.

 ![How class loader works in Java - class loading](../.files/Java classloader working.PNG)

ClassLoader działa w oparciu o trzy zasady:

- delegacji,
- widoczności,
- unikalności.

Zasada delegacji:

> As discussed on [when a class is loaded and initialized in Java](http://javarevisited.blogspot.sg/2012/07/when-class-loading-initialization-java-example.html), a class is loaded in Java, when its needed. Suppose you have an application specific class called Abc.class, first request of loading this class will come to Application ClassLoader which will delegate to its parent Extension ClassLoader which further delegates to Primordial or Bootstrap class loader. Primordial will look for that class in rt.jar and since that class is not there, request comes to Extension class loader which looks on jre/lib/ext directory and tries to locate this class there, if class is found there than Extension class loader will load that class and Application class loader will never load that class but if its not loaded by extension class-loader than Application class loader loads it from [Classpath in Java](http://java67.blogspot.sg/2012/08/what-is-path-and-classpath-in-java-difference.html). Remember Classpath is used to load class files while [PATH](http://javarevisited.blogspot.ca/2011/10/how-to-set-path-for-java-unix-linux-and.html) is used to locate executable like javac or java command.

Zasada widoczności mówi o tym, że ClassLoader podrzędny (child) widzi wszystkie klasy wczytane przez rodzica (parent), ale nie odwrotnie.

>  According to visibility principle, Child ClassLoader can see class loaded by Parent ClassLoader but vice-versa is not true. Which mean if class Abc is loaded by Application class loader than trying to load class ABC explicitly using extension ClassLoader will throw either [java.lang.ClassNotFoundException](http://javarevisited.blogspot.ca/2011/08/classnotfoundexception-in-java-example.html). as shown in below Example

Poniżej został przedstawiony przykład.

```java
package com.repo.classloader;

import static java.lang.System.*;

public class App {
    public static void main( String[] args )
            throws ClassNotFoundException
    {
        // Klasa zostanie odnaleziona
        out.println(Class.forName(
            "com.repo.classloader.App",
            true,
            App.class.getClassLoader())
        );

        // Klasa nie zostanie odnaleziona, ponieważ
        // parent nie ma dostępu do klas wczytanych przez
        // podrzędny ClassLoder.
        out.println(Class.forName(
            "com.repo.classloader.App",
            true,
            App.class.getClassLoader().getParent())
        );
    }
}
```

Zasada unikalności mówi, że klasa wczytana przez rodzica nie powinna być napisana przez ClassLoader podrzędny.

>  According to this principle a class loaded by Parent should not be loaded by Child ClassLoader again. Though its completely possible to write class loader which violates Delegation and Uniqueness principles and loads class by itself, its not something which is beneficial. You should follow all class loader principle while writing your own ClassLoader.
### Użycie określonego ClassLoadera
Java udostępnia mechanizm pozwalający na wczytanie klasy z wykorzystaniem określonego ClassLoadera. Wykorzystanie innego ClassLoadera wykonywane jest przeze metodę  `Class.forName(classname, initialized, classloader)`  gdzie trzecim parametrem jest ClassLoader który ma zostać użyty.

```java
public class App {
    public static void main( String[] args )
            throws ClassNotFoundException
    {
        out.println(Class.forName(
                "com.repo.classloader.App",
                true,
                App.class.getClassLoader())
        );
}
```
### Standardowy ClassLoader
```java
package java.lang;

public abstract class ClassLoader {

  public Class loadClass(String name);
  protected Class defineClass(byte[] b);

  public URL getResource(String name);
  public Enumeration getResources(String name);

  public ClassLoader getParent()
}
```



Jest to metoda której zadaniem jest zaczytanie klasy. Kopia jej implementacji wraz z własnymi komentarzami.

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // Sprwadzamy czy klasa została już wczytana
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // Zlecenamy wykonanie parentowi
                    c = parent.loadClass(name, false);
                } else {
                    // Nie ma rodzica, to zlecamy tgz. Bootstrap ClassLoader.
                    // Jest to natywna implementacja
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // Dopiero jak nie znaleziono, to wykonywajmy metody findClass.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

W implementacji widać wzorzec delegacji. Widać również miejsce w którym jest wywoływany rodzic oraz jeśli nie zostanie znaleziony to jest wywoływana metoda `findClass`. Implementacja w rozdziale poniżej.
### Własna implementacja i analiza
```java
public class CustomClassLoader extends ClassLoader {

    @Override
    public Class findClass(String name) throws ClassNotFoundException {
        byte[] b = loadClassFromFile(name);
        return defineClass(name, b, 0, b.length);
    }

    private byte[] loadClassFromFile(String fileName)  {
        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(
                fileName.replace('.', File.separatorChar) + ".class");
        byte[] buffer;
        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        int nextValue = 0;
        try {
            while ( (nextValue = inputStream.read()) != -1 ) {
                byteStream.write(nextValue);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        buffer = byteStream.toByteArray();
        return buffer;
    }
}
```

W pierwszej kolejności wywoływana jest metoda  `public Class loadClass(String name,  boolean resolve) throws ClassNotFoundException` .
### Test czy klasa istnieje
Czasami trzeba sprawdzić czy klasa o określonej nazwie istnieje. Można posłużyć się metodą `Class.forName`,  tylko trzeba uważać, jeśli w bloku statycznym klasy którą sprawdzamy zostanie wyrzucony wyjątek to sprawdzenie również się nie powiedzie. 

```java
public static class InitializingClass {
    static {
        if (true) { //enable throwing of an exception in a static initialization block
            throw new RuntimeException();
        }
    }
}
```

Zostanie wyrzucony wyjątek `ExceptionInInitializerError`.  Jeśli chcemy tylko sprawdzić czy klasa istnieje bez wywoływania inicjalizacji to robimy to w taki sposób, że drugi parametr do metody `forName` przekazuje `false` co spowoduje, że blok inicjalizacyjny się nie wywoła.

```java
@Test
public void givenInitializingClass_whenUsingForNameWithoutInitialization_thenNoException() throws ClassNotFoundException {
    Class.forName("path.to.InitializingClass", false, getClass().getClassLoader());
}
```

## Wyrażenie `final`

[//]: "final-keyword"

Słowo może zostać wykorzystane w trzech kontekstach:

- przy definiowaniu klasy,
- przy definiowaniu metody,
- przy definiowaniu zmiennej.

Przy definiowaniu zmiennej powoduje, że zmienna raz utworzona nie może zostać zmieniona.

Przy definiowaniu metody oznacza, że metoda nie może zostać nadpisana.

Przy definiowaniu klasy oznacza, ze klasa nie może zostać rozszerzona.

![Znalezione obrazy dla zapytania keywork final java](../../../.files/Java Final Keyword.png)

Dyrekrywa `final` znajduje równiez zastosowanie w przypadku tgz. wyrażeń lambda lub klas zagnieżdżonych. Poniżej jest przykład deklarowania funkcji z jednym parametrem.

```java
public static void main( String[] args ) {
    Function<String, String> concat = getConcatFunction("2012_");

    System.out.println(concat.apply("report_płac"));
}

public static Function<String, String> getConcatFunction(String prefix) {

    Function<String, String> concat = new Function<String, String>() {
        @Override
        public String apply(String s) {
            return prefix + s;
        }
    };

    prefix = "new";

    return concat;
}
```

Parametr `prefix` musi być zdefniowany jako `final` lub nie może byc modyfikowany w trakcie deklaracji.

```
Error:(18, 24) java: local variables referenced from an inner class must be final or effectively final
```

Mozna temu zaradzić na kilka sposobów.

Deklarując parametr wejściowy jako `final`.

```java
public static Function<String, String> getConcatFunction(final String prefix) {

```

Tworząc zmienna lokalną.

```java
String s1 = prefix;

Function<String, String> concat = new Function<String, String>() {
    @Override
    public String apply(String s) {
        return s1 + s;
    }
};
```
### Wyrażenie `final` i inicjacja obiektu
Inicjując obiekt nie mamy zawsze pewności w jakiej kolejności zostaną wywołane poszczególne instrukcje w konstruktorze. Użycie wyrazenia `final` przy deklaracji zmiennej spowoduje, że w pewien sposób wymusimy w jakiej kolejonści i które zmiennej powinny zostac zainicjowane, daje to gwarancję, że inne wątki dostana zainicjowan obiekt.

https://dzone.com/articles/final-keyword-and-jvm-memory-impact
## Różnica między obiektami

[//]: "object-diff"

Do sprawdzania różnic między obiektami istnieje biblioteka `java-object-diff`.

 https://github.com/SQiShER/java-object-diff

```java
final Category category1 = new Category();
  category1.setName("Cat1");
  category1.setName("The first category");

  final Category category2 = new Category();
  category2.setName("Cat2");
  category2.setName("The second category");

  final Item item1 = new Item();
  item1.setName("A");
  item1.setQuantity(1);
  item1.setUpdatedAt(new Date());
  item1.setCategory(category1);

  final Item item2 = new Item();
  item2.setName("B");
  item2.setQuantity(1);
  item2.setUpdatedAt(new Date());
  item2.setCategory(category2);

  DiffNode diff = ObjectDifferBuilder.buildDefault().compare(item1, item2);

  if (diff.hasChanges()) {
      diff.visit(new DiffNode.Visitor() {
          public void node(DiffNode node, Visit visit)
          {
              if (!node.hasChildren()) { // Only print if the property has no child
                  final Object oldValue = node.canonicalGet(item1);
                  final Object newValue = node.canonicalGet(item2);

                  final String message = node.getPropertyName() + " changed from " +
                          oldValue + " to " + newValue;
                  System.out.println(message);
              }
          }
      });
  } else {
      System.out.println("No differences");
  }
```
## Metody `hashCode` i `equals`

[//]: "hash-code-and-equals"

Metoda hashCode i equals są jednymi z podstawowych w Javie ich deklaracje znajdują się w Object. 

```java
public boolean equals(Object obj)
public int hashCode()
```

Do porównania typów prostych wystarczy użycie operatora `==` jednak w przypadku obiektów to się nie sprawdza ponieważ operator sprawdza czy obiekty są identyczne czyli sprawdza czy są w tym samym miejscu w pamięci.

Metoda `equals`, która w zamyśle wykorzystana jest do porównania obiektów wg ich wartości. Jednak jej ostateczne zachowanie zależne jest od implementacji. Przykładowo, domyślna implementacja to standardowy operator porównania, sprawdzający identyczność obiektów.

Klasy typów opakowujących (np. Integer, Long itp.) oraz String nadpisują implementację metody equals, w celu porównywania obiektów po wartości.

Metoda `hashCode` powstała w celach **optymalizacyjnych**. Jej zadaniem jest wygenerowanie dla obiektu szybkiego skrótu (hashu) w formie liczby całkowitej.

Hash generowany jest na podstawie stanu obiektu – wartości pól obiektu, które wyróżniają go od innych obiektów tej samej klasy. Powstały kod powinien zapewniać jak największą unikatowość – tak by możliwie niewielka liczba obiektów mogła wygenerować identyczny kod.

HashCode jest wykorzystywana przez wbudowane w Javie struktury danych (np. HashMap). **Najpierw obiekty są dzielone na tak zwane kubełki, wg wartości kodu hashCode. A dopiero następnie są między sobą porównywane z wykorzystaniem metody equals.** Dzięki temu nie ma potrzeby porównywania ze sobą wszystkich obiektów.

Kontrakt dla samej metody `hashCode` jest następujący:

- Jeśli informacje używane w `equals` nie są modyfikowane, to metoda `hashCode` musi zawsze konsekwentnie zwracać tę samą wartość.
- Jeśli metoda `equals` stwierdzi, że dwa obiekty są równe, to wywoływanie `hashCode` na obu tych obiektach musi zwrócić tę samą wartość.
- Jeśli dwa obiekty nie są równe według metody `equals`, to **nie** jest wymagane, aby `hashCode` na każdym z obiektów zwracał różne wyniki. Jednak jest to pożądane, bo ma to znaczenie wydajnościowe dla hash tablic (jeśli będą dwa takie same hashe, to będzie musiała wywołać metody `equals`, aby rozróżnić obiekty).

Dopuszczalne jest aby obiekty były różne ale zwracały taki sam hashCode `a.equals != b.equals and a.hashCode == b.hashCode`. Niedopuszczalne jest aby obiekty były równe ale zwracały różne kody. Taki warunek jest zły`a.equals == b.equals and a.hashCode != b.hashCode`.
## Etykiety sterujące

[//]: "drive-labels"

```java
loopX:
for(int x = 0; x < 10; x++) {
    out.println(String.format("x -> %s", x));

    loopY:
    for(int y = 0; y < 10; y++) {
        out.println(String.format("y -> %s", y));

        if (x + y == 5) {
            out.println(String.format("%s %s", x, y));

            // Spowoduje, że przejdziemy do etykiety loopY i przetwarzać kolejne liczby
            // continue loopY;

            // Spowoduje, że przetwarzać do etykiety loopY, ale petla się zakończyła wiec
            // program wykona się dalej, czyli przejdzie na x++
            // break loopY;

            // continue loopX;
            // break loopX;
        }
    }
```
## Optional

[//]: "optional"

```java
DocumentToSign document = documentToSignService.getDocumentToSignBy(documentId, null);

log.debug("Found TransactionID: [{}] by documentId: [{}]", document.getSamlTransactionId(), documentId);
return Optional.ofNullable(document)
    .map(DocumentToSign::getSamlTransactionId)
    .orElse(null);
```
## Komparator

[//]: "comparator"

Komparator jest to interfejs funkcyjny. Klasa implementująca komparator może zostać wykorzystania do posortowania listy.

Poniżej przykład z zadeklarowanym komparatorem sortującym listę.

```java
Comparator<Person> c = (a, b) -> {
    return a.getAge() < b.getAge() ? -1 : a.getAge() == b.getAge() ? 0 : 1;
};

ArrayList<Person> persons = new ArrayList<Person>(5) {{
    add(new Person("A", 10));
    add(new Person("B", 20));
    add(new Person("C", 30));
    add(new Person("D", 40));
}};

persons.sort(c);

System.out.println(persons);
```

Komparator może zostać utworzony również dla za pomocą funkcji (z interfejsu).

```java
Comparator<Person> c = Comparator.comparing(Person::getAge);
```
## Przykład `Hello world`

[//]: "hello-world"

```java
public class FirstJavaProgram {
    public static void main(String[] args){
        System.out.println("Hello world.");
    }
}
```

W Javie każdy element musi zostać zapisany w klasie, stąd nasz pierwszy program nazywa się `FirstJavaProgram` w którym mamy zdefiniowana metodę statyczną `main`.

Jest to minimum jakie musimy napisać aby utworzyć program.

Następnym krokiem jest skompilowanie programu za pomocą polecenia `javac FirstJavaProgram.java` oraz uruchomić `java FirstJavaProgram`.
## Problem z importowaniem kontrolek do SceneBuilder

[//]: "scene-builder-import-widgets"

Miałem problem z zaimportowaniem kontrolek do SceneBuildera. Cześć kontrolek się wczytywała, a niektóre nie chciały. Po kilku godzinach udało się mi określić przyczynę.

Przyczyną był brak zewnętrznych bibliotek w trakcie importowania. Problem pojawiał się przy tych kontrolkach które korzystały z zewnętrznych bibliotek.

Problem rozwiązałem przez dodanie do `classpath` ścieżki do biblioteki zewnętrznej w konfiguracji SceneBuildera.

```ini
[Application]
app.name=SceneBuilder
app.mainjar=dist.jar
app.version=8.5.0
app.preferences.id=com/oracle/javafx/scenebuilder/app
app.mainclass=com/oracle/javafx/scenebuilder/app/SceneBuilderApp
app.classpath=/home/ttmdear/.m2/repository/com/google/code/gson/gson/2.8.5/gson-2.8.5.jar:/home/ttmdear/workspace/httpio/target/httpio-1.0.1-pre-alpha.jar
app.runtime=$APPDIR/runtime
app.identifier=com.oracle.javafx.scenebuilder.app

[JVMOptions]

[JVMUserOptions]

[ArgOptions]
```

Po tej zmianie, kontrolka zaczęła się wyświetlać.

**Musiałem dodać ścieżkę do głównego projektu !**

Okazało się również, ze aby SceneBuilder poprawnie odczytał kontrolkę trzeba zadbać aby kod poprawnie się wykonywał. Np. miałem kontrolkę w której doczepiałem menu.

```java
setCellFactory(new Callback<TreeView<ItemWrapper>, TreeCell<ItemWrapper>>() {
    @Override
    public TreeCell<ItemWrapper> call(TreeView<ItemWrapper> itemWrapperTreeView) {
        return new TreeCell<ItemWrapper>() {
            Text text = new Text();
            RequestLabel label = new RequestLabel();

            @Override
            protected void updateItem(ItemWrapper item, boolean empty) {
                super.updateItem(item, empty);
				// ...
                // W tym miejscu item == null, co powodowało że kontrolka nie mogła się czytać.
                attachContextMenu(this, item);
            }
        };
    }
});

```

**Trzeba zawracać uwagę na to co piszę się w konstruktorze, ponieważ SceneBuilder wywołuje konstruktor. Jeśli występuje jakiś wyjątek w konstorze to może on być powodem błędu.**
## Zmienna `JAVA_HOME`

[//]: "java-home"

Jest to zmienna środowiskowa zawierająca ścieżkę wskazująca na katalog z javą.

Pod Windows może to być `C:\Program Files\Java\jdk1.8.0_151`.
## Przestrzeń `java.security  `

[//]: "java-security"

Zawiera wszystkie klasy i interfejsu związane z:

- szyfrowanie,
- podpisywanie,
- bezpieczeństwem.
## Tworzenie skrótów `MD5, SHA-1, SHA-256`

[//]: "hash-functions-md5-sha1-sha256"

Podstawowym mechanizmem do obliczania skrótów z wiadomości jest `MessageDigest`.

```java
try {
    byte[] bytesOfMessage = password.getText().toString().getBytes("UTF-8");
    MessageDigest md = MessageDigest.getInstance("MD5");

    md.update(bytesOfMessage);

    byte[] thedigest = md.digest();
} catch (UnsupportedEncodingException e) {
    e.printStackTrace();
}

```

Dostępne są funkcję skrótu:

- MD5
- SHA-1
- SHA-256

Inny przykład z kodowanie hasła za pomocą `MD5`.

```java
String password = "123456";

MessageDigest md = MessageDigest.getInstance("MD5");
byte[] hashInBytes = md.digest(password.getBytes(StandardCharsets.UTF_8));

StringBuilder sb = new StringBuilder();
for (byte b : hashInBytes) {
    sb.append(String.format("%02x", b));
}
System.out.println(sb.toString());
```
## Tworzenie sumy kontrolnej pliku

[//]: "creating-check-sum"

```java
package com.mkyong.hashing;

import java.io.FileInputStream;
import java.io.IOException;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class FileCheckSum {

    public static void main(String[] args) throws NoSuchAlgorithmException, IOException {

        MessageDigest md = MessageDigest.getInstance("MD5");
        byte[] hashInBytes = checksum("d:\\server.log", md);
        System.out.println(bytesToHex(hashInBytes));

    }

    private static byte[] checksum(String filepath, MessageDigest md) throws IOException {

        try (DigestInputStream dis = new DigestInputStream(new FileInputStream(filepath), md)) {
            while (dis.read() != -1) ; //empty loop to clear the data
            md = dis.getMessageDigest();
        }

        return md.digest();

    }

    private static String bytesToHex(byte[] hashInBytes) {

        StringBuilder sb = new StringBuilder();
        for (byte b : hashInBytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();

    }

}
```
## Dokumentacja `pre, code, @code`

[//]: "pre-code-atcode"

Java wspiera trzy typy umieszczania fragmentów kodu w dokumentacji funkcji.

| Situation                           | Code Markup Feature       | Rationale                                                    |
| ----------------------------------- | ------------------------- | ------------------------------------------------------------ |
| Inline code snippet                 | `{@code ... }`            | With `{@code ...}`, you don’t need to escape special characters. For inline snippets, it doesn’t matter that line breaks are lost. |
| Multi-line Java code snippets       | `<pre>...</pre>`          | For multi-line snippets you need line breaks. So only `<pre>...</pre>` and `<pre>{@code ...}</pre>` are options. However, only `<pre>...</pre>` allows the use of `'@'` (escaped using HTML number codes), which you need for Java code containing annotations. |
| Multi-line HTML / XML code snippets | `<pre>{@code ... }</pre>` | In HTML or XML code you probably need `'<'` and `'>'` more often than `'@'` , so it doesn’t matter that `'@'` cannot be displayed. If you need an `'@'`, you have to fall back on `<pre>`and HTML number codes. |
## Interfejs znacznikowy

[//]: "info-interface"

Jest to interfejs który nie ma żadnej metody, może zostać użyta do ograniczenia wejścia metody lub wskazania kompilatorowi jakiego typu jest klasa. Przykładem jest klasa `java.io.Serializable`.
## ThreadLocal

[//]: "thread-local"

Jest to obiekt przetrzymujący wartość w kontekście określonego wątku.

```java
final ThreadLocal<Integer> threadLocal = new ThreadLocal<>();

threadLocal.set(10);

System.out.println("Główny watek przed po zmianie: : " + threadLocal.get());

new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Inny watek przed zmianą: " + threadLocal.get());

        threadLocal.set(20);

        System.out.println("Inny watek przed po zmianie: : " + threadLocal.get());
    }
}).start();

System.out.println("Główny watek po zmianie: : " + threadLocal.get());
```

Czyli mamy jedną zmienną która przechowuje różne wartości w zależności od wątku w którym aktualnie działa.

Funkcja `get` działa w taki sposób, że pobiera aktualny wątek następnie z tego wątku wyciąga ThreadLocalMap.

```java
Thread t = Thread.currentThread();
ThreadLocalMap map = getMap(t);
if (map != null) {
    ThreadLocalMap.Entry e = map.getEntry(this);
    if (e != null) {
        @SuppressWarnings("unchecked")
        T result = (T)e.value;
        return result;
    }
}
```

ThreadLocal nie powinien być używany w razem z ServiceExecutor dlatego, że nie mamy pewności w jakich wątkach zostaną wykonane konkretne zadania.

> If we want to use an *ExecutorService* and submit a *Runnable* to it, using *ThreadLocal* will yield non-deterministic results – because we do not have a guarantee that every *Runnable* action for a given *userId* will be handled by the same thread every time it is executed.
>
> Because of that, our *ThreadLocal* will be shared among different *userIds.* That's why we should not use a *TheadLocal* together with *ExecutorService.* It should only be used when we have full control over which thread will pick which runnable action to execute.
## Try-with-resource

[//]: "try-with-resource"

Tego typu konstrukcję możemy nazwać cukrem syntaktycznym (ang. *syntactic sugar*). Takie konstrukcje upraszczają kod, jednak nie są niezbędne dla języka programowania. Innymi słowy programista mógłby sobie bez takich konstrukcji poradzić, jednak ich obecność zmniejsza ilość kodu, która jest potrzebna do wykonania tego samego zadania. 

```java
BufferedReader fileReader = null;
try {
    fileReader = new BufferedReader(new FileReader(inputPath));
    fileReader.readLine();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fileReader != null) {
        try {
            fileReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Prawda, że dużo tego? I tu z pomocą przychodzi konstrukcja try-with-resources, zobacz proszę jak ona wygląda:

```java
try(BufferedReader fileReader = new BufferedReader(new FileReader(inputPath))) {
    fileReader.readLine();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}
```

Konstrukcja wygląda jak `try`/`catch` z tym, że przez blokiem objętym `try` możemy zainicjalizować zmienne, które zostaną automatycznie zamknięte. Kompilator widząc konstrukcję try-with-resources wygeneruje za nas kod zbliżony do tego z pierwszego przykładu (w podobny sposób generuje np. domyślne konstruktory).

Konstrukcję try-with-resources możemy nazwać także „menadżerem kontekstu”, automatycznie zarządza ona za nas kontekstem, w ramach którego dostępne są zmienne zdefiniowane wewnątrz nawiasów `()`. Co więcej, wewnątrz tych nawiasów możemy zainicjalizować więcej zmiennych, każda z nich zostanie poprawnie zamknięta (zostanie na nich wywołana metoda `close`). W przykładzie poniżej odczytujemy linijkę z pliku wejściowego i zapisujemy ją do pliku wyjściowego (tutaj pominąłem obsługę wyjątków):

```
try(
    BufferedReader fileReader = new BufferedReader(new FileReader(inputPath));
    BufferedWriter fileWriter = new BufferedWriter(new FileWriter(outputPath))
) {
    String line = fileReader.readLine();
    fileWriter.write(line);
}
```

 Taka struktura tłumaczona jest przez kompilator na sekwencję zagnieżdżonych bloków `try`/`catch`/`finally`. W każdym z tych zagnieżdżonych bloków zarządza kolejną zmienną. Zmienne zamykane są w odwrotnej kolejności niż są deklarowane, zatem w naszym przykładzie pierwszy zostanie zamknięty `fileWriter` po nim `fileReader`. 
## Pętle

[//]: "loops"

```java
int lenght = list.size();

// Odczytanie elementów za pomocą petli for
for(int i = 0; i < lenght; i++) {
    System.out.println("Element" + i + " = " + list.get(i));
}

// Foreach
for(String element: list) {
    System.out.println(element);
}
```

Zwykła pętla `for` wygląda tak samo jak w innych językach. Natomiast pętla `foreach` jest zapisywana przez `for(... : ...)` i nie wspiera `key`.
## Przestrzeń `java.util`

[//]: "java-util"

Zawiera listę różnych klas.

https://docs.oracle.com/javase/8/docs/api/java/util/package-summary.html
## Obiekt `ArrayList`

[//]: "array-list"

Jest to implementacja prostej listy w Javie. Lista dynacznie się rozszerza.

`ArrayList` implementuje interfejs `List` która zwiera większość metod za pomocą których można operować na takiej liście.

Dodatkowo implementuje również `RandomAccess, Cloneable, Serializable`.
## Typy danych

[//]: "data-types"

| Typ     | Wielkość | Opis                                                         |
| ------- | -------- | ------------------------------------------------------------ |
| byte    | 1 byte   | Stores whole numbers from -128 to 127                        |
| short   | 2 bytes  | Stores whole numbers from -32,768 to 32,767                  |
| int     | 4 bytes  | Stores whole numbers from -2,147,483,648 to 2,147,483,647    |
| long    | 8 bytes  | Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
| float   | 4 bytes  | Stores fractional numbers from 3.4e−038 to 3.4e+038. Sufficient for storing 6 to 7 decimal digits |
| double  | 8 bytes  | Stores fractional numbers from 1.7e−308 to 1.7e+038. Sufficient for storing 15 decimal digits |
| boolean | 1 byte   | Stores true or false values                                  |
| char    | 2 bytes  | Stores a single character/letter                             |
| String  |          |                                                              |

Poniżej jest przykładowy program wyświetlający wszystkie typy zmiennych.

```java
public class Main {
    public static void main(String[] args){
        byte varbyte = 127;
        System.out.println(varbyte);

        short varshort = 32767;
        System.out.println(varshort);

        int varint = 2147483647;
        System.out.println(varint);

        long varlong = 2147483647;
        System.out.println(varlong);

        float varfloat = 1.10f;
        System.out.println(varfloat);

        double vardouble = 2.20d;
        System.out.println(vardouble);

        boolean varboolean = true;
        System.out.println(varboolean);

        char varchar = 'a';
        System.out.println(varchar);

        String name = "I'm java programmer.";
        System.out.println(name);
    }
}
```
## WebJars

[//]: "web-jars"

Są to pliki (archiwa) przechowujące zależności po stronie klienta. Pliki WebJars są np. wykorzystywane przy różnego rodzaju komponentach JavaScriptowych np. biblioteka Bootstrap, jQuery. 

Pliki WebJars mogą być zarządzane przez Mavena lub inny menadźery pakietów. 

Strona z listą: https://www.webjars.org/

Dodanie komponentu sprawdza się do zdefniowania zależności w pliku `.pom` i załączeniu.

```xml
<dependency>
    <groupId>org.webjars</groupId>
    <artifactId>jquery</artifactId>
    <version>3.4.1</version>
</dependency>
```
## Generowanie liczb losowych

[//]: "generate-random-numbers"

Java udostępnia kilka sposób na generowanie wartości losowych.

```java
private void testMatch(int min, int max) {
    int randomValue = (int) ((Math.random() * (max - min)) + min);
}

private void testRandom(int min, int max) {
    Random random = new Random();
    int randomValue = random.nextInt(max - min) + min;
}

private void testThreadLocalRandom(int min, int max) {
    int randomValue = ThreadLocalRandom.current().nextInt(min, max);
}

private void testSplittableRandom(int min, int max) {
    SplittableRandom splittableRandom = new SplittableRandom();
    int randomValue = splittableRandom.nextInt(min, max);
}

private void testSecureRandom(int min, int max) {
    SecureRandom secureRandom = new SecureRandom();
    int randomValue = secureRandom.nextInt(max - min) + min;
}
```
## Konwertowanie Double to Long

[//]: "conver-double-to-long"

```java
// Przez rzutowanie
Assert.assertEquals(9999, (long) 9999.999);

// metoda longValue
Assert.assertEquals(9999, Double.valueOf(9999.999).longValue());

Assert.assertEquals(9999, Math.round(9999.0));
Assert.assertEquals(9999, Math.round(9999.444));
Assert.assertEquals(10000, Math.round(9999.999));
```
## Zwracanie kilku wartości

[//]: "retruns-few-values"

W zasadzie Java pozwala na zwracanie jednej wartości z funkcji/metody.  W sytuacji gdy potrzebujemy zwrócić więcej wartości możemy użyć różnych struktur:

- Arrays

  ```java
  double[] getCoordinatesDoubleArray() {
     
      double[] coordinates = new double[2];
   
      coordinates[0] = 10;
      coordinates[1] = 12.5;
     
      return coordinates;
  }
  ```

- Collections

  ```java
  List<Number> getCoordinatesList() {
     
      List<Number> coordinates = new ArrayList<>();
     
      coordinates.add(10);  // Integer
      coordinates.add(12.5);  // Double
     
      return coordinates;
  }
  ```

- Map

  ```java
  Map<String, Number> getCoordinatesMap() {
     
      Map<String, Number> coordinates = new HashMap<>();
     
      coordinates.put("longitude", 10);
      coordinates.put("latitude", 12.5);
     
      return coordinates;
  }
  ```

- Kontenera

  ```java
  public class Coordinates {
     
      private double longitude;
      private double latitude;
      private String placeName;
     
      public Coordinates(double longitude, double latitude, String placeName) {
     
          this.longitude = longitude;
          this.latitude = latitude;
          this.placeName = placeName;
      }
     
      // getters and setters
  }
  ```

- Tuple

  Jest lista elementów, gdzie na każdy element jest określony przechowywany typ. Istnieje kilka implementacji `TupleN` gdzie N definiuje ilość elementów.

  ```java
  public class Tuple2<K, V> {
   
      private K first;
      private V second;
     
      public Tuple2(K first, V second){
          this.first = first;
          this.second = second;
      }
   
      // getters and setters
  }
  ```

## Szyfrowanie/deszyfrowanie, podpis/weryfikacja

[//]: "enctryp-and-sign"

```java
import javax.crypto.Cipher;
import java.io.InputStream;
import java.security.*;
import java.util.Base64;

import static java.nio.charset.StandardCharsets.UTF_8;

public class RsaExample {
    public static KeyPair generateKeyPair() throws Exception {
        KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
        generator.initialize(2048, new SecureRandom());
        KeyPair pair = generator.generateKeyPair();

        return pair;
    }

    public static KeyPair getKeyPairFromKeyStore() throws Exception {
        //Generated with:
        //  keytool -genkeypair -alias mykey -storepass s3cr3t -keypass s3cr3t -keyalg RSA -keystore keystore.jks

        InputStream ins = RsaExample.class.getResourceAsStream("/keystore.jks");

        KeyStore keyStore = KeyStore.getInstance("JCEKS");
        keyStore.load(ins, "s3cr3t".toCharArray());   //Keystore password
        KeyStore.PasswordProtection keyPassword =       //Key password
                new KeyStore.PasswordProtection("s3cr3t".toCharArray());

        KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry("mykey", keyPassword);

        java.security.cert.Certificate cert = keyStore.getCertificate("mykey");
        PublicKey publicKey = cert.getPublicKey();
        PrivateKey privateKey = privateKeyEntry.getPrivateKey();

        return new KeyPair(publicKey, privateKey);
    }

    public static String encrypt(String plainText, PublicKey publicKey) throws Exception {
        Cipher encryptCipher = Cipher.getInstance("RSA");
        encryptCipher.init(Cipher.ENCRYPT_MODE, publicKey);

        byte[] cipherText = encryptCipher.doFinal(plainText.getBytes(UTF_8));

        return Base64.getEncoder().encodeToString(cipherText);
    }

    public static String decrypt(String cipherText, PrivateKey privateKey) throws Exception {
        byte[] bytes = Base64.getDecoder().decode(cipherText);

        Cipher decriptCipher = Cipher.getInstance("RSA");
        decriptCipher.init(Cipher.DECRYPT_MODE, privateKey);

        return new String(decriptCipher.doFinal(bytes), UTF_8);
    }

    public static String sign(String plainText, PrivateKey privateKey) throws Exception {
        Signature privateSignature = Signature.getInstance("SHA256withRSA");
        privateSignature.initSign(privateKey);
        privateSignature.update(plainText.getBytes(UTF_8));

        byte[] signature = privateSignature.sign();

        return Base64.getEncoder().encodeToString(signature);
    }

    public static boolean verify(String plainText, String signature, PublicKey publicKey) throws Exception {
        Signature publicSignature = Signature.getInstance("SHA256withRSA");
        publicSignature.initVerify(publicKey);
        publicSignature.update(plainText.getBytes(UTF_8));

        byte[] signatureBytes = Base64.getDecoder().decode(signature);

        return publicSignature.verify(signatureBytes);
    }

    public static void main(String... argv) throws Exception {
        //First generate a public/private key pair
        KeyPair pair = generateKeyPair();
        //KeyPair pair = getKeyPairFromKeyStore();

        //Our secret message
        String message = "the answer to life the universe and everything";

        //Encrypt the message
        String cipherText = encrypt(message, pair.getPublic());

        //Now decrypt it
        String decipheredMessage = decrypt(cipherText, pair.getPrivate());

        System.out.println(decipheredMessage);

        //Let's sign our message
        String signature = sign("foobar", pair.getPrivate());

        //Let's check the signature
        boolean isCorrect = verify("foobar", signature, pair.getPublic());
        System.out.println("Signature correct: " + isCorrect);
    }
}
```
## Hamcrest
Jest to biblioteka ze zbiorem asercji.

```java
import org.junit.jupiter.api.Test;
import static org.hamcrest.MatcherAssert.assertThat; 
import static org.hamcrest.Matchers.*;

public class BiscuitTest {
  @Test 
  public void testEquals() { 
    Biscuit theBiscuit = new Biscuit("Ginger"); 
    Biscuit myBiscuit = new Biscuit("Ginger"); 
    assertThat(theBiscuit, equalTo(myBiscuit)); 
  } 
}

assertThat("chocolate chips", theBiscuit.getChocolateChipCount(), equalTo(10)); 
assertThat("hazelnuts", theBiscuit.getHazelnutCount(), equalTo(3));
```
## JAXB
Biblioteka do obsługi XML. Posiada rozbudowany mechanizm mapowania plików XML na obiekty.
## Porównywanie numerów wersji

[//]: "compare-versions-numbers"

Istnieje kilka bibliotek za pomocą których można porównywać ze sobą wartości wersji.

**Biblioteka maven-artifact**

------

```xml
<dependency>
    <groupId>org.apache.maven</groupId>
    <artifactId>maven-artifact</artifactId>
    <version>3.6.3</version>
</dependency>
```

Porównanie wersji.

```java
ComparableVersion version1_1 = new ComparableVersion("1.1");
ComparableVersion version1_2 = new ComparableVersion("1.2");
ComparableVersion version1_3 = new ComparableVersion("1.3");
 
assertTrue(version1_1.compareTo(version1_2) < 0);
assertTrue(version1_3.compareTo(version1_2) > 0);
```

Biblioteka obsługuje dowolny poziom zagnieżdżenia. Dodatkowo można użyć symboli `-` aby uwzględnić kwalfikatory.

```java
ComparableVersion version1_1_beta = new ComparableVersion("1.1-beta");
ComparableVersion version1_1_milestone = new ComparableVersion("1.1-milestone");
ComparableVersion version1_1_rc = new ComparableVersion("1.1-rc");
ComparableVersion version1_1_snapshot = new ComparableVersion("1.1-snapshot");
 
assertTrue(version1_1_alpha.compareTo(version1_1_beta) < 0);
assertTrue(version1_1_beta.compareTo(version1_1_milestone) < 0);
assertTrue(version1_1_rc.compareTo(version1_1_snapshot) < 0);
assertTrue(version1_1_snapshot.compareTo(version1_1) < 0);
```

**Biblioteka gradle-core**

------

Również udostępnia tego typu mechanizmy.

```xml
<dependency>
    <groupId>org.gradle</groupId>
    <artifactId>gradle-core</artifactId>
    <version>6.1.1</version>
</dependency>
```

Przykład.

```java
VersionNumber version1_1 = VersionNumber.parse("1.1");
VersionNumber version1_2 = VersionNumber.parse("1.2");
VersionNumber version1_3 = VersionNumber.parse("1.3");
 
assertTrue(version1_1.compareTo(version1_2) < 0);
assertTrue(version1_3.compareTo(version1_2) > 0);
 
VersionNumber version1_1_0 = VersionNumber.parse("1.1.0");
assertEquals(0, version1_1.compareTo(version1_1_0));

VersionNumber version1_1_1_1_alpha = VersionNumber.parse("1.1.1.1-alpha"); 
assertTrue(version1_1.compareTo(version1_1_1_1_alpha) < 0); 
 
VersionNumber version1_1_beta = VersionNumber.parse("1.1.0.0-beta"); 
assertTrue(version1_1_beta.compareTo(version1_1_1_1_alpha) < 0);
```

**Biblioteki pozostałe**

------

Inne biblioteki w których można znaleźć takie mechanizy :

- jackson-core,
- Semver4J.

**Własne rozwiązanie**

------

```java
public static int compareVersions(String version1, String version2) {
    int comparisonResult = 0;
    
    String[] version1Splits = version1.split("\\.");
    String[] version2Splits = version2.split("\\.");
    int maxLengthOfVersionSplits = Math.max(version1Splits.length, version2Splits.length);
 
    for (int i = 0; i < maxLengthOfVersionSplits; i++){
        Integer v1 = i < version1Splits.length ? Integer.parseInt(version1Splits[i]) : 0;
        Integer v2 = i < version2Splits.length ? Integer.parseInt(version2Splits[i]) : 0;
        int compare = v1.compareTo(v2);
        if (compare != 0) {
            comparisonResult = compare;
            break;
        }
    }
    return comparisonResult;
}

assertTrue(VersionCompare.compareVersions("1.0.1", "1.1.2") < 0);
assertTrue(VersionCompare.compareVersions("1.0.1", "1.10") < 0);
assertTrue(VersionCompare.compareVersions("1.1.2", "1.0.1") > 0);
assertTrue(VersionCompare.compareVersions("1.1.2", "1.2.0") < 0);
assertEquals(0, VersionCompare.compareVersions("1.3.0", "1.3"));
```
## Utworzenie katalogu tymczasowego

[//]: "create-tmp-dir"

```java
String tmpdir = Files.createTempDirectory("tmpDirPrefix").toFile().getAbsolutePath();
String tmpDirsLocation = System.getProperty("java.io.tmpdir");

assertThat(tmpdir).startsWith(tmpDirsLocation);

// Guava
String tmpdir = Files.createTempDir().getAbsolutePath();
String tmpDirsLocation = System.getProperty("java.io.tmpdir");
assertThat(tmpdir).startsWith(tmpDirsLocation);

// Apache Commons IO
String tmpDirsLocation = System.getProperty("java.io.tmpdir");
Path path = Paths.get(FileUtils.getTempDirectory().getAbsolutePath(), UUID.randomUUID().toString());

String tmpdir = Files.createDirectories(path).toFile().getAbsolutePath();

assertThat(tmpdir).startsWith(tmpDirsLocation);
```

Usunięcie katalogu po wyjściu z programu.

```java
tmpdir.toFile().deleteOnExit()
```

Nadanie uprawnień dla katalogu

```java
FileAttribute<Set> attrs = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString("r--------"));

Path tmpdir = Files.createTempDirectory(Paths.get("target"), "tmpDirPrefix", attrs);

assertThat(tmpdir.toFile().getPath()).startsWith("target");
assertThat(tmpdir.toFile().canWrite()).isFalse();
```
## Połączenie SSH

[//]: "connect-ssh"

Do połączenia SSH można wykorzystać bibliotekę JSch

```xml
<dependency>
    <groupId>com.jcraft</groupId>
    <artifactId>jsch</artifactId>
    <version>0.1.55</version>
</dependency>
```

Listowanie katalogów

```java
public static void listFolderStructure(String username, String password, String host, int port, String command) throws Exception {
    Session session = null;
    ChannelExec channel = null;
    
    try {
        session = new JSch().getSession(username, host, port);
        session.setPassword(password);
        session.setConfig("StrictHostKeyChecking", "no");
        session.connect();
        
        channel = (ChannelExec) session.openChannel("exec");
        channel.setCommand(command);
        
        ByteArrayOutputStream responseStream = new ByteArrayOutputStream();
        
        channel.setOutputStream(responseStream);
        channel.connect();
        
        while (channel.isConnected()) {
            Thread.sleep(100);
        }
        
        String responseString = new String(responseStream.toByteArray());
        System.out.println(responseString);
    } finally {
        if (session != null) {
            session.disconnect();
        }
        if (channel != null) {
            channel.disconnect();
        }
    }
}
```

Alternatywnym rozwiązaniem jest biblioteka Apache MINA SSHD

```xml
<dependency>
    <groupId>org.apache.sshd</groupId>
    <artifactId>sshd-core</artifactId>
    <version>2.5.1</version>
</dependency>
```

```java
public static void listFolderStructure(String username, String password, String host, int port, long defaultTimeoutSeconds, String command) throws IOException {
    
    SshClient client = SshClient.setUpDefaultClient();
    client.start();
    
    try (ClientSession session = client.connect(username, host, port)
      .verify(defaultTimeoutSeconds, TimeUnit.SECONDS).getSession()) {
        session.addPasswordIdentity(password);
        session.auth().verify(defaultTimeoutSeconds, TimeUnit.SECONDS);
        
        try (ByteArrayOutputStream responseStream = new ByteArrayOutputStream(); 
          ClientChannel channel = session.createChannel(Channel.CHANNEL_SHELL)) {
            channel.setOut(responseStream);
            try {
                channel.open().verify(defaultTimeoutSeconds, TimeUnit.SECONDS);
                try (OutputStream pipedIn = channel.getInvertedIn()) {
                    pipedIn.write(command.getBytes());
                    pipedIn.flush();
                }
            
                channel.waitFor(EnumSet.of(ClientChannelEvent.CLOSED), 
                TimeUnit.SECONDS.toMillis(defaultTimeoutSeconds));
                String responseString = new String(responseStream.toByteArray());
                System.out.println(responseString);
            } finally {
                channel.close(false);
            }
        }
    } finally {
        client.stop();
    }
}
```
## Pakiet java i javax

[//]: "package-javax"

`java` jest to podstawy pakiet dla Javy. Zawiera wszystkie sprawdzone klasy. `javax` jest to pakiet tgz. rozszerzeń. Zdarza się tak, że klasy z `javax` przechodzą do pakietu `java`. Podział na pakiety może mieć również wpływ na sposób wczytywania klas, te z pakiety `java` nie są walidowane przez ClassLoadera co znacznie przyspiesza szybkość ich wczytania. Pakiet `javax` zawiera takie rozszerzenia jak definicję ORM, Walidacji itp.
## Metoda `Object.finalize`

[//]: "object-finalize"

Jest to zaraz obok słowa `final, finally` słowo na F. Często jest to pytanie na rozmowie rekrutacyjnej. Metoda wywoływana przez GC zaraz przed wyczyszczeniem obiektu z pamięci. 

```java
class SomeObject {
    @Override //przesłonienie metody z klasy Object
    public void finalize() {
        System.out.println("GC is coming for me!");
    }
}
```

Można by ją wykorzystać np. do zamknięcia zasobów (trochę jak destruktor, ale nie do końca) przed usunięciem obiekty. **Niestety** nie jest zalecane stosowanie jej ponieważ wywołanie tej metody jest uzależnione od strategii działa GC, a ten na różnych JVM w zależności od konfiguracji może działać inaczej. 

Dlatego ta metoda od wersji 9 Javy została oznaczona jako depreciated. Należy ten wspomnieć, że wyjątki które się pojawiają w trakcie wykonywania tej metody w GC zostaną zignorowane. Więc łatwo sobie wyobrazić sytuację w której próbujemy zamknąć zasób i dostajemy błąd IO ale nie jesteśmy w stanie nic z nim zrobić.
